<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
    
     <entry>
        <title>Java常用方法总结</title>
        <url>http://jchenTech.github.io/post/java/java%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
        <categories>
          <category>Java</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>常用方法</tag>
        </tags>
        <content type="html"> String类方法    方法 描述     int length() 返回字符串的长度： return value.length   char charAt(int index) 返回某索引处的字符return value[index]   boolean isEmpty() 判断是否是空字符串：return value.length == 0   String toLowerCase() 使用默认语言环境，将 String 中的所字符转换为小写   String toUpperCase() 使用默认语言环境，将 String 中的所字符转换为大写   String trim() 返回字符串的副本，忽略前导空白和尾部空白   boolean equals(Object obj) 比较字符串的内容是否相同   boolean equalsIgnoreCase(String anotherString) 与equals方法类似，忽略大小写   String concat(String str) 将指定字符串连接到此字符串的结尾。 等价于用“&#43;”   int compareTo(String anotherString) 比较两个字符串的大小   String substring(int beginIndex) 返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。   String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。   boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束   boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始   boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始   boolean contains(CharSequence s) 当且仅当此字符串包含指定的 char 值序列时，返回 true   int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引   int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始   int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引   int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索    替换    方法 描述     String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。   String replace(CharSequence target, CharSequence replacement) 使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。   String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。   String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。    匹配与切片    方法 描述     boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式   String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。   String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。   </content>
    </entry>
    
     <entry>
        <title>十大经典排序算法总结（基于Java实现）</title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%9F%BA%E4%BA%8Ejava%E5%AE%9E%E7%8E%B0/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>排序算法</tag>
        </tags>
        <content type="html"> 排序算法说明 排序的定义 对一序列对象根据某个关键字进行排序。
术语说明  稳定 ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定 ：如果a原本在br的前面，而a=b，排序之后a可能会出现在b的后面； 内排序 ：所有排序操作都在内存中完成； 外排序 ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度 ： 一个算法执行所耗费的时间。 空间复杂度 ：运行完一个程序所需内存的大小。  算法总结 算法分类 比较与非比较的区别 常见的快速排序、归并排序、堆排序、冒泡排序 等属于比较排序 。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置 。
在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。
比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。
计数排序、基数排序、桶排序则属于非比较排序 。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置 。
非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。
非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。
冒泡排序</content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC10 Subtype Polymorphism vs. HoFs</title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec10/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> LEC9 Subtype Polymorphism vs. HoFs
</content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC9 Extends, Casting, Higher Order Functions</title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec9/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> LEC9 Extends, Casting, Higher Order Functions
接口和实现 Interface and Implement 早先我们介绍了类和接口，我们意识到在编写类时，有时会编写很多冗余代码。 这将我们引向继承，即某个对象不需要重新定义其父对象的所有性质。我们可以从接口和类继承，语法略有不同。 对于要继承接口性质的类，语法如下（其中SLList是一个类，而List61B是一个接口）：
SLList&amp;lt;Blorp&amp;gt; implements List61B&amp;lt;Blorp&amp;gt; 类似地，一个类实现另一类性质的方法的语法如下：
Class_Name extends Class_Name 继承的用法 假设我们要创建一种特殊的SLList类型，称为RotatingSLList。 RotatingSLList应该能够执行SLList可以做的所有事情； 但是，它也应该能够向右旋转。 我们应该怎么做？ 好吧，这只是继承的应用！ 执行以下操作将使RotatingSLList具有SLList的所有性质以及它自己的方法rotateRight。
public class RotatingSLList&amp;lt;Blorp&amp;gt; extends SLList&amp;lt;Blorp&amp;gt;{ public void rotateRight() {...} } 什么会被继承？ 现在，我们在继承中有一个强大的工具； 但是，我们将定义一些规则。 现在，我们将说哪些可以继承：
 实例和静态变量 所有方法 所有嵌套类。这会随着引入私有变量而有所变化，但现在不必担心。 没有继承的一项是类的构造函数。  构造函数的特殊情况？ 即使没有继承构造函数，我们仍然会使用它们。 我们可以使用关键字super()显式调用构造函数。 在每个构造函数的开始，已经有一个对其父类的构造函数的隐式调用。 结果是
public VengefulSLList() { deletedItems = new SLList&amp;lt;Item&amp;gt;(); } 等同于
public VengefulSLList() { super(); deletedItems = new SLList&amp;lt;Item&amp;gt;(); } 然而，带参数的构造函数不能被隐式调用。
public VengefulSLList() { super(x); deletedItems = new SLList&amp;lt;Item&amp;gt;(); } 不等同于：
public VengefulSLList() { deletedItems = new SLList&amp;lt;Item&amp;gt;(); } 这是因为这里仅调用了空参数super()。
is A 当一个类从另一个继承时，我们知道它必须具有所有的特质。这意味着VengefulSLList是SLList，因为它具有SLList的所有特质-它也具有其他一些特质。
每个单个类都是Object类的后代，这意味着它们都是Object。
抽象Abstraction 正如您将在本课程的后面学到​​的那样，程序过大时可能会引起混乱。使程序更易于处理的一种方法是使用抽象。基本上，抽象隐藏了人们不需要查看的程序组件。隐藏方法的用户应该能够在不知道它们如何工作的情况下使用它们。
实现抽象动机的一种直观方法是看着自己。您是人类（除非有机器人正在研究这种情况，否则我很抱歉冒犯了您），人类可以食用食物并将其转化为能量。您无需知道如何将食物转化为能量，只需知道它的作用即可。在这种情况下，可以考虑将食物转化为能量的一种方法，输入是食物，而输出是能量。
强制类型转换Casting 在Java中，每个对象都有一个静态类型（在编译时定义）和一个动态类型（在运行时定义）。我们的代码可能基于这样一个事实，即某些变量可能比静态类型更具体。例如，如果我们具有以下定义：
Poodle frank = new Poodle(&amp;#34;Frank&amp;#34;, 5); Poodle frankJr = new Poodle(&amp;#34;Frank Jr.&amp;#34;, 15); 这个表达是合理的：
Dog largerDog = maxDog(frank, frankJr); 但是这个就不合理：
Poodle largerPoodle = maxDog(frank, frankJr); 前一条语句有效的原因是因为编译器知道一个事实，即从maxDog函数调用返回的任何东西都是Dog。 但是，在后一种情况下，即使两个Dog参数都是Poodles，编译器也不知道maxDog的返回值是否会返回Poodle。
除了拥有通用的Dog之外，我们可能会有些冒险并且使用一种称为Casting的技术。 强制转换允许我们强制变量的静态类型，从根本上诱骗编译器让我们强制表达式的静态类型。 为了使largePoodle成为静态类型的Poodle，我们将使用以下代码：
Poodle largerPoodle = (Poodle) maxDog(frank, frankJr); 请注意，我们并没有改变maxDog的实际动态类型-我们只是告诉编译器maxDog会产生的是Poodle。这意味着任何对LargePoodle的引用都将具有与之关联的静态Poodle类型。
Casting虽然功能强大，但也很危险。您需要确保要casting的内容能够并且将实际发生。可以使用一些规则：
 您总是可以转换（到类的更通用版本），而不必担心会破坏任何东西，因为我们知道更具体的版本是通用类的版本。例如，您可以随时将贵宾犬投给狗，因为所有贵宾犬都是狗的。
 您还可以谨慎地强制转换（降级为某个类的特定版本），因为您需要确保在运行时不会传递任何违反您的强制转换的信息。例如，有时候狗是贵宾犬，但并非总是如此。
 最后，您永远都不能转换为高于或低于要转换的类的类。例如，您不能将狗投向猴子，因为猴子不在狗的直接血统之内-它是动物的孩子，因此距离较远。
 </content>
    </entry>
    
     <entry>
        <title>如何删除Github上的文件夹</title>
        <url>http://jchenTech.github.io/post/git/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4github%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
        <categories>
          <category>Git</category>
        </categories>
        <tags>
          <tag>Git</tag><tag>Github</tag>
        </tags>
        <content type="html"> 要知道在github上只能删除仓库,却无法删除文件夹或文件, 所以只能通过命令来解决，
（1）首先进入master文件夹下, Git Bash Here ,打开命令窗口 $ git --help 帮助命令
（2）$ git pull origin master 将远程仓库里面的项目拉下来，$ dir 查看有哪些文件夹
（3）此时$ git rm -r --cached target 删除target文件夹，$ git commit -m &#39;Deleted target&#39; 提交。
（4）最后$ git push -u origin master将本次更改更新到github项目上去，删除完毕。
</content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC8 Inheritance, Implements</title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec8/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> LEC8 Inheritance, Implements
方法重载 Overloading: 在Java中，类方法名字可以相同，但参数不同。例如，Math 类可以具有 add(int a, int b) 方法和 add(float a, float b) 方法。 Java编译器足够智能，可以根据传入的参数选择正确的方法。具有相同名称但不同参数的方法被认为被重载。
使代码通用： 考虑一个仅使用 AList 作为参数的 largestNumber 方法。缺点是，无论我们采用 AList 还是 SLList，largestNumber的逻辑都是相同的。我们只是对不同类型的列表进行操作。如果我们使用以前的方法覆盖的想法，则会导致Java文件很长，并且包含许多类似的方法。这段代码很难维护。如果我们用一种方法修复错误，则必须手动将此修复方法复制到所有其他方法。
解决上述问题的方法是定义一个代表 AList 和 SLList 的新引用类型。我们将其称为 List。接下来，我们指定一个“is-a”关系：AList是一个 List。我们对SLList做同样的事情。让我们将其形式化为代码。
接口 Interface: 我们使用 interface 关键字而非 class 来创建 List。我们写：
public interface List&amp;lt;Item&amp;gt; { ... } 关键思想是接口指定此 List 可以执行的操作，而不是如何做。 由于所有Lists都有一个 get 方法，因此我们将以下方法签名添加到接口类中：
public Item get(int i); 注意，我们没有定义此方法。 我们只是简单地说，只要我们使用List接口，就应该存在此方法。
现在，我们要指定 AList 为一个 List 。 我们将 AList 的类声明更改为：
public AList&amp;lt;Item&amp;gt; implements List&amp;lt;Item&amp;gt; { ... } 我们可以为 SLList 做同样的事情。 现在，回到我们的 largestNumber 方法，而不是为每种类型的列表创建一个方法，我们可以简单地创建一个以 List 为参数的方法。 只要我们的实际对象实现List接口，该方法就可以正常工作！
重写 Overriding： 对于在 List中定义过的 AList 中的每个方法，我们将在方法签名上方添加一个 @Override。 举个例子：
@Override public Item get(int i) { ... } 这不是必需的，但是是好的风格，因此我们将需要它。 此外，它还允许我们检查错别字。 如果我们键入错误的方法名称，则如果具有 @Override 标记，则编译器将阻止我们的编译。
接口继承: 在形式上，我们说子类从超类继承。 接口包含所有方法签名，每个子类必须实现每个单独的签名。 将其视为合同。 另外，关系可以跨越多代。 例如，C可以从B继承，而B可以从A继承。
默认方法 Default Methods: 接口可以具有默认方法。 我们通过以下方式定义：
default public void method() { ... } 我们实际上可以在接口内实现这些方法。 请注意，没有实例变量可以使用，但是我们可以自由使用接口中定义的方法，而不必担心实现。 默认方法应适用于实现该接口的任何类型的对象！ 子类不必在任何地方重新实现默认方法。 他们可以简单地免费调用它。 但是，我们仍然可以覆盖默认方法，并在子类中重新定义该方法。
静态类型与动态类型 Static vs. Dynamic Type： Java中的每个变量都有一个静态类型。 这是在声明变量时指定的类型，并在编译时进行检查。 每个变量都有一个动态类型。 该类型在实例化变量时指定，并在运行时检查。 举个例子：
Thing a; a = new Fox(); 这里，Thing 是静态类型，Fox 是动态类型，这是可以的因为所有的foxes都是things。我们也可以：
Animal b = a; This is fine, because all foxes are animals too. We can do:
Fox c = b; This is fine, because b points to a Fox. Finally, we can do:
a = new Squid() This is fine, because the static type of a is a Thing, and Squid is a thing.
动态方法选择 Dynamic Method Selection： 规则是，如果我们具有静态类型 X 和动态类型 Y，则如果 Y 重写 X 中的方法，则在运行时，我们将在 Y 中使用该方法。 学生经常混淆重写和重载。
重载和动态方法选择： 对于重载方法，动态方法选择不起作用。 考虑下面的代码，Fox扩展了Animal。
1 Fox f = new Fox(); 2 Animal a = f; 3 define(f); 4 define(a); 假设我们在同一个类中有以下的重载方法：
public static void define(Fox f) { ... } public static void define(Animal a) { ... } 第3行将执行 define(Fox f)，而第4行将执行 define(Animal a)。 动态方法选择仅在我们重写方法时才适用。 这里没有重写，因此动态方法选择不适用。
</content>
    </entry>
    
     <entry>
        <title>【CS61B】链表IntList、SLList、DLList、AList整理</title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61b%E9%93%BE%E8%A1%A8intlistsllistdllistalist/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> 本文整理了CS61B中的链表IntList、SLList、DLList、AList实现。
IntList public class IntList { public int first; public IntList rest; public IntList(int f, IntList r) { first = f; rest = r; } /** Return the size of the list using... recursion! */ public int size() { if (this.rest == null) {/* base case */ return 1; } return 1 &#43; this.rest.size(); } /** Return the size of the list using no recursion! */ public int iterativeSize() { /* You can not assign &amp;#34;this&amp;#34; in Java*/ IntList p = this; int totalSize = 0; while (p != null) { totalSize &#43;= 1; p = p.rest; } return totalSize; } /** Returns the ith value in this list.*/ public int get(int i) { IntList p = this; int nth = 0; if (i &amp;gt;= p.size()) { return -1; } while (nth != i) { p = p.rest; nth &#43;= 1; } return p.first; } public static void main(String[] args) { IntList L = new IntList(15, null); L = new IntList(10, L); L = new IntList(5, L); System.out.println(L.size()); System.out.println(L.iterativeSize()); System.out.println(L.get(2)); } }  SLList /** An SLList is a list of integers, which hides the terrible truth * of the nakedness within. */ public class SLList { private static class IntNode { public int item; public IntNode next; public IntNode(int i, IntNode n) { item = i; next = n; System.out.println(size); } } /* The first item (if it exists) is at sentinel.next. */ private IntNode sentinel; private int size; private static void lectureQuestion() { SLList L = new SLList(); IntNode n = IntNode(5, null); } /** Creates an empty SLList. */ public SLList() { sentinel = new IntNode(63, null); size = 0; } public SLList(int x) { sentinel = new IntNode(63, null); sentinel.next = new IntNode(x, null); size = 1; } /** Adds x to the front of the list. */ public void addFirst(int x) { sentinel.next = new IntNode(x, sentinel.next); size = size &#43; 1; } /** Returns the first item in the list. */ public int getFirst() { return sentinel.next.item; } /** Adds x to the end of the list. */ public void addLast(int x) { size = size &#43; 1; IntNode p = sentinel; /* Advance p to the end of the list. */ while (p.next != null) { p = p.next; } p.next = new IntNode(x, null); } /** Returns the size of the list. */ public int size() { return size; } public static void main(String[] args) { /* Creates a list of one integer, namely 10 */ SLList L = new SLList(); L.addLast(20); System.out.println(L.size()); } } DLList(LinkedListDeque链表双边队列) /** * Created by JianjunChen on 08/16/2020 * This is a Linked List Doubly ended queue Data Structure using Lists! * @Rule The amount of memory that your program uses at any given time must be * proportional to the number of items. * @Rule Do not maintain references to items that are no longer in the deque. * @Rule Implement all the methods listed above in “The Deque API” section. */ public class LinkedListDeque&amp;lt;T&amp;gt; { /**LinkedNode Nested Class*/ private class LinkedNode { private LinkedNode prev; /* Doubly Linked List*/ private T item; private LinkedNode next; public LinkedNode(LinkedNode p, T i, LinkedNode n) { prev = p; item = i; next = n; } } private LinkedNode sentinel; //private LinkedNode last; private int size; /** Constructor of LinkedListDeque */ public LinkedListDeque() { sentinel = new LinkedNode(null, null, null); sentinel.prev = sentinel; sentinel.next = sentinel; //last = sentinel; size = 0; } /** Adds an item of type T to the front of the deque.*/ public void addFirst(T item) { LinkedNode first = new LinkedNode(sentinel, item, sentinel.next); /* Note that the order cannot be reversed since if we firstly write * sentinel.next = first; the sentinel.next.prev will equal to first.prev!!!!*/ sentinel.next.prev = first; sentinel.next = first; size &#43;= 1; } /** Adds an item of type T to the back of the deque. */ public void addLast(T item) { LinkedNode last = new LinkedNode(sentinel.prev, item, sentinel); /* Note that the order cannot be reversed!!! */ sentinel.prev.next = last; sentinel.prev = last; size &#43;= 1; } /** Returns true if deque is empty, false otherwise. */ public boolean isEmpty() { if (sentinel.next == sentinel) { return true; } return false; } /** Returns the number of items in the deque. */ public int size() { return size; } /* Prints the items in the deque from first to last, separated by a space. */ public void printDeque() { LinkedNode p = sentinel; while (p.next != sentinel) { System.out.print(p.next.item &#43; &amp;#34; &amp;#34;); p = p.next; } } /** Removes and returns the item at the front of the deque. If no such item exists, returns null.*/ public T removeFirst() { if (isEmpty()) { return null; } T firstItem = sentinel.next.item; /* Note that the order cannot be reversed!!!*/ sentinel.next.next.prev = sentinel; sentinel.next = sentinel.next.next; size -= 1; return firstItem; } /** Removes and returns the item at the back of the deque. * If no such item exists, returns null. */ public T removeLast() { if (isEmpty()) { return null; } T lastItem = sentinel.prev.item; /* Note that the order cannot be reversed!!! */ sentinel.prev.prev.next = sentinel; sentinel.prev = sentinel.prev.prev; size -= 1; return lastItem; } /** Gets the item at the given index, where 0 is the front, 1 is the next item, * and so forth. If no such item exists, returns null. Must not alter the deque! */ public T get(int index) { if (index &amp;gt; size - 1) { return null; } LinkedNode p = sentinel.next; int i = 0; while (i != index) { p = p.next; i &#43;= 1; } return p.item; } /** Helper method for getRecursive */ private T getRecursiveHelper(LinkedNode currentNode, int index) { if (index == 0) { return currentNode.item; } return getRecursiveHelper(currentNode.next, index - 1); } /** Same as get but using recursion!! */ public T getRecursive(int index) { if (index &amp;gt; size - 1) { return null; } return getRecursiveHelper(sentinel.next, index); } } AList(ArrayDeque数组双边队列) /** * Created by JianjunChen on 08/18/2020 * This is a Array based Doubly Ended Queue Data Structure!! * @Rule The starting size of your array should be 8. * @Rule Implement all the methods listed above in “The Deque API” section. * @Rule The amount of memory that at any given time must be proportional to the number * of items. For arrays of length 16 or more, your usage factor should always be at least 25%. * */ // Circular ArrayDeque public class ArrayDeque&amp;lt;T&amp;gt; { private int initialCapacity = 8; //initial array capacity private int capacity; //current array capacity private int eFactor = 2; //expanding factor private double usageFactor; private int mCapacity = 16; // The minimum capacity for contraction private double mRatio = 0.25; //The minimum usage ratio before contraction private int cFactor = 2; //contraction factor private T[] items; private int size; private int nextFirst; private int nextLast; public ArrayDeque() { capacity = initialCapacity; items = (T[]) new Object[initialCapacity]; size = 0; nextFirst = 4; nextLast = 5; } /** Finding the next nextFirst and nextLast index in circle ArrayDeque. */ private int oneMinus(int index) { if (index == 0) { // whether the index is out of bounds! index = capacity - 1; } else { index -= 1; } return index; } private int onePlus(int index) { if (index == capacity - 1) { // whether the index is out of bounds! index = 0; } else { index &#43;= 1; } return index; } /** Resize the original array to a new array with given capacity. */ private void resize(int newCapacity) { T[] a = (T[]) new Object[newCapacity]; int currentFirst = onePlus(nextFirst); int currentLast = oneMinus(nextLast); if (currentFirst &amp;lt; currentLast) { int length = currentLast - currentFirst &#43; 1; System.arraycopy(items, currentFirst, a, 0, length); nextFirst = newCapacity - 1; nextLast = length; } else { int firstRightCount = capacity - currentFirst; int firstLeftCount = capacity - firstRightCount; System.arraycopy(items, currentFirst, a, 0, firstRightCount); System.arraycopy(items, 0, a, firstRightCount, firstLeftCount); nextFirst = newCapacity - 1; nextLast = capacity; } capacity = newCapacity; items = a; } /** Adds an item of type T to the front of the deque. * @Rule Must take constant time, except during resizing operations. */ public void addFirst(T item) { items[nextFirst] = item; size &#43;= 1; nextFirst = oneMinus(nextFirst); //The array is full, needed resize operation! if (size == capacity) { resize(size * eFactor); } } /** Adds an item of type T to the back of the deque. * @Rule Must take constant time, except during resizing operations. */ public void addLast(T item) { items[nextLast] = item; size &#43;= 1; nextLast = onePlus(nextLast); //The array is full, needed resize operation! if (size == capacity) { resize(size * eFactor); } } /** Returns true if deque is empty, false otherwise. */ public boolean isEmpty() { if (size == 0) { return true; } return false; } /** Returns the number of items in the deque. */ public int size() { return size; } /** Prints the items in the deque from first to last, separated by a space. */ public void printDeque() { if (isEmpty()) { return; } int index = onePlus(nextFirst); while (index != nextLast) { System.out.print(items[index] &#43; &amp;#34; &amp;#34;); index = onePlus(index); } } private void contract() { usageFactor = (double) size / capacity; if (usageFactor &amp;lt;= mRatio &amp;amp;&amp;amp; capacity &amp;gt;= mCapacity) { int newCapacity = capacity / cFactor; resize(newCapacity); } } /** Removes and returns the item at the back of the deque. If no such item exists, returns null. * @Rule must take constant time, except during resizing operations. */ public T removeFirst() { if (isEmpty()) { return null; } int currentFirst = onePlus(nextFirst); T currentFirstItem = items[currentFirst]; nextFirst = currentFirst; items[nextFirst] = null; size -= 1; contract(); return currentFirstItem; } /** Removes and returns the item at the back of the deque. If no such item * exists, returns null.. * @Rule must take constant time, except during resizing operations. */ public T removeLast() { if (isEmpty()) { return null; } int currentLast = oneMinus(nextLast); T currentLastItem = items[currentLast]; nextLast = currentLast; items[nextLast] = null; size -= 1; return currentLastItem; } /** * Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth. * If no such item exists, returns null. Must not alter the deque! * @Rule must take constant time. */ public T get(int index) { if (index &amp;gt;= size) { return null; } int indexFromFirst = nextFirst &#43; 1 &#43; index; if (indexFromFirst &amp;gt;= capacity) { indexFromFirst -= capacity; } return items[indexFromFirst]; } }</content>
    </entry>
    
     <entry>
        <title>【CS61B】Proj1A Data Structures -- LinkedListDeque and ArrayDeque </title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61bproj1a/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> 项目要求：https://sp18.datastructur.es/materials/proj/proj1a/proj1a
代码地址：https://github.com/jchenTech/cs61b/tree/master/proj1a
</content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC6 ALists, Resizing, vs. SLists </title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec6/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> ALists, Resizing, vs. SLists
https://sp18.datastructur.es/
列表与数组 我们的 DLList 有一个缺点。获得第i个项目很慢；我们必须从头到尾扫描列表中的每个项目，直到到达第 i 个项目为止。但是，对于名为 A 的数组，我们可以使用方括号表示法 A[i] 快速访问第i个项目。因此，我们的目标是实现带有数组的列表。
AList AList 将具有与 DLList 相同的API，这意味着它将具有与 DLList 相同的方法(addLast(), getLast(), removeLast(), and get(int i))。 AList也将具有一个跟踪其大小的大小变量。
AList不变式 AList有一些不变式。
 addLast：我们要添加的下一个项目将进入 size 位置。 getLast：我们要返回的项目位置为 size-1。 size：列表中的项目数应为 size。  实现AList 每个 AList 都有一个int[] 叫做 item。
 对于addLast，我们将项目放置在 items[size]中。 对于getLast，我们只返回 items[size-1]。 对于removeLast，我们只是减小 size（我们不需要更改 items）。因此，如果调用 addLast，则由于 size 减小了，因此只会覆盖旧值。但是，最好将对象删除后将其清空，因为这样可以节省内存。注意这些方法与不变量有多紧密的联系。  抽象 本课程的一个关键思想是可以将实现细节隐藏在用户面前。例如，用户可能想使用列表，但是作为实现者，我们可以为他们提供列表的任何实现，只要该列表符合其规范即可。用户不应该了解我们列表的内部工作原理。
调整数组大小Array Resizing 当数组满时，我们可以调整数组大小。但是，我们了解到数组大小无法更改。相反，解决方案是创建一个更大的新数组，然后将我们的旧数组值复制到新数组中。现在，我们拥有所有旧值，但是我们有更多空间来添加项目。
调整速度Resizing Speed 在讲座视频中，每次达到数组大小限制时，我们便开始将数组调整大小再增加一个额外框。事实证明这非常慢，因为将数组复制到新数组意味着我们必须对每个项目执行复制操作。最糟糕的部分是，由于我们仅调整了一个额外的框的大小，因此，如果我们选择添加另一项，则每次添加到数组时都必须再次执行此操作。
提高Resizing性能 而不是添加一个额外的框，我们可以创建一个新数组，其大小为 size * FACTOR项，其中 FACTOR 可以是任何数字，例如2。我们将在本课程的稍后部分讨论为什么这样做很快。
减小数组大小 如果我们拥有一百万个长度的数组，但是我们删除了990,000个元素，该怎么办？好吧，类似地，例如，如果我们达到250,000个元素，则可以通过创建一半大小的数组来缩小数组的大小。同样，我们将在本课程的后面部分对此进行更严格的讨论。
另外：分解代码 有时，我们编写大型方法来完成多项任务。更好的方法是将我们的大型方法分解为许多较小的方法。这样的好处之一是我们可以分部分地测试我们的代码。
泛型AList 上一次，我们讨论了如何制作泛型 DLList。 我们可以为 AList 做类似的事情。 但是我们发现我们在创建数组时出错了。 我们的问题是Java中不允许使用通用数组。 相反，我们将更改以下行：
items = new Item[100]; 改为：
items = (Item[]) new Object[100]; 这叫做 cast，我们将在以后学习。
</content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC5 DLLists, Arrays </title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec5/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> DLLists, Arrays
https://sp18.datastructur.es/
SLList的缺点 addLast() 方法非常慢！我们无法添加到列表的中间。另外，如果我们的列表很大，那么我们必须从最前面开始，并一直循环到列表的最后，然后再添加元素。
一个Naive的解决方法 回想一下，我们将列表的大小作为SLList的实例变量进行了缓存。如果我们也缓存列表中的最后一个元素怎么办？突然之间，addLast() 又很快了。我们立即访问最后一个元素，然后添加我们的元素。但是 removeLast() 仍然很慢。在 removeLast() 中，我们必须知道second-to-last 变量是什么，因此我们可以将缓存的 last 变量指向该变量。然后，我们可以缓存 second-to-last，但是现在，如果我想删除倒数第二个元素，则需要知道倒数第二个元素在哪里。如何解决这个问题呢？
DLList 解决方案是为每个 IntNode 提供一个 prev 指针，指向上一个项目。这将创建一个双向链表或 DLList。通过此修改，从列表的前面和后面添加和删除变得很快（尽管从中间添加/删除仍然很慢）。
结合Sentinel 回想一下，我们在 SLList 中添加了一个哨兵节点。对于 DLList，我们可以有两个哨兵（一个为前哨，一个为后哨），也可以使用圆形哨兵。使用圆形标记的 DLList 具有一个哨兵。哨兵通过next指针指向列表的第一个元素并且用 prev 指针指向最后一个元素。此外，列表最后一个元素的 next 指向哨兵，列表中第一个元素的 prev 指向哨兵。对于空列表，哨兵两个方向指向自身。
泛型双向链表Generic DLList 我们如何修改 DLList，以便它可以是我们选择的任何对象的列表？回想一下我们的类定义如下：
public class DLList { ... } 将其变为：
public class DLList&amp;lt;T&amp;gt; { ... } 其中 T 是占位符对象类型。 注意尖括号语法。 另请注意，我们不必使用 T； 任何变量名都可以。 在 DLList 中，我们的项目现在为 T 类型，并且我们的方法现在将 T 类型实例作为参数。 为了准确性，我们还可以将 IntNode 类重命名为 TNode。
使用泛型双向链表 回想创建一个 DLList，我们输入：
DLList list = new DLList(10); 如果我们想创建一个支持 String 对象得 DLList，我们必须说：
DLList&amp;lt;String&amp;gt; list = new DLList&amp;lt;&amp;gt;(&amp;#34;bone&amp;#34;); 创建列表时，编译器将 T 的所有实例替换为 String！ 我们将在以后的课程中更详细地介绍通用类型。
数组 回想一下变量只是位盒。例如，int x; 创建了一个32位的存储盒。数组是一个特殊的对象，它由编号顺序的存储盒组成！要获得数组A的第i个项，请使用 A[i]。 数组的长度不能更改，并且数组的所有元素必须具有相同的类型（这与Python列表不同）。 这些框的索引为零，这意味着对于具有N个元素的列表，第一个元素位于 A[0]，最后一个元素位于 A[N-1]。 与常规类不同，数组没有方法！ 数组确实有一个 length 变量。
数组实例化 创建数组有三种有效的表示。 第一种方法指定数组的大小，并使用默认值填充数组：
int[] y = new int[3]; 第二种和第三种方法向数组填充特定的值：
int[] x = new int[]{1, 2, 3, 4, 5}; int[] w = {1, 2, 3, 4, 5}; 我们可以使用数组索引在数组中设置一个值。 例如，我们可以说 A[3] = 4;。 这将访问数组A的第四个元素，并将该框的值设置为4。
Arraycopy 为了复制数组，我们可以使用 System.arraycopy。 它有5个参数； 语法很难记住，因此我们建议使用诸如此类的各种在线参考。
二维数组 我们可以声明多维数组，对于二维数组，我们可用以下语法：
int[][] array = new int[4][]; 这创建了一个包含整型数组的数组，注意我们必须手动的创建内层数组如下：
array[0] = new int[]{0, 1, 2, 3}; Java还可以使用自动创建的内部数组来创建多维数组。 为此，请使用以下语法：
int[][] array = new int[4][4]; 我们也可以使用这种方式：
int[][] array = new int[][]{{1}, {1, 2}, {1, 2, 3}} 来得到具有具体数值的数组。
Arrays vs. Classes
 两者都用于组织一堆内存。 两者都有固定数量的“盒子”。 通过方括号符号访问数组。 通过点表示法访问类。 数组中的元素必须全部为同一类型。 类中的元素可以是不同的类型。 数组索引是在运行时计算的。 我们无法计算类成员变量名称。 </content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC4 SLLists, Nested Classes, Sentinel Nodes </title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec4/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> SLLists, Nested Classes, Sentinel Nodes
https://sp18.datastructur.es/
裸数据结构Naked Data Structure IntLists很难使用。为了正确使用 IntLists，即使对于简单的列表相关任务，程序员也必须理解并利用递归。
Adding Clothes 我们首先将 IntList 类转变为 IntNode 类。然后我们将删除IntNode类中的所有方法，接下来我们将创建一个名为 SLList 的新类，该类首先包含实例变量，并且该变量的类型应为 IntNode。本质上我们已经用 SLList 包装了我们的IntNode。
使用SLList 作为 SLList 的用户，要创建一个列表，我调用 SLList 的构造函数，并且希望填充列表的数字。然后，SLList 构造函数将使用该数字调用 IntNode 构造函数，并首先设置其指向刚创建的 IntNode。
改进 注意当创建一个有一个值的列表时，我们谢了 SLList list = new SLList(1);。我们不必担心像我们的IntList那样传递空值，本质上，SLList类充当列表用户和裸 IntList 之间的中间人。
Public vs Private 我们希望用户仅通过SLList方法修改列表，而不要直接修改first。我们可以通过变量访问权限设置为private来防止至其他用户这样做。编写 private IntNode first; 来防止其它类中的代码首先访问和修改(而该类中的代码仍然可以这么做)。
嵌套类Nested Classes 我们还可以将类移入类以创建嵌套类！您也可以将嵌套类声明为私有类。这样，其他类将永远无法使用此嵌套类。
静态嵌套类Static Nested Classes 如果 IntNode 类从不使用 SLList 类的任何变量或方法，我们可以通过添加 static 关键字将其变为静态。
递归帮助器方法Recursive Helper Methods 如果要在 SLList 中编写递归方法，我们将如何去做呢？毕竟，SLList 不是像 IntNode 这样的自然递归数据结构。一个常见的想法是编写一个用户可以调用的外部方法。此方法调用一个以 IntNode 作为参数的私有帮助器方法。然后，此辅助方法将执行递归，并将答案返回给外部方法。
缓存Caching 以前，我们通过返回 1&#43;其余列表的大小来递归计算 IntList 的大小。如果列表很大，这将变得很慢，并且我们反复调用我们的 size 方法。现在我们有了一个 SLList，让我们简单地将列表的大小作为实例变量进行缓存！请注意，在没有 IntList 之前我们无法做到这一点。
空列表 使用一个 SLList，我们现在可以表示一个空列表。我们只需将 first 设置为 null 并将 size 设置为 0。即，因为first现在为null，所以任何尝试访问first属性的方法（例如first.item）都将返回NullPointerException。当然，我们可以通过编写处理这种特殊情况的代码来解决此错误。但是可能会有很多特殊情况。有更好的解决方案吗？
前哨节点Sentinel Nodes 使所有 SLList 对象（甚至是空列表）都相同。为此，给每个 SLList 一个前哨节点，一个始终存在的节点。实际元素位于前哨节点之后，并且我们所有的方法都应尊重哨兵始终是列表中第一个元素的想法。
不变式Invariants 不变式是关于保证是正确的数据结构的事实（假设您的代码中没有错误）。每当我们向数据结构中添加功能时，这便为我们提供了一个方便的清单。还向用户保证将保留他们信任的某些属性。例如，带有前哨节点的SLList至少具有以下不变量：
 前哨引用始终指向前哨节点。 前项（如果存在）始终位于 sentinel.next.item。 size 变量始终是已添加的 items 总数。 </content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC3 References, Recursion, and Lists </title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec3/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> References, Recursion, and Lists
https://sp18.datastructur.es/
Bits: 计算机将信息存储为内存，并使用0或1的位序列表示此信息。
Primitives： Primitives是信息的表示。 Java有8种原始类型：byte, short, int, long, float, double, boolean, and char。每个基本类型由一定数量的位表示。例如，整型是32位，而字节是8位。
声明基元：当我们将变量声明为基元（即int x;）时，我们预留了足够的存储空间来保存位（在本例中为32）。我们可以认为这是一个存放位的盒子。然后，Java将变量名称映射到此框。假设我们有一行代码int y = x; x之前定义的位置。 Java会将 x 框内的位复制到 y 框内的位。
创建对象：当我们使用new关键字创建类的实例时，Java为每个字段创建位框，其中每个框的大小由每个字段的类型定义。例如，如果一个Walrus对象具有一个int变量和一个double变量，则Java将分配两个框，总计96位（32 &#43; 64）以容纳两个变量。这些将被设置为默认值，例如0。然后，构造函数进入并将这些位填充为适当的值。构造函数的返回值将返回盒子所在的内存位置，通常是64位地址。然后可以将该地址存储在具有“引用类型”的变量中。
引用类型：如果变量不是原始类型，则它是引用类型。当声明对象变量时，我们使用引用类型变量将对象所在位置的地址存储在内存中。请记住，这就是构造函数返回的内容。引用类型始终是大小为64位的框。请注意，该变量不会存储整个对象本身！
等于的黄金法则：对于基元，线y = x将x框内的位复制到y框。对于引用类型，我们做的完全相同。在“ Walrus newWalrus = oldWalrus;”行中，我们将oldWalrus框中的64位地址复制到newWalrus框中。因此，我们可以将此等价黄金法则（GroE）视为：当我们给一个等于等值的值时，我们只是将位从一个存储盒复制到另一个存储盒！
参数传递：说我们有一个方法 average(double a, double b)。此方法以double为参数。参数传递也遵循GRoE，即，当我们调用此方法并传递两个double时，我们将这些变量中的位复制到参数变量中。
数组实例化：数组也是对象，也可以使用new关键字实例化。这意味着声明一个数组变量（即int [] x;）将创建一个64位引用类型变量，该变量将保存该数组的位置。当然，现在，此框包含空值，因为我们尚未创建数组。数组的新关键字将创建该数组并返回该数组在内存中的位置。因此，通过说int [] x = new int [] {0，1，2，3，4} ;，我们将这个新创建的数组的地址设置为变量x。注意，数组的大小是在创建数组时指定的，不能更改！
整数列表IntLists：使用引用，我们递归定义了IntList类。 IntList是可以更改大小（与数组不同）的整数列表，并且可以存储任意数量的整数。可以通过递归或迭代来完成大小帮助程序的编写。
</content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC2 Defining and Using Classes </title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec2/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> Defining and Using Classes
Reading Static vs Non-Static Methods Static Methods Java中的所有代码都必须是类class中的一部分，大多数代码在方法methods中：
public class Dog { public static void makeNoise() { System.out.println(&amp;#34;Bark!&amp;#34;); } } 如果运行 Dog 类，将会报错：
$ java Dog Error: Main method not found in class Dog, please define the main method as: public static void main(String[] args) 为了执行Dog类，我们需要添加一个main方法。或者，我们也可以单独创建一个 DogLauncher 类来执行 Dog 类：
public class DogLauncher { public static void main(String[] args) { Dog.makeNoise(); } }$ java DogLauncher Bark! 一个类使用另一个类也叫做这个类的 client客户， 所以 DogLauncher 是 Dog 的client
Instance Variables and Object Instantiation 实例变量和对象初始化 狗的叫声不是都是一样的，其中一种方法是为不同类型的Dog创建不同的类。
public class TinyDog { public static void makeNoise() { System.out.println(&amp;#34;yip yip yip yip&amp;#34;); } } public class MalamuteDog { public static void makeNoise() { System.out.println(&amp;#34;arooooooooooooooo!&amp;#34;); } } 另一种方法是，类可以被实例化，而示例可以包含数据，所以我们创建Dog类的实例，并使Dog方法的行为取决于特定Dog的属性。为了更加具体，我们可以考虑以下的类：
public class Dog { public int weightInPounds; public void makeNoise() { if (weightInPounds &amp;lt; 10) { System.out.println(&amp;#34;yipyipyip!&amp;#34;); } else if (weightInPounds &amp;lt; 30) { System.out.println(&amp;#34;bark. bark.&amp;#34;); } else { System.out.println(&amp;#34;woof!&amp;#34;); } } } 该方法使用Dog的方式为：
public class DogLauncher { public static void main(String[] args) { Dog d; d = new Dog(); d.weightInPounds = 20; d.makeNoise(); } } 当该程序运行时，会输出“bark.bark.”
所以我们可以得到一些结论：
 Java中的对象是任何类的实例。 Dog类具有自己的变量，也称为实例变量或非静态变量。 这些必须在类内部声明，这与Python或Matlab等语言不同，在Python或Matlab中，可以在运行时添加新变量。 我们在Dog类中创建的方法没有static关键字。 我们称此类方法为实例方法或非静态方法。 要调用makeNoise方法，我们必须首先使用new关键字实例化Dog，然后制作特定的Dog bark。 换句话说，我们调用d.makeNoise()而不是Dog.makeNoise()。 实例化对象后，可以将其分配给适当类型的声明变量，例如： d = new Dog(); 类的变量和方法也称为类的成员。 类的成员使用点表示法进行访问。  Constructors in Java (Java中的构造函数) 我们通常通过构造函数在面向对象语言中构造对象
public class DogLauncher { public static void main(String[] args) { Dog d = new Dog(20); d.makeNoise(); } } 这里的实例化是由参数的，为了使得该实例化符合语法，我们需要添加一个构造函数：
public class Dog { public int weightInPounds; public Dog(int w) { weightInPounds = w; } public void makeNoise() { if (weightInPounds &amp;lt; 10) { System.out.println(&amp;#34;yipyipyip!&amp;#34;); } else if (weightInPounds &amp;lt; 30) { System.out.println(&amp;#34;bark. bark.&amp;#34;); } else { System.out.println(&amp;#34;woof!&amp;#34;); } } } 每当我们尝试使用new关键字和单个整数参数创建Dog时，都会调用带有签名 public Dog(int w) 的构造函数。
数组实例化、对象数组 Java中使用 new 来实例化数组：
public class ArrayDemo { public static void main(String[] args) { /* Create an array of five integers. */ int[] someArray = new int[5]; someArray[0] = 3; someArray[1] = 4; } } 相似的，我们可以在Java中创建实例化对象数组：
public class DogArrayDemo { public static void main(String[] args) { /* Create an array of two dogs. */ Dog[] dogs = new Dog[2]; dogs[0] = new Dog(8); dogs[1] = new Dog(20); /* Yipping will result, since dogs[0] has weight 8. */ dogs[0].makeNoise(); } } 在这里，new 既用于创建含两个Dog对象的数组，也创建了单个的Dog
Class Methods vs. Instance Methods 类方法vs实例方法 Java允许我们定义两种方法：
 类方法，即静态方法 实例方法，即非静态方法  实例化方法只能被一个特定的类的实例调用，静态方法只能被类本身调用。举个静态方法的例子，Math 类提供了一个 sqrt 方法，因为他是静态的，所以它允许：
x = Math.sqrt(100); 如果sqrt是实例方法，则下面将具有尴尬的语法。 幸运的是，sqrt是静态方法，因此我们不必在实际程序中执行此操作。
Math m = new Math(); x = m.sqrt(100); 有时，类中既有实例化方法也有静态方法，比如，我们想比较两条狗，我们可以用静态方法进行比较：
public static Dog maxDog(Dog d1, Dog d2) { if (d1.weightInPounds &amp;gt; d2.weightInPounds) { return d1; } return d2; } 该方法可以被调用：
Dog d = new Dog(15); Dog d2 = new Dog(100); Dog.maxDog(d, d2); 另外还可以用非静态方法：
public Dog maxDog(Dog d2) { if (this.weightInPounds &amp;gt; d2.weightInPounds) { return this; } return d2; }Dog d = new Dog(15); Dog d2 = new Dog(100); d.maxDog(d2); 这里我们是用的特定的实例化变量进行调用方法。
静态变量 对于类而言，具有静态变量有时会很有用。 这些是类本身而非实例的固有属性。 例如，我们可能会记录到“狗”的学名是“ Canis handsomeis”：
public class Dog { public int weightInPounds; public static String binomen = &amp;#34;Canis familiaris&amp;#34;; ... } 我们应该通过类名而不是特定的实例来访问静态变量，即应使用 Dog.binomen, 而不是 d.binomen
1.3 public static void main(String[] args) 到目前为止，我们已经了解到了，现在该使我们一直在使用main方法的声明变得神秘了。 分成几部分，我们有：
 public：到目前为止，我们所有的方法都以该关键字开头。 static：这是一个静态方法，不与任何特定实例相关联。 void：没有返回类型。 main：这是方法的名称。 String [] args：这是传递给main方法的参数。  Command Line Arguments 命令行参数 public class ArgsDemo { public static void main(String[] args) { System.out.println(args[0]); } }$ java ArgsDemo these are command line arguments these 1.3.2 Summing Command Line Arguments Exercise 1.2.3: Try to write a program that sums up the command line arguments, assuming they are numbers. For a solution, see the webcast or the code provided on GitHub.
Using Libraries使用库 Overview总结 Client程序和Main方法 ：没有main方法的Java程序无法使用java命令运行。 但是，可以使用另一类的main方法来调用一个类的方法。 使用另一个类的Java类称为该类的客户端。
类声明：Java类可以包含方法和/或变量。 我们说这样的方法和变量是类的“成员”。 成员可以是实例成员或静态成员。 静态成员用static关键字声明。 实例成员是没有static关键字的任何成员。
类实例化：类的实例化几乎总是使用new关键字完成的，例如 Dog d = new Dog()。 Java中类的实例也称为对象。
点表示法：我们使用点表示法访问类的成员，例如 d.bark()。 可以从同一班级或其他班级访问班级成员。
构造函数constructor：构造函数告诉Java当程序尝试创建类的实例时该怎么做，例如执行Dog d = new Dog()时应执行的操作。
数组实例化：数组也使用new关键字实例化。如果我们有一个对象数组，例如Dog [] dogarray，则数组的每个元素也必须分别实例化。
静态方法与实例方法：静态方法和实例方法之间的区别非常重要。实例方法是只能由类的实例（即特定对象）执行的操作，而静态方法则由类本身执行。实例方法是使用对特定实例的引用来调用的，例如d.bark()，而静态方法应使用类名来调用，例如Math.sqrt()。知道何时使用它们。
静态变量：变量也可以是静态的。静态变量应使用类名访问，例如Dog.binomen与d.binomen相反。从技术上讲，Java允许您使用特定实例进行访问，但是我们强烈建议您不要这样做，以免造成混淆。
void方法：不返回任何内容的方法应设置为void返回类型。
this关键字：在方法内部，我们可以使用this关键字引用当前实例。
public static void main(String[] args)：我们现在知道这些东西分别是什么意思：
 public：到目前为止，我们所有的方法都以该关键字开头。 static：这是一个静态方法，不与任何特定实例相关联。 void：没有返回类型。 main：这是方法的名称。 String [] args：这是传递给main方法的参数。 命令行参数。操作系统可以将这些参数作为“命令行参数”提供给您的程序，并且可以使用main中的args参数进行访问。例如，如果我们从命令行调用程序，例如java ArgsDemo，这些都是命令行参数，那么ArgsDemo的* main方法将具有一个包含字符串“ these”，“ are”，“ command”，“ line”，和“参数”。  使用库：在2017年，您无需从头开始构建所有内容。在我们的课程中，您被允许并强烈鼓励您使用Java的内置库以及我们提供的库，例如普林斯顿标准库。除了Java提供或内置的库以外，您不应使用其他库，因为它可能使某些作业无济于事，而且我们的自动分级机将无法访问这些库，并且您的代码也将无法使用。
从Internet获得帮助：欢迎您在线寻求帮助。但是，您应始终引用您的消息来源，并且不应就特定的家庭作业问题或项目寻求帮助。例如，使用谷歌搜索“如何转换String Java”或“如何读取文件Java”是可以的，但您不应搜索“ project 2 61b java berkeley”。
</content>
    </entry>
    
     <entry>
        <title>【CS61B】LEC1 Intro, Hello World </title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61blec1/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> 从今天开始，将follow数据结构的一门经典课程，UC Berkeley的CS61B。
Reading Hello World Let&amp;rsquo;s look at our first Java program. When run, the program below prints &amp;ldquo;Hello world!&amp;rdquo; to the screen.
public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;#34;Hello world!&amp;#34;); } } For those of you coming from a language like Python, this probably seems needlessly verbose. However, it&amp;rsquo;s all for good reason, which we&amp;rsquo;ll come to understand over the next couple of weeks. Some key syntactic features to notice:
 The program consists of a class declaration, which is declared using the keywords public class. In Java, all code lives inside of classes. The code that is run is inside of a method called main, which is declared as public static void main(String[] args). We use curly braces { and } to denote the beginning and the end of a section of code. Statements must end with semi-colons.  Running a Java Program The most common way to execute a Java program is to run it through a sequence of two programs. The first is the Java compiler, or javac. The second is the Java interpreter, or java.
For example, to run HelloWorld.java, we&amp;rsquo;d type the command javac HelloWorld.java into the terminal, followed by the command java HelloWorld. The result would look something like this:
$ javac HelloWorld.java $ java HelloWorld Hello World! In the figure above, the $ represents our terminal&amp;rsquo;s command prompt. Yours is probably something longer.
You may notice that we include the &amp;lsquo;.java&amp;rsquo; when compiling, but we don&amp;rsquo;t include the &amp;lsquo;.class&amp;rsquo; when interpreting. This is just the way it is (TIJTWII).
Variables and Loops The program below will print out the integers from 0 through 9.
public class HelloNumbers { public static void main(String[] args) { int x = 0; while (x &amp;lt; 10) { System.out.print(x &#43; &amp;#34; &amp;#34;); x = x &#43; 1; } } } When we run this program, we see:
$ javac HelloNumbers.java $ java HelloNumbers $ 0 1 2 3 4 5 6 7 8 9 Some interesting features of this program that might jump out at you:
 Our variable x must be declared before it is used, and it must be given a type! Our loop definition is contained inside of curly braces, and the boolean expression that is tested is contained inside of parentheses. Our print statement is just System.out.print instead of System.out.println. This means we should not include a newline (a return). Our print statement adds a number to a space. This makes sure the numbers don&amp;rsquo;t run into each other. Try removing the space to see what happens. When we run it, our prompt ends up on the same line as the numbers (which you can fix in the following exercise if you&amp;rsquo;d like).  Static Typing One of the most important features of Java is that all variables and expressions have a so-called static type. Java variables can contain values of that type, and only that type. Furthermore, the type of a variable can never change.
One of the key features of the Java compiler is that it performs a static type check. For example, suppose we have the program below:
public class HelloNumbers { public static void main(String[] args) { int x = 0; while (x &amp;lt; 10) { System.out.print(x &#43; &amp;#34; &amp;#34;); x = x &#43; 1; } x = &amp;#34;horse&amp;#34;; } } Compiling this program, we see:
$ javac HelloNumbers.java HelloNumbers.java:9: error: incompatible types: String cannot be converted to int x = &amp;#34;horse&amp;#34;; ^ 1 error Extra Thought Exercise In Java, we can say System.out.println(5 &#43; &amp;quot; &amp;quot;);. But in Python, we can&amp;rsquo;t say print(5 &#43; &amp;quot;horse&amp;quot;), like we saw above. Why is that so?
Consider these two Java statements:
String h = 5 &#43; &amp;#34;horse&amp;#34;; and
int h = 5 &#43; &amp;#34;horse&amp;#34;; The first one of these will succeed; the second will give a compiler error. Since Java is strongly typed, if you tell it h is a string, it can concatenate the elements and give you a string. But when h is an int, it can&amp;rsquo;t concatenate a number and a string and give you a number.
In this case, System.out.println(5 &#43; &amp;quot;horse&amp;quot;);, Java interprets the arguments as a string concatentation, and prints out &amp;ldquo;5horse&amp;rdquo; as your result. Or, more usefully, System.out.println(5 &#43; &amp;quot; &amp;quot;); will print a space after your &amp;ldquo;5&amp;rdquo;.
Defining Functions in Java In languages like Python, functions can be declared anywhere, even outside of functions. For example, the code below declares a function that returns the larger of two arguments, and then uses this function to compute and print the larger of the numbers 8 and 10:
def larger(x, y): if x &amp;gt; y: return x return y print(larger(8, 10)) Since all Java code is part of a class, we must define functions so that they belong to some class. Functions that are part of a class are commonly called &amp;ldquo;methods&amp;rdquo;. We will use the terms interchangably throughout the course. The equivalent Java program to the code above is as follows:
public class LargerDemo { public static int larger(int x, int y) { if (x &amp;gt; y) { return x; } return y; } public static void main(String[] args) { System.out.println(larger(8, 10)); } } The new piece of syntax here is that we declared our method using the keywords public static, which is a very rough analog of Python&amp;rsquo;s def keyword. We will see alternate ways to declare methods in the next chapter.
Code Style, Comments, Javadoc In this course, we&amp;rsquo;ll work hard to try to keep our code readable. Some of the most important features of good coding style are:
Consistent style (spacing, variable naming, brace style, etc) Size (lines that are not too wide, source files that are not too long) Descriptive naming (variables, functions, classes), e.g. variables or functions with names like year or getUserName instead of x or f. Avoidance of repetitive code: You should almost never have two significant blocks of code that are nearly identical except for a few changes. Comments where appropriate. Line comments in Java use the // delimiter. Block (a.k.a. multi-line comments) comments use /* and */.
Comments public class LargerDemo { /** Returns the larger of x and y. */ public static int larger(int x, int y) { if (x &amp;gt; y) { return x; } return y; } public static void main(String[] args) { System.out.println(larger(8, 10)); } } Overview总结 关键语法功能：我们的第一个程序揭示了Java的几个重要语法特性：
 所有代码都存在于一个类中。 执行的代码在称为main的函数（又称为方法）内部。 花括号用于表示一段代码的开头和结尾，例如类或方法的声明。 语句以分号结尾。 变量具有声明的类型，也称为“静态类型”。 变量必须在使用前声明。 函数必须具有返回类型。如果函数不返回任何内容，则使用void， 编译器确保类型一致性。如果类型不一致，则程序将无法编译。  静态类型： （我认为）静态类型是Java的最佳功能之一。与没有静态类型的语言相比，它为我们提供了许多重要的优势：
 在程序运行之前检查类型，使开发人员可以轻松捕获类型错误。 如果编写程序并分发编译的版本，则（大多数）可以保证该程序没有任何类型错误。这使您的代码更可靠。 每个变量，参数和函数都有一个声明的类型，从而使程序员更易于理解和推理代码。 静态类型的缺点，将在后面讨论。  编码风格：编码风格在61B和现实世界中非常重要。应按照教科书和讲座中的说明对代码进行适当的注释。
命令行编译和执行： javac用于编译程序。 java用于执行程序。我们必须始终在执行之前进行编译。
</content>
    </entry>
    
     <entry>
        <title>【CS61B】利用Github管理课程代码并搭建Auto Grade环境</title>
        <url>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cs61b%E5%88%A9%E7%94%A8github%E7%AE%A1%E7%90%86%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%B9%B6%E6%90%AD%E5%BB%BAauto-grade%E7%8E%AF%E5%A2%83/</url>
        <categories>
          <category>数据结构与算法</category>
        </categories>
        <tags>
          <tag>Java</tag><tag>CS61B</tag><tag>数据结构</tag>
        </tags>
        <content type="html"> 学习CS61B的一个挑战便是需要学习使用Git and github。由于非伯克利注册的学生不能够得到instructional number,因此我们需要在自己的github上创建一个专有的repository，我将自己的命名为cs61b-sp18，有了这个repo，我们就可以把本地的课程代码/作业代码/项目代码推送到这个远程库中，然后上传到autograder进行评分。
配置github环境  在 GitHub 创建一个仓库，这里为了方便起见，建议将 仓库名称 和 本地的文件夹命名为相同的名字，我都命名为了 cs61b 将远程的仓库 clone 到本地  git clone https://github.com/chonghaozhang1998/cs61b.git  clone能够把GitHub上的repo复制到本地，并关联这两个repo，而且remote repository自动会变为origin (means origin remote repo). 需要注意的是，此时无论是本地的还是远程的repo上我们都还在master branch.  然后进入本地的repo：
cd cs61b  在这个repo里我们需要从cs61b的官方github repository中将starter code导入到本地来。不过这时候origin是自己的github repo，所以不能用clone操作，而应先add再pull：  git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git  这时候skeleton就是官方repo中的starter code远程库。然后  git pull skeleton master 提交代码 以lab1为例，将之前写的 HelloWorld.java 和 HelloNumbers.java 文件放到本地的 ./cs61b/lab1 中，然后暂存并提交这两个文件：
git add lab1/* git commit -m &amp;#34;completed first part of lab1&amp;#34; 然后将这些更改推送到 origin 远程仓库上的 master 分支：
git push origin master 此时代码就提交到github上去了，然后就通过auto grade选择github上repo里的文件进行打分就可以了。
</content>
    </entry>
    
     <entry>
        <title>Ubuntu18.04安装NVIDA显卡驱动</title>
        <url>http://jchenTech.github.io/post/linux/ubuntu18.04%E5%AE%89%E8%A3%85nvida%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
        <categories>
          <category>Linux</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Ubuntu</tag>
        </tags>
        <content type="html"> 今天的目标是在 Ubuntu 18.04 上安装 NVIDIA 显卡驱动，请注意，显卡一定要是 NVIDIA 的显卡才能按照这篇文章的方法安装。
先来说说带有 NVIDIA 独立显卡的电脑为什么要安装 NVIDIA 显卡驱动吧。下面是我从维基百科摘抄的显卡工作原理的介绍：
 显卡是插在主板上的扩展槽里的（现在一般是 PCI-E 插槽，此前还有 AGP、PCI、ISA 等插槽）。它主要负责把主机向显示器发出的显示信号转化为一般电器信号，使得显示器能明白个人计算机在让它做什么。显卡的主要芯片叫“显示芯片”（Video chipset，也叫 GPU 或 VPU，图形处理器或视觉处理器），是显卡的主要处理单元。显卡上也有和计算机存储器相似的存储器，称为“显示存储器”，简称显存。
早期的显卡只是单纯意义的显卡，只起到信号转换的作用；当前我们一般使用的显卡都带有 3D 画面运算和图形加速功能，所以也叫做“图形加速卡”或“3D 加速卡”。PC 上最早的显卡是 IBM 在 1981 年推出的 5150 个人计算机上所搭载的 MDA 和 CGA 两款 2D 加速卡。
显卡通常由总线接口、PCB 板、显示芯片、显存、RAMDAC、VGA BIOS、VGA 功能插针、D-sub 插座及其他外围组件构成，现在的显卡大多还具有 VGA、DVI 显示器接口或者 HDMI 接口及 S-Video 端子和 Display Port 接口。
 此次采用的方法是使用 PPA 第三方软件仓库安装最新版本
 添加 PPA 软件仓库：sudo add-apt-repository ppa:graphics-drivers/ppa，需要输入用户密码，按照提示还需要按下 Enter 键。 更新软件索引：sudo apt update 查询所有ubuntu推荐的驱动: ubuntu-drivers devices 安装所有推荐的驱动程序: sudo ubuntu-drivers autoinstall </content>
    </entry>
    
     <entry>
        <title>Ubuntu18.04桌面版双系统安装教程</title>
        <url>http://jchenTech.github.io/post/linux/ubuntu18.04%E6%A1%8C%E9%9D%A2%E7%89%88%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
        <categories>
          <category>Linux</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Ubuntu</tag>
        </tags>
        <content type="html"> 由于后面将要在linux系统上进行图像处理相关工作，所以需要安装Linux操作系统，目前采用的是Ubuntu18.04桌面版本方便个人使用，由于在虚拟机上较慢，采取双系统安装方式。
准备工作 注：本篇文章以 Ubuntu18.04.1 的安装为例。 准备工作在其他系统上进行，我这里在 Windows10 上进行以下的三步。
下载 Ubuntu 镜像 打开ubuntu18.04的下载地址，进入页面后点击右边的Download按钮开始下载。
制作U盘启动盘 1）安装制作工具：UltraISO，下载完成后安装
2）插入用来做启动盘的U盘（最好是usb3.0接口，16GB或以上），并清空里面的文件
3）打开安装好的UltraISO，点击继续试用按钮工作界面
4）进入工作界面后，点击菜单栏文件(F)，在弹出的选项卡里点击打开
5）在弹出的文件选择对话框中找到下载好的 Ubuntu18.04.1 LTS 镜像文件，打开后如下图所示：
6）点击菜单栏上的启动，在弹出的选项卡里点击写入硬盘映像
7）在弹出的新窗口中，
硬盘驱动器：选择刚刚插入的U盘
写入方式：设置为USB-HDD&#43;
其余需要勾选的不管，采用默认的设置就行
然后可以格式化一下
最后点击最下面一栏的写入按钮
8）写入过程大概会持续4～5分钟，完成后界面如下图所示，接着点击返回按钮。
至此，启动盘制作完成！
1.3 给 Ubuntu 分配硬盘空间 安装 Ubuntu18.04 这一步也可以在安装过程中分区的时候执行，不过最好安装前弄好，省得到时候出岔子需要从头开始。
1）鼠标右键计算机，在弹出来选项卡中选择管理，接着在弹出来的窗口左侧点击 存储/磁盘管理，进入磁盘管理界面，如下图所示：
2）在你要安装的目标磁盘中，通过删除卷和删除分区操作腾出一块未分配的磁盘空间作为安装区。由于我的电脑是单硬盘，所以选择最后一个磁盘进行压缩卷，即我的电脑有C、D、E盘，所以在我的E盘拿150GB 的空间用来安装 Ubuntu18.04.1（安装区的大小依磁盘总的空间以及你的需要而定）。
设置启动项 关闭你要安装 Ubuntu18.04.1 的目标主机，然后插入启动盘，接着开机，迅速的按住 F12直到进入 bios 设置界面（不同的电脑进入 bios 的按键不同，一般为 F12 或者 Delete 键），通过方向键选择Boot Menu，然后回车
进入Boot Manager后，选择 EFI USB 作为启动项，回车
至此我们就进入了安装程序，选择 Install Ubuntu， 回车直接安装
正式安装 选择语言 键盘布局 无线连网 连不连都可以，不影响最终安装
更新选项 一般我们用仅仅用 Ubuntu 来编程或者部署项目，娱乐一般用 Windows, 所以选择 最小安装
最下面的两个选项会拖慢安装的速度，这些工作可以放到安装完成后集中处理，所以也不勾选。
选择安装类型 第一和第二个选项安装的时候更省事，安装程序会自动分区，第三个选项需要自己手动分区，安装的时候会麻烦一点，但是因为是手动分区，你对系统的分区情况也更加熟悉，方便系统后期的管理。我们选择第三个选项 其他选项 ，然后点击 继续
手动分区(重点) 接下来需要我们手动分区，前面我们给在E磁盘给 Ubuntu18.04 预留了 150GB 的磁盘空间，下面对这 150GB 的空间进行分区。
/home 逻辑分区 Ext4 80GB
/boot 主分区 Ext4 1GB
swap 逻辑分区 交换空间 12GB
/ 主分区 Ext4 剩余所有内存
如上图，选中之前预留的空先区，鼠标左键双击或者点击左下角 “&#43;” 按钮，依次按照上面的分区表手动分区。 （如果在给 /boot 分完区后空闲区变为不可用，则点击 “-” 按钮删除 /boot 分区，然后先给其他挂载点分区，最后再给 /boot 分区）
对于交换空间 swap ，根据你电脑的内存情况来分：
如果内存小，就分配 2～3 倍内存的空间；
如果内存中等，就分配 1～2 倍内存的空间；
如果内存大，就分配 1 倍内存的空。
按照上面的分区表分完区后，每个区的信息如下图所示，这时还需要注意到最下面一栏 安装启动引导器的设备，你在哪个磁盘上安装的 ubuntu（在哪个磁盘上分区），就选择那一个磁盘。然后点击右下角现在安装 按钮，在弹出来的对话框中点击 继续 按钮。此处由于我是在win10系统基础上进行安装Ubuntu并且没有分EFI分区，所以选择Win10系统的EFI分区，即名字带有Windows Boot Manager的那一个。
选择时区 创建用户名 安装系统软件 安装完成后的优化工作 更换软件源 参考文章：  https://blog.csdn.net/baidu_36602427/article/details/86548203 https://www.cnblogs.com/masbay/p/11627727.html https://www.jianshu.com/p/54d9a3a695cc </content>
    </entry>
    
     <entry>
        <title>【论文笔记】MRP: Fast Haze Removal for Nighttime Image Using Maximum Reflectance Prior</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0mrp%E5%A4%9C%E9%97%B4%E5%8E%BB%E9%9B%BE/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>图像去雾</tag><tag>MRP夜间去雾</tag>
        </tags>
        <content type="html">  Abstract
在本文中，我们解决了单个夜间图像中的雾霾去除问题，即使存在杂色和非均匀照明。核心思想在于先前的新型最大反射率。我们首先介绍夜间朦胧成像模型，其中包括直接衰减项和散射项中的局部环境照明项目。然后，我们提出一个简单但有效的图像先验，最大反射先验，以估计变化的环境照明。最大反射率先验基于关键观察：对于大多数白天无雾图像块，每个颜色通道在某些像素处具有非常高的强度。对于夜间雾度图像，每个颜色通道的局部最大强度主要由环境照明贡献。因此，我们可以直接估计环境照度和透射图，从而恢复高质量的雾状图像。各种夜间图像的实验结果证明了所提出方法的有效性。特别是，我们的方法具有计算效率的优势，比现有技术方法快10-100倍。
 论文链接：https://openaccess.thecvf.com/content_cvpr_2017/html/Zhang_Fast_Haze_Removal_CVPR_2017_paper.html
1. Introduction 恢复模糊图像对于户外场景的许多计算机视觉应用是重要的。 由于漂浮在空气中的微小颗粒吸收并散射大气中的光，因此朦胧图像遭受显着的可见性降低，表现在两个方面：直接反射光的衰减和散射环境光的累积。 模糊图像的劣化随着场景点和相机之间的距离而增加，其中反射光的幅度减小并且环境光的幅度增加。 米德尔顿的模型[21]将朦胧成像过程描述为直接衰减项和散射项的线性组合。 基于该模型，已经提出了许多方法来从单个图像中去除雾度。 这些方法的关键思想依赖于各种图像先验，例如，颜色衰减[30]，暗通道[10]和雾度线[3]。
虽然在处理白天雾霾时已经证明了这些方法的有效性，但也有应用这些方法时，晚上的模糊图像有很大的局限性。主要原因是白天朦胧的成像模型和先验不适合大多数夜间朦胧的场景。白天模糊成像模型假设环境光照是全局一致的。因此，大多数去雾方法估计来自图像中最亮区域的白色环境光。然而，夜间场景通常具有多个彩色人造光源，例如，路灯，霓虹灯和汽车灯，导致强烈不均匀和杂色的环境照明。这不仅使环境光的估计不准确，而且使一些图像先验变得无效。例如，暗通道先验假设像素最小强度对应于场景中的黑色物体。该先前在白天非常好地工作，而它不能直接应用于夜间场景，因为最小强度可能受到杂色环境照明的影响。为了克服上述困难，一些工作采用了各种新技术，如色彩转移[23]，光照校正[29]，辉光去除[17]和图像融合[1]，以解决与单夜间雾霾去除相关的问题图像（见第2节）。 该研究的目的是估计每个像素的环境照度和大气透射率，以便恢复无雾图像。 为此，我们首先介绍[29]中提出的夜间朦胧成像模型。 该模型是直接衰减项和散射项的线性组合，两者都包括考虑杂色和非均匀环境照明的局部变量。 根据这个模型，恢复无雾图像是一个不适定的问题。
为了处理固有的模糊性，我们提出了一种用于夜间图像雾度去除的新颖先验，即最大反射率先验。 此优先级基于白天无雾图像补丁的统计数据。 我们发现，在大多数贴片中，每个颜色通道在某些像素处具有非常高的强度。 所提出的先验意味着，每个颜色通道处具有局部最大强度的像素对应于具有最大反射率的场景点。 因此，我们将提议的先验称为最大反射先验。
通过使用此先验，我们可以直接估计夜间模糊图像的高质量环境照明。 从这个环境光照估计，我们可以很容易地计算透射图，并最终获得夜间无雾图像。 该方法在物理上是有效的并且能够处理复杂的照明条件，包括杂色和非均匀光。 它可以实现高质量的去雾效果，几乎没有晕圈伪影。 由于其计算复杂度与图像中的像素数量成线性关系，因此该方法在运行时非常有效。
2. Previous work 已经提出了多种方法来解决从单个日间图像中去除雾霾的方法。 然而，由于夜间的杂色和不均匀照明，这些方法不适用于夜间模糊图像。
据我们所知，过去几十年中关于夜间雾霾去除的文献较少.Pei和Lee [23]提出了一种colortransfer技术，在白天雾霾图像的指导下，将输入的夜间雾霾图像转换成灰色图像。虽然这种方法可以提高可视性，但它也会引入一些颜色失真。 Zhang等人[29]提出了一种夜间去雾方法，包括光照补偿，色彩校正和去雾。由于该方法涉及一些额外的后处理步骤，因此倾向于引入颜色伪像。李等人。 [17]通过添加大气点扩散函数来修改标准朦胧成像模型，以模拟有源光源的发光效果。基于该模型，他们应用层分离算法来分解输入图像中的辉光[16]。然后使用空间变化的大气光图来基于暗通道先验估计透射图。他们的结果包含的光晕伪像少于[29] 最近，C。Ancuti等人通过在暗通道片上应用局部最大值来估计局部空气，然后使用多尺度融合方法来获得可见度增强图像。 虽然所提出的环境光照估计方案可能与[1]类似，但它们根本不同。 他们假设由最小运算符过滤的局部斑块的最亮像素可以捕获大气光的属性。这些像素确实对应于场景中的模糊区域。 由于朦胧像素的分布在空间上是变化的，因此在[1]中仔细选择了贴片的大小以增加捕获朦胧像素的机会。 另一方面，我们采用每个颜色通道具有最大反射率的像素来估计环境照度。 这些像素通常对应于具有灰色或多种颜色的区域和光源，这些区域在夜间场景中是常见的，如图2所示。
3. Nighttime hazy imaging model 在这里，我们介绍了夜间朦胧成像模型，它考虑了杂色照明的影响。 我们首先介绍标准的日间雾霾模型。 对于日间阴影场景，广泛用于描述成像过程的模型如下：
是与全球大气光A和场景反射相关的场景辐射Ri 方程（1）右侧的第一项称为直接衰减，第二项称为空气衰减。 直接衰减表示场景辐射及其在大气中的衰减，而气流衰减则表示由大气光散射引起的。 根据等式（1），假设全局大气光Aλ是白天雾霾环境的唯一光源，并且每个通道的衰减和散射特性是相同的，即与波长无关。 然而，如第1部分所述，夜间场景通常具有多个彩色人造光源，导致强烈不均匀和杂色的环境照明。 因此，将局部环境照度添加到标准朦胧成像模型的衰减项和散射项中，以获得如下的夜间朦胧成像模型：
后一项是环境照明，Li是环境照明的强度，η λ是环境照明的颜色
注意，该模型不同于Li等人提出的模型。[17]。 Li等人的模型在略微修改的标准雾度模型中增加了大气点扩散函数，因此可以更好地描述有源光源的发光效果。 然而，他们的模型采用与标准日间朦胧成像模型相同的场景反射项，其中假设照明是常数
4. Maximum reflectance prior 提出的先验基于白天无雾图像块的统计。 我们发现，对于大多数图像块，每个颜色通道在某些像素处具有非常高的强度。 换句话说，这些块中每个颜色通道的最大强度应该具有非常高的值。 在数学上，对于图像I，我们定义：
其中MλΩi是颜色通道λ处的贴片Ωi中像素强度的最大值，Lj是入射光强度，Rλj是反射率。 M在本文中称为最大反射率图。
对于白天明亮和清晰的图像，入射光强度在空间上是均匀的并且可以假设固定为值1.因此，在特定颜色通道处具有局部最大强度的像素主要对应于在相应颜色通道处具有高反射率的物体或表面。
因此，Eq（3）具有以下等价形式：
具有最大反射率的物体或表面主要包括：a）白色（灰色）或镜面反射区域，例如： 天空，路面，建筑物的窗户和水面; b）任何充满不同颜色的表面，例如 光源，鲜花，广告牌和人群。 由于这些物体和表面在场景中是常见的，对于大多数白天无雾图像块，每个颜色通道的最大强度具有值1，即MλΩi≈1。因此，我们将上述观察称为最大反射率先验。
为了验证提议的先验的有效性，我们从flickr.com收集无雾图像集。这些图像主要捕获在室外景观和城市景观场景中，通常会出现雾霾。调整它们的大小，使最大宽度和高度为500像素。图2（a）和（c）示出了几个室外图像和相应的最大反射率图（注意，输入图像在HSV颜色空间中用其V值进行归一化）。图3（a）显示了所有50,000个最大反射图贴片的强度直方图。该统计数据支持我们先前对最大反射率的假设。如图3（b）所示，存在许多导致白色MRP的候选贴片。我们提出的先验不要求每个颜色通道的最大强度由单个白色像素贡献。典型的例子如图3（c）所示。每个颜色通道中有相当多的像素具有最大反射率。这些像素通常对应于具有灰色或不同颜色的物体，例如衣服，花朵，森林和路面。
对于夜间朦胧成像，环境照明是杂色且不均匀的。 因此，对于夜间朦胧图像块，每个颜色通道的最大强度将具有较低的值并显示各种颜色。通常，这些强度是杂色环境照明的粗略近似（见图2（b）和（d）））。 在本研究中，我们将利用此属性来估计环境照明。 请注意，具有最大反射率的场景点也包括光源。 因此，通过使用此先验，所提出的方法应能够在一定程度上处理发光效应。
所提出的先验部分地受到颜色恒定性研究中使用的众所周知的白色斑块假设的启发。 在[13]中，研究了几种颜色恒定方法中的正像素的影响。 我们概括了这个想法，并提出了一个新的夜间图像去雾先验。
5. Nighttime image dehazing 给定输入图像I，该研究的目的是估计每个像素的环境照度和大气透射率，以便恢复无雾图像。 我们首先在估计环境照明的颜色图之前使用最大反射率，并从输入图像中去除其效果。 然后，在估计变化的照明强度和大气透射率时，我们去除雾度效应并获得最终的颜色平衡和无雾度的图像。 建议的夜间除雾过程的细节将在以下部分中解释。
5.1. Estimation of ambient illumination 在夜间雾霾环境中，从许多点状人造光源辐射的光在空间中平滑地变化，除了一些遮挡导致明暗区域之间的突然变化。 这些边界在整个图像中非常稀疏。 另一方面，雾度在任意方向上散射光。 散射光的聚集导致光线平滑变化。 为此，我们假设每个局部片j∈Ωi上的环境照度Aλj是常数。 具体地，假设环境照明的强度Lj和颜色图ηλj是恒定的，并且写为LΩi和ηλΩi。 此外，还假设传输图tj如[10]中那样平滑地改变。 在[10]之后，我们还假设tj是Ωi上的常数并写为tΩi。 基于上述假设，我们在每个局部补丁Ωi上的Eq（2）的两侧应用max-operator并获得以下结果：
从提出的最大反射率之前，我们有
因此，我们可以通过以下方式估算环境照明的颜色图：
这里，光强度LΩi在所有颜色通道中固定于最大MλΩi。 等式（6）确实描绘了光强度归一化并且仅保持环境照明的颜色分量。 我们将最小化问题描述为图优化问题，并且消光拉普拉斯矩阵确实定义了相邻节点之间的相似性。
在获得粗糙的环境色图ηλΩi之后，我们通过最小化以下优化问题来改进它：
这里Λ是消光拉普拉斯矩阵[15]，它定义了相邻像素之间的相似性[12]，第二项解释了平滑度惩罚。 通过使用图像引导滤波器[11]可以有效地解决（近似）优化问题
5.2. Haze removal 在获得ηλ的估计值之后，我们可以从输入图像中去除颜色效果并重新将Eq（2）写为：
按照上述关于每个局部补丁Ωi的Lj和tj的假设，我们在Eq（8）的两侧应用max-operator，并再次替换最大反射率。类似地，我们有：
由于上述等式适用于每个颜色通道，因此我们在每个通道中计算LΩi并选择最大值作为最终估计值
与ηλ类似，我们通过图像引导滤波器细化LΩi以获得平滑的Li 在获得Li之后，我们可以通过在方程（8）的两侧应用最小算子并引入暗通道先验来估计传输ti。 在数学上，它可以写成：
代表颜色平衡的无雾图像。 获得原始估计tΩi为
我们使用图像引导过滤器进行优化 最后，我们将无雾图像恢复为：
5.3. A Faster Approximated Estimation Method 在这里，我们提出了一种更快的ηλi和Li估计方法，它同时具有Sec5.1和Sec5.2所示的顺序方式。 具体地，在获得最大反射率图MλΩi之后，我们使用图像引导滤波器直接对其进行细化。 然后Li和ηλi计算如下：
ti和Jλj的估计与Sec5.2中描述的过程相同。 我们分别将这两种方法表示为MRP和MRP-Faster
6. Additional experimental results 如果图像中有足够的最大反射区域，则所提出的方法甚至适用于白天模糊图像。 图9显示了一些示例。 该方法更好地校正颜色失真，同时产生可比较的去雾结果。 最后，我们在图10中给出了一些失败的例子。如图10所示，在草和叶的区域中存在一些颜色失真。 主要原因是先前的最大反射率并不适合这些区域。 这将是解决这一问题的另一项未来工作
7. Discussion and conclusion 在本文中，我们提出了一种非常简单但有效的先验，称为最大反射先验，用于从夜间模糊图像中去除雾霾。 最大反射率先验基于室外日间图像的统计。 通过应用先验，我们可以容易地估计环境照明，从而以更简单和更有效的方式从夜间图像中去除雾度。
这项工作与基于统计先验的大多数方案有一些共同的局限性 - 先前可能不适用于某些特定图像。 当场景对象固有地仅具有不同的颜色时，最大反射率先前变为无效。 所提出的方案将为这些物体产生颜色失真，例如图10中的草和树叶。我们打算研究更先进的颜色恒定技术[19,22]来克服这个问题。 此外，我们将在未来的工作中使用更多指标（如FADE [5]）执行更多评估。
参考文章： [1] https://www.jianshu.com/p/6f8dce57c7a4
</content>
    </entry>
    
     <entry>
        <title>DehazeZoo：图像&amp;视频去雾清晰化资源大全（论文/数据集/开源项目）</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>图像去雾</tag>
        </tags>
        <content type="html"> 图像去雾的目的是消除雾霾环境对图像质量的影响，增加图像的可视度，是图像处理和计算机视觉领域共同关切的前沿课题，吸引了国内外研究人员的广泛关注。在github上 cxtalk列举了图像去雾近年来经典论文、评估指标与数据集，在此转载以便记录。
转载自：DehazeZoo (Single Image vs. Video Based) https://github.com/cxtalk/DehazeZoo
DehazeZoo (Single Image vs. Video Based) Xiang Chen, Yufeng Li, Yufeng Huang
1 Description  DehazeZoo: A survey on haze removal from video and single image. Papers, codes and datasets are maintained.
 Thanks for the sharing of DerainZoo by Youzhao Yang.
 More details about image dehazing and deraining are available here.
  2 Image Quality Metrics  PSNR (Peak Signal-to-Noise Ratio) [paper] [matlab code] [python code] SSIM (Structural Similarity) [paper] [matlab code] [python code] VIF (Visual Quality) [paper] [matlab code] FSIM (Feature Similarity) [paper] [matlab code] NIQE (Naturalness Image Quality Evaluator) [paper][matlab code][python code]  3 Dehazing Research 3.1 Datasets  KITTI [paper][dataset] RESIDE [paper][dataset] SceneNet [paper][dataset] I-HAZE [paper][dataset] O-HAZE [paper][dataset] D-HAZY [paper][dataset] Middlebury [paper][dataset] NYU Depth Dataset V2 [paper][dataset]  3.2 Papers 2020  Shen et al, Implicit Euler ODE Networks for Single-Image Dehazing. [paper][code] Liu et al, Efficient Unpaired Image Dehazing with Cyclic Perceptual-Depth Supervision. [paper][code] Li et al, You Only Look Yourself: Unsupervised and Untrained Single Image Dehazing Neural Network. [paper][code] Pang et al, BidNet: Binocular Image Dehazing without Explicit Disparity Estimation. (CVPR) [paper][code] Sourya et al, Fast Deep Multi-patch Hierarchical Network for Nonhomogeneous Image Dehazing. [paper][code] Dong et al, Multi-Scale Boosted Dehazing Network with Dense Feature Fusion. (CVPR) [paper][code] Li et al, Learning to Dehaze From Realistic Scene with A Fast Physics Based Dehazing Network. [paper][code] Shao et al, Domain Adaptation for Image Dehazing. (CVPR) [paper][code][web] Wu et al, Accurate Transmission Estimation for Removing Haze and Noise from a Single Image. (TIP) [paper][code] Ren et al, Single Image Dehazing via Multi-Scale Convolutional Neural Networks with Holistic Edges. (IJCV) [paper][code] Dong et al, FD-GAN: Generative Adversarial Networks with Fusion-discriminator for Single Image Dehazing. [paper][code] Qin et al, FFA-Net: Feature Fusion Attention Network for Single Image Dehazing. (AAAI) [paper][code]  2019  Wu et al, Learning Interleaved Cascade of Shrinkage Fields for Joint Image Dehazing and Denoising. (TIP) [paper][code] Li et al, Semi-Supervised Image Dehazing. (TIP) [paper][code] Li et al, Benchmarking Single Image Dehazing and Beyond. (TIP) [paper][code][web] Pei et al, Classification-driven Single Image Dehazing. [paper][code] Liu et al, GridDehazeNet: Attention-Based Multi-Scale Network for Image Dehazing. (ICCV) [paper][code] Li et al, Joint haze image synthesis and dehazing with mmd-vae losses. [paper][code] Peter et al, Feature Forwarding for Efficient Single Image Dehazing. [paper][code] Shu et al, Variational Regularized Transmission Refinement for Image Dehazing. [paper][code] Liu et al, End-to-End Single Image Fog Removal using Enhanced Cycle Consistent Adversarial Networks. [paper][code] Chen et al, Gated Context Aggregation Network for Image Dehazing and Deraining. (WACV) [paper][code] Ren et al, Deep Video Dehazing with Semantic Segmentation. (TIP) [paper][code]  2018  Ren et al, Gated Fusion Network for Single Image Dehazing. (CVPR) [paper][code][web] Zhang et al, FEED-Net: Fully End-To-End Dehazing. (ICME) [paper][code] Zhang et al, Densely Connected Pyramid Dehazing Network. (CVPR) [paper][code] Yang et al, Towards Perceptual Image Dehazing by Physics-based Disentanglement and Adversarial Training. (AAAI) [paper][code] Deniz et al, Cycle-Dehaze: Enhanced CycleGAN for Single Image Dehazing. (CVPRW) [paper][code]  Before  Ren et al, An All-in-One Network for Dehazing and Beyond. (ICCV) [paper][code][web] Zhu et al, Single Image Dehazing via Multi-Scale Convolutional Neural Networks. (ECCV) [paper][code][web] Cai et al, DehazeNet: An end-to-end system for single image haze removal. (TIP) [paper][code][web] Ren et al, A fast single image haze removal algorithm using color attenuation prior. (TIP) [paper][code] He et al, Single Image Haze Removal Using Dark Channel Prior. (CVPR) [paper][code]  4 Note  The above content is constantly updated, welcome continuous attention!  5 Acknowledgement  Thanks for the sharing of codes of image quality metrics by Wang, Hong.  6 Contact  If you have any question, please feel free to contact Xiang Chen (Email: cx@cvgpu.com). </content>
    </entry>
    
     <entry>
        <title>【论文笔记】AOD-Net: An All-in-One Network for Dehazing and Beyond</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0aod-net/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>图像去雾</tag><tag>AOD-Net</tag>
        </tags>
        <content type="html">  摘要:本文提出了一种用卷积神经网络（CNN）构建的图像去雾模型，称为一体化除雾网络（AOD-Net）。它是基于重新配制的大气散射模型设计的。 AOD-Net不是像大多数先前模型那样分别估算传输矩阵和大气光，而是通过轻量级CNN直接生成清晰图像。这种新颖的端到端设计使得将AOD-Net嵌入到其他深度模型（例如，faster R-CNN）中变得容易，以改善对模糊图像的高级任务性能。在合成和自然模糊图像数据集上的实验结果证明了我们在PSNR，SSIM和主观视觉质量方面优于现有技术的优越性能。此外，当将AOD-Net与faster R-CNN连接并从头到尾训练联合管道时，我们目睹了对模糊图像的对象检测性能的大幅提升。
关键词:去雾，图像恢复，深度学习，联合训练，物体检测。
 论文下载：https://arxiv.org/pdf/1707.06543.pdf
tensorflow源码 ：https://download.csdn.net/download/cherry1307/11012233
pythorch源码: https://github.com/TheFairBear/PyTorch-Image-Dehazing
项目：https://sites.google.com/site/boyilics/website-builder/project-page
引言 由于存在诸如灰尘，雾气和烟雾的气溶胶，雾度的存在给相机捕获的图像增加了复杂的噪声。 它会大大降低室外图像的可见度，对比度降低，表面颜色变暗。 此外，模糊的图像将使许多后续高级计算机视觉任务的有效性受到威胁，例如物体检测和识别。 因此，广泛考虑了去雾算法，作为（不适定的）图像恢复和增强的具有挑战性的实例。 类似于图像去噪和超分辨率[37]，[15]等其他问题，早期的去雾工作[23]，[30]，[38]，[12]假设来自同一场景的多个图像的可用性。 然而，从单个图像中去除雾霾现在已经占据了主导地位，因为它对于实际设置更为实用[7]。 本文重点研究了单幅图像去雾问题。
前人的工作 作为用于去雾的先验知识，模糊图像生成遵循广为接受的物理模型（详见第II-A节）。除了估计全球大气光强度之外，已经认识到实现雾霾去除的关键是传输矩阵的恢复。
[7]通过估计场景的反照率提出了一种物理接地的方法。
[9]，[34]发现有效暗通道先验（DCP）更可靠地计算传输矩阵，然后是一系列工作
[13]，[24]，[36]。 [20]强制执行边界约束和上下文正则化以获得更清晰的恢复图像。在
[33]中提出了一种自动恢复大气光的加速方法。
[45]先前开发了颜色衰减，并为模糊图像创建了场景深度的线性模型，然后以监督的方式学习了模型参数。
[16]说明了联合估计场景深度并从模糊视频序列中恢复清晰潜像的方法。
[1]提出了一种基于非局部先验（雾度线）的算法，基于清晰图像中的每个颜色簇成为RGB空间中的雾度线的假设。
所有上述方法都取决于物理模型和各种复杂的图像统计假设。然而，由于从单个图像估计物理参数通常是不准确的，因此上述方法的去雾性能似乎并不总是令人满意。
最近，随着卷积神经网络（CNN）在计算机视觉任务中取得了普遍的成功，它们也被引入到图像去雾中。
DehazeNet [3]提出了一种可训练的模型来估计一个模糊图像的传输矩阵。
[27]进一步开发了多尺度CNN（MSCNN），它首先生成了一个粗尺度的传输矩阵，然后对其进行了细化。
存在的问题 1）没有端到端去雾：大多数用于图像恢复和增强的深度学习方法完全包含端到端建模：训练模型以直接从损坏的图像中回归清晰的图像。例子包括图像去噪[42]，去模糊[31]和超分辨率[41]。相比之下，迄今为止还没有用于除雾的端到端深度模型，它直接从模糊的模型中回归清晰的图像。虽然乍一看可能看起来很奇怪，但人们需要意识到雾霾本质上会带来不均匀的依赖于信号的噪声：由雾度引起的表面场景衰减与相机表面之间的物理距离相关（即像素深度）。这与假设与信号无关的噪声的大多数图像劣化模型不同，在这种情况下，所有信号都经历相同的参数化降级过程。因此，可以使用一个静态映射功能轻松建模其恢复模型。同样不能直接应用于除雾：降解过程因信号而异，并且恢复模型也必须是输入自适应的。
现有方法具有相同的信念，即估计精确的中间传输图是从雾霾中恢复清晰的场景的关键[1]，[3]，[27]。通过经验规则分别计算大气光，并且基于物理模型恢复清晰图像。尽管是直观的，但是这样的过程不直接测量或最小化重建失真。用于估计传输矩阵和大气光的两个单独步骤中的误差将累积并且可能相互放大。结果，传统的单独管道产生了次优的图像恢复质量。
2）缺少与高级视觉任务的衔接：目前，去雾模型依赖于两组评估标准：（1）对于合成模糊图像，其对应的清晰图像已知，通常计算PSNR和SSIM来测量确保恢复保真度; （2）对于没有清晰图像的真实自然模糊图像，唯一可用的去雾效果比较是主观视觉质量。然而，与图像去噪和超分辨率结果不同，他们视觉伪像的抑制效果是可见的（例如，在纹理和边缘上），现有技术的去雾模型之间的视觉差异[1]，[3]，[27]通常表现在全球的光照和色调中，并且通常太微妙而无法分辨。
一般图像恢复和增强，被称为低级视觉任务的一部分，通常被认为是中级和高级视觉任务的预处理步骤。众所周知，诸如物体检测和识别之类的高级计算机视觉任务的性能将在存在各种劣化的情况下恶化，并且然后在很大程度上受到图像恢复和增强的质量的影响。然而，根据我们的最佳知识，没有探索将去雾算法和结果与高级视觉任务性能相关联。
我们的贡献 在本文中，我们提出了一体化除雾网络（AOD-Net），这是一种基于CNN的除雾模型，具有两个关键创新，以应对上述两个挑战：
 我们是第一个提出端到端可训练的去雾模型，它直接从模糊图像中生成干净的图像，而不是依赖于任何单独的和中间的参数估计步骤1。 。 AOD-Net是基于重新配制的大气散射模型设计的，因此保留了与现有工作相同的物理基础[3]，[27]。然而，它建立在我们不同的信念之上，即物理模型可以以“更端对端”的方式制定，其所有参数在一个统一模型中估算。
 我们是第一个定量研究去雾质量如何影响随后的高级视力任务的人，这项任务是比较去雾效果的新客观标准。此外，AOD-Net可以与其他深层模型无缝嵌入，构成一个管道，在模糊图像上执行高级任务，具有隐式的去雾过程。由于我们独特的一体化设计，这种管道可以从头到尾联合调整，以进一步提高性能，如果用其他深度去雾方法替代AOD-Net是不可行的[3]，[27]。
  AOD-Net在合成模糊图像上进行训练，并在合成和真实自然图像上进行测试。实验证明了AOD-Net优于几种最先进的方法，不仅包括PSNR和SSIM（见图1），还包括视觉质量（见图2）。作为轻量级和高效率的型号，AOD-Net的耗费时间低至0.026秒，可以使用单个GPU处理一个480×640图像。当与更快的R-CNN [26]连接时，AOD-Net在改善模糊图像的物体检测性能方面明显优于其他去雾模型，当我们共同调整AOD-Net和fasterrcnn的流水线时，性能得到进一步提升。
本文从以前的会议版本[14]扩展而来。本文最引人注目的改进在于第四部分，我们对评估和增强物体检测的去雾进行了深入的讨论，并介绍了联合训练部分的细节和分析。我们还对AOD-Net的架构进行了更详细和全面的分析（例如第III-D节）。此外，我们还包括更广泛的比较结果。
提出的方法 物理模型 在本节中，解释了提出的AOD-Net。 我们首先介绍了转换后的大气散射模型，在此基础上设计了AOD-Net。 然后详细描述AOD-Net的体系结构。
A 物理模型和转换公式
大气光散射模型已经是雾霾图像生成的经典描述模型[19], [21], [22]，
其中I(x)是雾霾图像，J(x)是场景辐射（即待恢复的清晰图像），这里有两个关键的参数：A代表大气光值，t(x)代表传输矩阵：
这里beta是大气光的散射系数，d(x)是物体和相机之间的距离，我们可以为清晰图像重写 模型：
现存的诸如[27]，[3]之类的工作遵循相同的三步程序：
1）使用复杂的深模型从模糊图像I（x）估计传输矩阵t（x）;
2）使用一些经验方法估计A;
3）通过（3）估计清洁图像J（x）。
这样的过程导致次优解决方案，其不直接最小化图像重建误差。当将它们组合在一起以计算（3）时，t（x）和A的单独估计将导致累积或甚至放大的误差。
我们的核心思想是将两个参数t（x）和A统一为一个公式，即（4）中的K（x），并直接最小化像素域重建误差。为此，将（3）中的公式重新表示为下面的转换公式：
网络设计 提出的aod-net包含两个模块：
（a）k-estimation模块：从输入图像I(x)估计k（x）;
（b）清晰图像生成模型：k（x）再去估计J（x）
K估算模块是AOD-Net的关键组成部分，负责估算深度和雾浓度。如图4（b）所示，我们使用五个卷积层，并通过融合不同大小的卷积核形成多尺度特征。在[3]中，在第二层中使用具有不同卷积核尺寸的并行卷积。[27]将粗尺度网络特征与细尺度网络的中间层连接起来。受他们的启发，AOD-Net的“concat1”层连接层“conv1”和“conv2”的特征。类似的，“concat2”连接来自“conv2”和“conv3”的特征，“concat3”连接来自“conv3”和“conv4”的特征。这种多尺度设计捕获不同尺度的特征，并且中间连接还不长卷积期间的信息损失。值得注意的是，AOD-Net的每个卷积层仅使用三个卷积核。因此与现有的深层方法相比，AOD-Net重量轻，例如[3],[27]。在K估计模块之后，清晰图像生成块由逐元素乘法层和若干元素加法层组成，以便通过计算（4）生成恢复的图像。
实验结果 数据集和实现 创建合成数据集：NYU2深度数据集，大气光值[0.6,1.0],beta {0.4,0.6,0.8,1.0,1.2,1.4,1.6},取出27256个图像做训练集，3170个做测试集A，Middlebury立体数据集中取出800张full-size合成图像作为测试集B,此外，在自然雾霾图像上也评估了模型的泛化能力。
在训练过程中，使用高斯随机变量初始化权重。 我们使用ReLU神经元，因为我们发现它比[3]中提出的BReLU神经元在我们的特定环境中更有效。 动量和衰减参数分别设置为0.9和0.0001。 我们使用8个图像（480×640）的批量大小，学习率为0.001。 我们采用简单的均方误差（MSE）损失函数，并且很高兴地发现它不仅提升了PSNR，还提升了SSIM以及视觉质量。AOD-Net模型需要大约10个训练时期才能收敛，并且通常在10个时期之后表现得足够好。 在本文中，我们已经训练了40个时期的模型。 还发现将范数约束在[-0.1,0.1]内对clip the gradient （防止梯度爆炸）很有帮助。 该技术在稳定复发网络训练方面很受欢迎[25]。
合成数据集上的质量评估 对比方法：
 Fast Visibility Restoration (FVR) [35], Dark-Channel Prior (DCP) [9], Boundary Constrained Context Regularization (BCCR) [20], Automatic Atmospheric Light Recovery (ATM) [33], Color Attenuation Prior (CAP) [45], Non-local Image Dehazing (NLD) [1], [2], DehazeNet [3], and MSCNN [27]  在之前的实验中，由于在真实模糊图像上进行测试时没有无雾霾的真实性，因此报告了很少有关于恢复质量的定量结果。 我们合成的模糊图像伴随着地面实况图像，使我们能够根据PSNR和SSIM比较这些去噪结果。
表I和III-B分别显示了测试集A和B上的平均PSNR和SSIM结果。 由于AOD-Net在MSE损失下从端到端进行了优化，因此看到其PSNR性能高于其他方法并不令人惊讶。 更有吸引力的是观察到AOD-Net比所有竞争对手获得更大的SSIM优势，尽管SSIM并未直接被称为优化标准。 由于SSIM的测量超出了像素方面的误差，并且众所周知，它更忠实地反映了人类的感知，因此我们对AOD-Net的哪一部分实现了这种持续改进感到好奇。
我们进行以下调查：TestSet B中的每个图像被分解为平均图像和残差图像的总和。前者由具有相同平均值的所有像素位置构成（图像上的平均3通道矢量）。很容易证明两个图像之间的MSE等于它们在两个残留图像之间添加的平均图像之间的MSE。平均图像大致对应于全局照明并且与A相关，而残差更多地涉及局部结构变化和对比等。我们观察到AOD-Net产生类似的残余MSE（在TestSet B上平均）到一些竞争对手DehazeNet和CAP等方法。然而，AOD-Net结果的平均部分的MSE显着低于DehazeNet和CAP，如表III所示。由此暗示，由于我们在端到端重建损失下的联合参数估计方案，AOD-Net可能更能够正确地恢复A（全局照明）。由于人眼对全局照明的大变化肯定比对任何局部失真更敏感，因此难怪为什么AOD-Net的视觉效果也明显更好，而其他一些结果通常看起来不切实际。
上述优点也体现在计算SSIM [39]的照明（1）项中，并部分解释了我们强大的SSIM结果。 SSIM收益的另一个主要来源似乎来自对比（c）项。例如，我们随机选择五个图像进行测试，TestSetB上AOD-Net结果的对比值平均值为0.9989，显着高于ATM（0.7281），BCCR（0.9574），FVR（0.9630），NLD（0.9250），DCP （0.9457），MSCNN（0.9697），DehazeNet（0.9076）和CAP（0.9760）。
视觉效果评估 a）合成图像：图5显示了来自TestSet A的合成图像的去雾结果。我们观察到AOD-Net结果通常具有更清晰的轮廓和更丰富的颜色，并且在视觉上更忠实于地面实况。
b）具有挑战性的自然图像：虽然通过室内图像合成训练，但ADO-Net可以很好地泛化为室外图像。我们根据一些自然图像示例的最新方法对其进行评估，这些示例比[9]，[8]，[3]的作者发现的一般室外图像更具挑战性。挑战在于高度杂乱的物体，精细纹理或照明变化的主导地位。如图6所示，FVR遭受过度增强的视觉伪影。 DCP，BCCR，ATM，NLD和MSCNN在一个或多个图像上产生不切实际的色调，例如第二行上的DCP，BCCR和ATM结果（注意天空颜色），或第四行上的BCCR，NLD和MSCNN结果（注意石头颜色）。 CAP，DehazeNet和AOD-Net拥有最具竞争力的视觉效果，具有合理的细节。然而，仔细观察，我们仍然观察到CAP有时会模糊图像纹理，而DehazeNet会使某些区域变暗。 AOD-Net恢复更丰富和更饱和的颜色（在第三和第四行结果之间进行比较），同时抑制大多数伪像。
c）白色风景自然图像：白色场景或物体一直是去除雾霾的主要障碍。许多有效的先验如[9]在白色物体上失效，因为对于与大气光相似颜色的物体，透射值接近于零。 DehazeNet [3]和MSCNN [27]都依赖于精心挑选的过滤操作进行后处理，这提高了它们对白色物体的稳健性，但不可避免地牺牲了更多的视觉细节。虽然AOD-Net没有明确考虑处理白色场景，但我们的端到端优化方案似乎在这里提供了更强的鲁棒性。图7显示了白色场景的两个模糊图像以及通过各种方法的去雾结果。很容易注意到DCP结果的无法忍受的瑕疵，特别是在第一行的天空区域。这个问题得到缓解，但仍然存在CAP，DehazeNet和MSCNN结果，而AOD-Net几乎没有人工制品。此外，CAP似乎模糊了白色物体的纹理细节，而MSCNN创建了过度增强的相反效果：请参阅猫头部区域进行比较。 AOD-Net设法消除雾霾，而不会引入假色调或扭曲的物体轮廓。
d）对无雾图像的小影响：虽然经过模糊的图像训练，AOD-Net被证实具有非常理想的特性，如果它没有雾度，它对输入图像几乎没有负面影响。这赞同我们的K估计模块的稳健性和有效性。图8显示了来自Colorlines的两个具有挑战性的清晰图像的结果[8]。
e）图像反光晕：我们在另一个图像增强任务上尝试AOD-Net，称为图像反光晕，无需重新训练。光晕是光线超出适当边界的扩散，在照片的明亮区域形成不希望的雾化效果。与去雾相关但遵循不同的物理模型，AOD-Net的反光晕结果也是不错的：参见图9的一些例子。
多尺度特征的有效性 在本节中，我们专门分析了K估计模块的层间级联的有用性，它结合了不同大小的滤波器的多尺度特征。 我们认为，尽管经验性发现，当前的连接方式通过始终将几个连续的较低层连续馈入下一层，促进了从低层到高层的平滑特征转换。 为了进行比较，我们设计了一个基线：“conv1→conv2→conv3→conv4→conv5（K）”，它不涉及层间连接。 对于TestSet A，平均PSNR为17.0517 dB，SSIM为0.7688。 对于TestSet B，平均PSNR为22.3359 dB，SSIM为0.9032。 这些结果通常不如AOD-Net（除了TestSet B上的PSNR略高），特别是两个SSIM值都遭受显着下降。
速度对比 AOD-Net的轻质结构导致更快的除雾。 我们在同一台机器（Intel（R）Core（TM）i7-6700 CPU@3.40GHz和16GB内存）上为所有型号选择了来自TestSet A的50个图像，没有GPU加速。 所有型号的每图像平均运行时间如表IV所示。 尽管其他Matlab实现较慢，但比较DehazeNet（Pycaffe版本）和我们的[11]是公平的。 结果表明AOD-Net具有很高的效率，每张图像仅占DehazeNet的1/10
高层视觉任务：评估和提升目标检测任务中的去雾 高级计算机视觉任务，如物体检测和识别，涉及视觉语义，并受到了极大的关注[26]，[43]。然而，这些算法的性能可能在很大程度上受到实际应用中各种降级的危害。传统方法在进入目标任务之前采用单独的图像恢复步骤。最近，[40]，[17]验证了恢复和识别步骤的联合优化将显着提高传统两阶段方法的性能。然而，之前的方法[44]，[5]，[4]主要仅针对图像分类任务，研究了常见降级（如噪声，模糊和低分辨率）的影响和补救措施。据我们所知，没有类似的工作来定量研究雾霾的存在如何影响高级视觉任务，以及如何使用联合优化方法来减轻其影响。我们研究了雾霾存在下的物体检测问题，作为高级视觉任务如何与除雾相互作用的一个例子。我们选择faster R-CNN模型[26]作为强基线4，并测试合成和自然有雾图像。然后，我们将AOD-Net模型与更快的R-CNN模型连接起来，作为统一管道进行联合优化。从我们的实验得出的一般结论是：随着雾度变重，物体检测变得不太可靠。在所有雾霾条件下（轻度，中度或重度），我们的联合调谐模型不断改进检测，超越maive fster R-CNN和非联合的方法。
Pascal-voc2007上的合成雾霾图像的质量评估 A.具有合成雾度的Pascal-VOC 2007的定量结果我们从Pascal VOC 2007数据集（称为Groundtruth）创建了三个合成集[6]：
重雾（A = 1，β= 0.1）， 中雾（A = 1，β= 0.06） 轻雾（A） = 1，β= 0.04）。 通过[18]中描述的方法预测深度图。每组被分成非重叠训练集和测试集。首先，我们比较五种方案而不进行任何网络微调：
（1）naive fater - RCNN：使用清晰的Pascal-VOC 2007上预先训练的模型直接输入模糊图像;
（2）DehazeNet &#43;faster R-CNN：首先使用DehazeNet进行除雾，然后使用faster R-CNN;
（3）MSCNN &#43;faster R-CNN：首先使用MSCNN进行除雾，然后使用faster R-CNN;
（4）DCP &#43;faster R-CNN：首先使用DCP进行除雾，然后使用faster R-CNN;
（5）AOD-Net&#43;faster R-CNN：AOD-Net与faster R-CNN连接，没有任何联合调整。
我们计算三个测试集的平均精度（mAP），如表V中的前三行所示。清晰的Pascal-VOC 2007测试集上的mAP为0.6954。我们可以看到，重度雾霾使mAP降低了近0.18。通过在检测之前首先使用各种去雾方法去雾，mAP改善了很多。其中，DCP &#43;faster rcnn4我们使用基于20种Pascal VOC 2007数据集预训练的VGG16模型，由faster R-CNN作者提供：https：//github.com/ rbgirshick / py-fast-rcnnR-CNN表现最佳，重雾度提高21.57％。没有任何联合调整，AOD-Net &#43;faster R-CNN表现与MSCNN &#43;faster R-CNN相当，并且看起来比DCP &#43;faster R-CNN更差。
由于我们的一体化设计，AOD-Net &#43; Faster R-CNN的流水线可以从头到尾联合优化，以提高对模糊图像的物体检测性能。我们分别为三个雾霾的训练集调整AOD-Net &#43; Faster R-CNN，并将此调谐版称为JAOD-Faster R-CNN。我们在前35,000次迭代中使用0.0001的学习率，在接下来的65,000次迭代中使用0.00001，两者的动量均为0.9，重量衰减为0.0005。由于这种联合调整，重雾度情况下mAP从0.5794增加到0.6819，这显示了这种端到端优化的主要优势和我们独特设计的价值。为了比较，我们还在雾霾数据集上重新训练faster R-CNN作为比较。我们使用0.0001的学习率来微调预训练的更快的R-CNN（在清晰的自然图像上训练）。在重新训练以适应雾霾数据集之后，在重度雾度下，再训练的快速R-CNN的mAP从0.5155增加到0.6756，同时仍然比JAOD-faster R-CNN更差。此外，由于实际上希望获得一个适用于任意雾度水平的统一模型，我们生成包括各种雾度水平的训练集，其中β从[0,0.1]随机采样。我们在这个训练集上重新调整和评估JAOD-Faster R-CNN和Retrained Faster R-CNN，其结果在表V的最后一行进行比较。尽管两者的表现都略逊于他们训练和申请的“专用”对应物。在特定的雾度水平下，它们在所有三种雾度水平下都表现良好，而JAOD-Faster R-CNN再次优于Retrained Faster R-CNN。图11描绘了在各种雾度条件下，在JAOD-Faster R-CNN和再培训更快的R-CNN方案之间每5,000次迭代的mAP比较。
自然雾霾图像的质量评估 图10显示了对Web源自然模糊图像的对象检测结果的视觉比较。比较了六种方法： (1) naive Faster-RCNN; (2) DehazeNet &#43; Faster R- CNN ; (3) MSCNN &#43; Faster R-CNN ; (4) AOD-Net &#43; Faster R- CNN; (5) Fine-tuned Faster R-CNN. (6) JAOD-Faster R-CNN.。我们观察到雾霾可能导致错误检测，不准确的本地化以及对于fster R-CNN的不自信的类别识别。虽然AOD-Net &#43; Faster R-CNN已经显示出优于原始Faster-RCNN的明显优势，但JAOD-Faster R-CNN结果的性能进一步显着提升，显着超越所有其他替代方案。
请注意，AOD-Net &#43; Faster R-CNN从联合优化中获益双重：AOD-Net本身共同估算所有参数，整个流水线共同调整低水平（去雾）和高水平（检测）和认可）端到端的任务。端到端的管道调整是由AOD-Net独特实现的，AOD-Net是迄今为止唯一的一体化除雾模型。
到底那个起到实际帮助：特定任务的除雾网络或只是添加更多参数？ 虽然JAOD-Faster R-CNN可以说是上面所示的最佳表现者，但自然会出现一个问题：它是否是AOD-Faster R-CNN使用的参数比（Retrained）faster R-CNN更多的结果？在本节中，我们展示了添加额外的图层和参数，而没有针对去雾的任务特定设计，并不一定能提高雾度中对象检测的性能。我们设计了一个名为Auto-Faster R-CNN的新基线，用简单的卷积自动编码器取代了JAOD-Faster R-CNN中的AOD-Net部分。自动编码器与AOD-Net具有相同数量的参数，由五个卷积层组成，其结构类似于K估计模块。我们使用与AOD-Net相同的训练协议和数据集预先训练用于除雾任务的自动编码器，并将其与更快的R-CNN连接以进行端到端调整。如表VI所示，自动更快的R-CNN的性能与AOD-Faster R-CNN并不相同，并且表现得比微调更快的R-CNN更差。回想一下[26]证实直接向更快的R-CNN添加额外的层并不一定能改善一般干净图像中物体检测的性能。我们的结论是它在朦胧案件中的一贯对应。此外，应该注意的是，尽管JAOD-Faster R-CNN在更快的R-CNN之前添加了AOD-Net，但由于AOD-Net的轻量化设计，复杂性并未增加太多。对于（Retrained）faster R-CNN，每个图像的平均运行时间为0.166秒，对于JAOD-Faster R-CNN，使用NVIDIA GeForce GTX TITAN X GPU为0.192秒。
讨论和结论 本文提出了AOD-Net，这是一种一体化的管道，可以通过端到端的CNN直接重建无雾图像。我们使用客观（PSNR，SSIM）和主观标准，在合成和自然雾度图像上比较AOD-Net与各种最先进的方法。广泛的实验结果证实了AOD-Net的优越性，稳健性和效率。此外，我们还提出了第一个关于AOD-Net如何通过联合管道优化提高自然朦胧图像上的物体检测和识别性能的研究。可以观察到，我们共同调整的模型在雾度存在的情况下不断改进检测，超过了天真的更快的R-CNN和非关节方法。然而，如上所述，去雾技术与来自图像的深度估计高度相关，并且通过结合深度先验知识或精细的深度估计模块，存在改善AOD-Net的性能的空间。
参考文章 [1] https://blog.csdn.net/Julialove102123/article/details/89046288
</content>
    </entry>
    
     <entry>
        <title>【论文笔记】MSCNN: Single Image Dehazing via Multi-Scale Convolutional Neural Networks</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0mscnn/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>图像去雾</tag><tag>MSCNN去雾</tag>
        </tags>
        <content type="html">  现存方法缺点：The performance of existing image dehazing methods is limited by hand-designed features, such as the dark channel, color disparity and maximum contrast, with complex fusion schemes.
提出的方法：In this paper, we propose a multi-scale deep neural network for single-image dehazing by learning the mapping between hazy images and their corresponding transmission maps. The proposed algorithm consists of a coarse-scale net which predicts a holistic transmission map based on the entire image, and a fine-scale net which refines results locally. To train the multi-scale deep network, we synthesize a dataset comprised of hazy images and corresponding transmission maps based on the NYU Depth dataset. Extensive experiments demonstrate that the proposed algorithm performs favorably against the state-of-the-art methods on both synthetic and real-world images in terms of quality and speed.
 项目主页：https://sites.google.com/site/renwenqi888/research/dehazing/mscnndehazing
论文下载：https://drive.google.com/open?id=0B7PPbXPJRQp3TUJ0VjFaU1pIa28
代码下载：https://drive.google.com/open?id=0B7PPbXPJRQp3TUJ0VjFaU1pIa28
暗通道模型&#43;深度学习
动机：现有图像去雾方法的性能受到手工设计的特征的限制（先验），例如暗通道，颜色差异和最大对比度，以及复杂的融合方案
对比方法： Tan（2007）、Fattal（2008）、DCP、 BCCR（Meng）、Tarel、Tang
方法：通过学习模糊图像与其相应的传输图之间的映射，提出了一种用于单图像去雾的多尺度深度神经网络。 所提出的算法包括粗尺度网络，其基于整个图像预测整体透射图，以及精细尺度网络进行局部性的优化。
MSCNN：
 提出一个多尺度的CNN来学习有效的特征（t）； 首先由粗尺度网络估计场景传输图，然后由精细尺度网络细化； 分析传统方法提取的特征与CNN学习的特征之间的差异；  优点：
 时间很快  缺点：
 对夜晚雾情况处理不好   t(x)：通过最小化预估的t(x)与真实图像的t(x)之间的MSE;具体步骤见Fig2(b)
A：通过在透射图t（x）中选择0.1％最暗像，在这些像素中，选择相应的雾图像I中具有最高强度的像素作为大气光。
提到了他们的速度很快：
海报：
</content>
    </entry>
    
     <entry>
        <title>【论文笔记】DehazeNet: An End-to-End System for Single Image Haze Removal</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0dehazenet/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>图像去雾</tag><tag>DehazeNet</tag>
        </tags>
        <content type="html"> 该文章提出一种名为DehazeNet的可训练的端到端系统，用于传输值估计。 DehazeNet将模糊图像作为输入，并输出其中间透射图，随后用于通过大气散射模型恢复无雾图像。 DehazeNet采用基于卷积神经网络的深层架构，其层专门设计用于体现图像去雾中已建立的假设/先验。具体而言，Maxout单位的图层用于特征提取，这可以生成几乎所有与雾相关的特征。我们还在DehazeNet中提出了一种新的非线性激活函数，称为双边整流线性单元，它能够提高恢复的无雾图像的质量。我们在提议的DehazeNet的组件与现有方法中使用的组件之间建立连接。基准图像的实验表明，DehazeNet比现有方法具有更高的性能，同时保持高效和易用。
摘要  背景：Single image haze removal is a challenging ill-posed problem.
现存方法：Existing methods use various constraints/priors to get plausible dehazing solutions. The key to achieve haze removal is to estimate a medium transmission map for an input hazy image.
提出的方法：In this paper, we propose a trainable end-to-end system called DehazeNet, for medium transmission estimation. DehazeNet takes a hazy image as input, and outputs its medium transmission map that is subsequently used to recover a haze-free image via atmospheric scattering model. DehazeNet adopts convolutional neural network-based deep architecture, whose layers are specially designed to embody the established assumptions/priors in image dehazing. Specifically, the layers of Maxout units are used for feature extraction, which can generate almost all haze-relevant features. We also propose a novel nonlinear activation function in DehazeNet, called bilateral rectified linear unit, which is able to improve the quality of recovered haze-free image. We establish connections between the components of the proposed DehazeNet and those used in existing methods. Experiments on benchmark images show that DehazeNet achieves superior performance over existing methods, yet keeps efficient and easy to use.  贡献  DehazeNet是一个端到端系统。 它直接学习和估计模糊图像patches与其传输图之间的映射关系。 这是通过其深层架构的特殊设计来实现的，以体现已建立的图像去雾原理。 提出了一种新的非线性激活函数，称为双边整流线性单元1（BReLU）。 BReLU扩展了整流线性单元（ReLU）并证明了其在获得精确图像恢复方面的重要性。 从技术上讲，BReLU使用双边约束来减少搜索空间并改善收敛。 在DehazeNet的组件与现有的去雾方法中使用的假设/先验之间建立联系，并解释DehazeNet通过自动从头到尾自动学习所有这些组件来改进这些方法。   图像去雾的核心 现有的图像去雾（Image Dehazing）技术离不开一个简单的自然模型——大气散射模型（Atmospheric Scattering Model）。大气散射模型描述了，在雾霾和光照的共同作用下的成像机制：
其中，$t(x)$ 是媒介透射率（medium transmission），顾名思义表示能顺利透过雾霾到达摄像头的比率。因此，透射率跟物体与摄像头距离 $d(x)$ 成反比，离摄像头越远的物体受雾霾影响更大。当距离 $d(x)$ 趋于无穷大时，透射率 $t(x)$ 趋于零，$I(x)$ 趋近于 $\alpha$，其中：
 &amp;#x03B1;=  max  y&amp;#x2208; x&amp;#x007C;t x &amp;#x2264;t0   I y   综上所述，去雾的核心是如何更精确地估计媒介透射率 t(x)。
基于人工特征 手工特征是传统机器视觉的基础，讲究的是熟能生巧，依赖的是实践出真知。通过“观察→经验→设计”构建各式各样的特征来满足各式各样的任务需求。图像去雾技术也是沿着手工特征逐步地发展起来。
（1）暗通道先验[2]（Dark Channel Prior，DCP）
说起去雾特征，不得不提起的暗通道先验（DCP）。大道之行在于简，DCP作为CVPR 2009的最佳论文，以简洁有效的先验假设解决了雾霾浓度估计问题。
观察发现，清晰图像块的RGB颜色空间中有一个通道很暗（数值很低甚至接近于零）。因此基于暗通道先验，雾的浓度可由最暗通道的数值近似表示：
 D(x)=  min  y&amp;#x2208;&amp;#x03A9;(x)  (  min  c&amp;#x2208;&amp;#x007B;r,g,b&amp;#x007D;   I c  (y))  （2）最大对比度[3]（Maximum Contrast，MC）
根据大气散射模型，雾霾会降低物体成像的对比度：Σx‖ΔI(x)‖=tΣx‖ΔJ(x)‖≤Σx‖ΔJ(x)‖。因此，基于这个推论可利用局部对比度来近似估计雾霾的浓度。同时，也可以通过最大化局部对比度来还原图像的颜色和能见度。
 C(x)=  max  y&amp;#x2208; &amp;#x03A9; r  (x)     1   &amp;#x03A9; s  (y)     &amp;#x2211;  z&amp;#x2208; &amp;#x03A9; s  (y)   &amp;#x007C;&amp;#x007C;I(z)&amp;#x2212;I(y)&amp;#x007C;&amp;#x007C;  2      （3）颜色衰减先验[4]（Color Attenuation Prior，CAP）
颜色衰减先验（CAP）是一种与暗通道先验（DCP）相似的先验特征。观察发现雾霾会同时导致图像饱和度的降低和亮度的增加，整体上表现为颜色的衰减。根据颜色衰减先验，亮度和饱和度的差值被应用于估计雾霾的浓度：
（4）色度不一致(Hue Disparity)[5]
 H(x)=&amp;#x007C; I  si h  (x).. I h  (x)&amp;#x007C;  基于深度智能 人的视觉系统并不需依赖这些显式的特征变换，便可以很好地估计雾的浓度和场景的深度。DehazeNet是一个特殊设计的深度卷积网络，利用深度学习去智能地学习雾霾特征，解决手工特征设计的难点和痛点。
网络的设计
 第一层是特征提取层，即提取有雾图像特征。根据不同的假设与先验设计不同的滤波器。举的例子中有16个滤波器。其中每四个是上述一种先验特征滤波器。通过maxout unit的激活函数，每四个输出一张图。这里不padding，输入是3*16*16三通道的块。输出的是四个16*12*12,每一个代表一种特征。
 使用多尺度的平行卷积操作。由于多尺度特征被证明有利于去雾并且在inception的模型中也用到了平行卷积，即同一张图用不同尺度的卷积核进行卷积。分别用16个3*3、16个5*5和16个7*7的卷积核进行卷积，每一种尺度产生16个，并且通过padding每张图大小应该是一致的。总共获得48个48*10*10。
 Maxpooling对局部数据敏感，另外根据假设透射率有局部不变性，所以用一个7*7局部最大值滤波替代maxpooling。输出是48个48*6*6。
 通过1个4*4的卷积核，产生1*1的标量，并且使用的激活函数为BReLU。因为ReLU抑制了小于0的数，只适用于图像分类等方面，并不适合图像复原。因为最后的透射率图允许高于1或者低于0。所以提出了BReLU，既保持了局部线性，又保持了双边的限制。输出的是一个标量，即输入块中心点的透射率值。
  参考文献 [1] Cai B, Xu X, Jia K, et al. DehazeNet: An End-to-End System for Single Image Haze Removal [J]. IEEE Transactions on Image Processing, 2016, 25(11): 5187-5198.
[2] He K, Sun J, Tang X. Single image haze removal using dark channel prior[J]. IEEE transactions on pattern analysis and machine intelligence, 2011, 33(12): 2341-2353.
[3] Tan R T. Visibility in bad weather from a single image[C]//Computer Vision and Pattern Recognition, 2008. CVPR 2008. IEEE Conference on. IEEE, 2008: 1-8.
[4] Zhu Q, Mai J, Shao L. A fast single image haze removal algorithm using color attenuation prior[J]. IEEE Transactions on Image Processing, 2015, 24(11): 3522-3533.
[5] C. O. Ancuti, C. Ancuti, C. Hermans, and P. Bekaert, “A fast semiinverse approach to detect and remove the haze from a single image,” in Computer Vision–ACCV 2010, 2011, pp. 501–514.
[6] Goodfellow I J, Warde-Farley D, Mirza M, et al. Maxout networks[J]. ICML (3), 2013, 28: 1319-1327.
[7] DehazeNet: An End-to-End System for Single Image Haze Removal解读 https://blog.csdn.net/Julialove102123/article/details/80199276
[8] 阅读笔记&amp;mdash;-DehazeNet:An End-to-End System for Single Image Haze Removal https://blog.csdn.net/yinhou1771/article/details/82682311
</content>
    </entry>
    
     <entry>
        <title>【论文笔记】暗通道先验去雾算法</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E6%9A%97%E9%80%9A%E9%81%93%E5%85%88%E9%AA%8C%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>图像去雾</tag><tag>暗通道</tag>
        </tags>
        <content type="html"> 雾霾是由空气中的灰尘和烟雾等小的漂浮颗粒产生的常见大气现象。这些漂浮的颗粒极大地吸收和散射光，导致图像质量下降。在雾霾影响下，视频监控，远程感应，自动驾驶等许多实际应用很容易受到威胁，检测和识别等高级计算机视觉任务很难完成。因此，图像去雾（除雾）成为一种越来越重要的技术。在图像去雾领域，不得不学习何凯明在2009CVPR上获最佳论文的文章。
暗通道先验理论 暗通道先验是基于如下观察，在户外的无雾图像中，在大部分非天空区域，至少有一个通道值是很小一个数或趋近于零。因此，对任意一幅图 $J$，给出暗通道 $J^{dark}$ 的表示：
  J  dark  (X)=  min&amp;#x200B;  y&amp;#x2208;&amp;#x03A9;(x)  (  min&amp;#x200B;  c&amp;#x2208;&amp;#x007B;r,g,b&amp;#x007D;   J c  (Y))  其中两个最小是各通道最小，局部窗口最小。即首先对图像每个像素取三通道中最小值，得到一个单通道图，然后对这个单通道图作最小值滤波就可以得到暗通道图 $J^{dark}$。
作者将造成这个现象的原因归结为以下三点：
 各类物体的阴影，玻璃 彩色物体表面，如花草树木，蓝色的水面 色物体表面，如树干，石头等  正因为自然界总是充满了彩色和阴影，就导致了图像暗通道总是很暗。为了验证这个先验知识，作者统计了大量图片，发现基本都符合这个先验。以下是几幅680*1024的风景图在不同大小滤波窗口下的暗通道图：
以上图像基本都符合暗通道先验，由此可见暗通道的普遍性。在暗通道先验的基础上，就可以进行去雾算法的推导。
大气散射模型 在计算机视觉和计算机图形领域，一个常用来描述有雾图像的公式表达为：
 I(x)=J(x)t(x)&#43;A(1&amp;#x2212;t(x))  其中: $I(x)$ 为拍摄的含雾图像，$J(x)$ 为无雾图像，$t(x)$ 为透射率，用来描述太阳光通过媒质投射到照相机过程中没有被散射的部分，$A$ 为全球大气光成分。
可见含雾图像 $I(x)$ 的形成主要由两部分决定：第一部分是 $I(x)t(x)$ 构成的直接衰减项，用于描述景物光线在透射媒介中经衰减后的部分；第二部分是 $A[1-t(x)]$ 构成的大气光照，它由图像采集装置前方的散射引起，会导致景物色调的偏移。如图所示。
暗通道先验去雾算法 首先假设大气光成分 $A$ 已知。去雾模型可以化为以下方程：
$$ \frac{{{I^c}(x)}}{{{A^c}}}{\text{ = }}t(x)\frac{{{J^c}(x)}}{{{A^c}}}{\text{ &#43; }}1 - t(x) $$
上标 $c$ 即表示r,g,b三通道。
进一步假设每个滤波窗口内的透射率 $t(x)$ 是常数，记为$\overline t (x)$ ，然后对方程两边同时计算暗通道，即作两次最小值运算，可得下式：
   min  y&amp;#x2208;&amp;#x03A9;(x)  &amp;#x200B;(  min&amp;#x200B; c     I c  (y)   A c    &amp;#x200B;)=t &amp;#x00AF;  (x)  min  y&amp;#x2208;&amp;#x03A9;(x)  &amp;#x200B;(  min&amp;#x200B; c     J c  (y)   A c    &amp;#x200B;)&#43;1&amp;#x2212;t &amp;#x00AF;  (x)  因为 $\bar t(x)$ 是常量，所以放在最小运算外面。
根据暗通道先验，$J$ 趋近于零：
  J  dark  (x)=  min  y&amp;#x2208;&amp;#x03A9;(x)  &amp;#x200B;(  min c  &amp;#x200B; J c  (y))=0  因为 $A^c$ 总是正值，可得：
   min  y&amp;#x2208;&amp;#x03A9;(x)  &amp;#x200B;(  min c  &amp;#x200B;   J c  (y)   A c    )=0  代回原式，即可简单地得到透射率估计值：
 t &amp;#x00AF;  (x)=1&amp;#x2212;  min  y&amp;#x2208;&amp;#x03A9;(x)  &amp;#x200B;(  min c  &amp;#x200B;   I c  (y)   A c    )  同时，即使是晴天，大气光成分还是存在的，尤其是在看远处的物体时给人的感觉更强。这种大气光成分会给人一种景深的层次感，去雾要有所保留。因此，引入一个常量参数 $\omega (0 &amp;lt; \omega &amp;lt; 1)$ 用来控制去雾的程度：
 t &amp;#x00AF;  (x)=1&amp;#x2212;&amp;#x03C9;  min  y&amp;#x2208;&amp;#x03A9;(x)  &amp;#x200B;(  min c  &amp;#x200B;   I c  (y)   A c    )  作者在文中建议的 $\omega$ 为0.95。
在算法开始的地方就假设 $A$ 是已知，那么具体如何得到 $A$ 的值。作者在文中给出的方法是，在暗通道中找出前0.1%最亮的点，即透射率最小的点。对于这些点，去雾图中找到对于的点，并取它们中的所有通道最大的值作为 $A$ 的近似。至此，透射率 $t(x)$，大气光成分 $A$，雾图 $I$，都是已知了，就可以求解无雾图：
 J(x)=  I(x)&amp;#x2212;A  max(t(x),t0&amp;#x200B;)  &amp;#x200B;&#43;A  其中，$t_0$ 为一个透射率下界。由于直接恢复时，当透射率 $t(x)$ 接近零的时候，$J(x)t(x)$ 也为零，这就会失去原图信息，容易引入噪声，因此设置一个下界，在雾密度很大的地方，保留一定数量的雾。$t_0$ 的值一般取0.1。作者还提到，去雾后的图像一般会显得比较暗淡，可以适当增加曝光以得到更好的效果。
参考文章  暗通道去雾 https://blog.csdn.net/weixin_43194305/article/details/89206379 </content>
    </entry>
    
     <entry>
        <title>网络挖掘及其相关应用</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>复杂网络</tag><tag>社交网络挖掘</tag>
        </tags>
        <content type="html"> 网络挖掘及其相关应用
1 网络结构 1.1 网络统计特征 网络模型许多概念来自于图论，因为网络模型本质上是一个由节点和边组成的图。以下为网络模型中常用的统计概念。
 度（Degree）：节点的度定义为与该节点相连的边的数目。在有向图中，所有指向某节点的边的数量叫作该节点的入度，所有从该节点出发指向别的节点的边的数量叫作该节点的出度。网络平均度反应了网络的疏密程度，而通过度分布则可以刻画不同节点的重要性。
 网络密度（Density）：网络密度可以用于刻画节点间相互连边的密集程度，定义为网络中实际存在边数与可容纳边数上限的比值，常用来测量社交网络中社交关系的密集程度及演化趋势。
 平均路径长度（Average path length）：两节点间的距离为连接两者的最短路径的边的数目，网络的直径为任意两点间的最大距离；网络的平均路径长度则是所有节点对之间距离的平均值，它描述了网络中节点间的分离程度，即网络有多小。
 聚类系数（Clustering Coefficient）：用于描述网络中与同一节点相连的节点间也互为相邻节点的程度。其用于刻画网络中一个人朋友们之间也互相是朋友的概率，反应了网络中的聚集性。
 介数（Betweeness）：为图中某节点承载整个图所有最短路径的数量，通常用来评价节点的重要程度，比如在连接不同社群之间的中介节点的介数相对于其他节点来说会非常大，也体现了其在社交网络信息传递中的重要程度。
  网络通常是采用邻接矩阵和邻接表的形式进行存储，节点之间存在连边则对应为1，若不存在连边则为0。
参考文献： 一文读懂社交网络分析：学术研究、应用、前沿与学习资源
1.2 网络特征与模型 1.2.1 网络特征  小世界现象：小世界现象是指地理位置相距遥远的人可能具有较短的社会关系间隔。早在1967年，哈佛大学心理学教授 Stanley Milgram 通过一个信件投递实验，归纳并提出了“六度分割理论（Six Degrees of Separation）”, 即任意两个都可通过平均五个人熟人相关联起来。1998年，Duncan Watts 和 Steven Strogatz 在《自然》杂志上发表了里程碑式的文章《Collective Dynamics of “Small-World” Networks》，该文章正式提出了小世界网络的概念并建立了小世界模型。  小世界现象在在线社交网络中得到了很好地验证，根据2011年 Facebook 数据分析小组的报告， Facebook 约7.2亿用户中任意两个用户间的平均路径长度仅为4.74，而这一指标在推特中为4.67。可以说，在五步之内，任何两个网络上的个体都可以互相连接。
一般来说，小世界网络的特征是高聚类系数和低平均路径长度。复杂网络的小世界效应是指尽管网络的规模很大(网络节点数目N很大)，但是两个节点之间的距离比我们想象的要小得多。也就是网络的平均路径长度L随网络的规模呈对数增长，即L～In N。大量的实证研究表明，真实网络几乎都具有小世界效应。
 无标度特性：大多数真实的大规模社交网络都存在着大多数节点有少量边，少数节点有大量边的特点，其网络缺乏一个统一的衡量尺度而呈现出异质性，我们将这种节点度分布不存在有限衡量分布范围的性质称为无标度。无标度网络表现出来的度分布特征为幂律分布，这就是此类网络的无标度特性。  ＊ 我们平时听说的听说的「小世界网络」，网络上的「马太效应」，「强连接」和「弱连接」，甚至「肥胖是可以传染的」到底是什么意思？
＊ 研究者通常用哪些量来刻画复杂网络的整体性质（例如「小世界」特性）或者局部性质（例如用户之间的「趋同性」）？
参考文献： * 一文读懂社交网络分析：学术研究、应用、前沿与学习资源
 System Sciences at SIS  1.2.2 网络模型  规则网络：最简单的网络模型为规则网络，它是指系统中各元素之间的关系可以用一些规则的结构表示，也就是说网络中任意两个节点之间的联系遵循既定的规则，通常每个节点的近邻数目都相同。常见的具有规则拓扑结构的网络包括全局耦合网络（也称为完全图）、最近邻耦合网络和星型耦合网络。
 随机网络：从某种意义上讲，规则网络和随机网络是两个极端，而复杂网络处于两者之间。节点不是按照确定的规则连线，如按纯粹的随机方式连线，所得的网络称为随机网络。如果节点按照某种自组织原则方式连线，将演化成各种不同网络。
 小世界网络：规则的最近邻耦合网络具有高聚类特性，但并不是小世界网络。另一方面，ER随机网络虽然具有小的平均路径长度但却没有高聚类特性。因此，这两类网络模型都不能再现真实网络的一些重要特征，毕竟大部分实际网络既不是完全规则的，也不是完全随机的。作为从完全规则网络向完全随机网络的过渡，Watts和Strogtz于1998年引入了一个小世界网络模型，称为WS小世界模型。
   BA网络: BA模型考虑到现实网络中节点的幂律分布特性，生成无标度网络。  2 网络节点中心性（Centrality） 2.1 度中心性（Degree centrality） 度中心性是在网络分析中刻画节点中心性的最直接度量指标，定义为一个节点的连边的数量数。一个节点的节点度越大就意味着这个节点的度中心性越高。
$$C_{D}(v)=\deg(v)$$
设想一下，你在微信上有个账号，那么是不是意味着微信好友数量越多，那么你的社交圈子越广？（假设都是真实好友，不考虑微商神马的奇葩情况）比如我有20个好友，那么意味着20个结点与我相连。如果你有50个好友，那么意味着你的点度中心度比我高，社交圈子比我广。这个就是点度中心性的概念。
2.2 接近中心性（Closeness centrality） 节点的接近中心性的定义为该节点到网络中其他节点的平均最短路径长度。换句话说就是该节点到其他节点越近则接近中心性越大。
$${\displaystyle C(x)={\frac {1}{\sum _{y}d(y,x)}}}$$
这个定义其实比Degree Centrality从几何上更符合中心度的概念，因为到其它节点的平均最短距离最小，意味着这个节点从几何角度看是出于图的中心位置。我们设想一个实际生活中的场景，比如你要建一个大型的娱乐商场，你可能会希望周围的顾客到达这个商场的距离都可以尽可能地短。
2.3 中介中心性 计算经过一个点的最短路径的数量。经过一个点的最短路径的数量越多，就说明它的中介中心度越高。
  C B  (v)= &amp;#x2211;  s&amp;#x2260;v&amp;#x2260;t&amp;#x2208;V      &amp;#x03C3;  st  (v)   &amp;#x03C3;  st       假设想知道的人是A。但是后来我们发现在这个26人的圈子里面，度中心性最高的人A，却不一定是活跃的，这里就需要用到中介中心度（betweenness centrality）来进行计算。很多节点之间的最短路径都经过C这个点，那么就说C有高的中介中心度。也就是说这个点处在其他点对相互之间的捷径上。
如果一个大的社交网络中包含了几个小组，那么中介中心度高的人就起到将这些小组连接起来的作用。比如在男生女生共同存在的网上学习网络中，比较常见的现象是女生之间互动紧密同时男生之间互动紧密，但是中介中心度高的学生将会打破这种男生女生小组织的边界，在网络中，将男生女生连接在一起，使之形成一个整体的大网络。
2.4 特征向量中心性 一个节点的重要性既取决于其邻居节点的数量（即该节点的度），也取决于其邻居节点的重要性,记 $x_t$ 为节点 $v_t$ 的重要性度量值，则：
  x v  = 1 &amp;#x03BB;   &amp;#x2211;  t&amp;#x2208;M(v)    x t   = 1 &amp;#x03BB;   &amp;#x2211;  t&amp;#x2208;G    a  v,t    x t    其中 $M(v)$ 是节点 $v$ 的邻居节点集合，而 $\lambda$ 是常数，这个公式经过多次迭代可以变换为：
$$\mathbf{Ax} = {\lambda}\mathbf{x}$$
Google的PageRank和Katz中心性也是特征向量中心性的变种。
2.4 Katz中心性 Katz中心性是度中心性的延伸。度中心性度量的是节点的直接邻居节点的数量，而Katz中心性度量了可以连接成为一条路径的所有节点的数量，而越远的节点的贡献度越低：
  x i  = &amp;#x2211;  k=1 &amp;#x221E;    &amp;#x2211;  j=1 N    &amp;#x03B1; k      ( A k  )  ji    其中，$\alpha$ 是一个(0,1)之间的衰减因子。
2.5 PageRank中心性 2.5.1 PageRank概述 PageRank，又称网页排名、谷歌左侧排名、PR，是Google公司所使用的对其搜索引擎搜索结果中的网页进行排名的一种算法。
佩奇排名本质上是一种以网页之间的超链接个数和质量作为主要因素粗略地分析网页的重要性的算法。其基本假设是：更重要的页面往往更多地被其他页面引用（或称其他页面中会更多地加入通向该页面的超链接）。其将从A页面到B页面的链接解释为“A页面给B页面投票”，并根据投票来源（甚至来源的来源，即链接到A页面的页面）和投票对象的等级来决定被投票页面的等级。简单的说，一个高等级的页面可以提升其他低等级的页面。
该算法以谷歌公司创始人之一的拉里·佩奇（Larry Page）的名字来命名。谷歌搜索引擎用它来分析网页的相关性和重要性，在搜索引擎优化中经常被用来作为评估网页优化的成效因素之一。
当前，佩奇排名算法不再是谷歌公司用来给网页进行排名的唯一算法，但它是最早的，也是最著名的算法。
2.5.2 PageRank实现 简化版本 假设一个由4个网页组成的集合：A，B，C和D。同一页面中多个指向相同的链接视为同一个链接，并且每个页面初始的PageRank值相同，最初的算法将每个网页的初始值设定为1。但是在后来的版本以及下面的示例中，为了满足概率值位于0到1之间的需要，我们假设这个值是0.25。
在每次迭代中，给定页面的PR值（PageRank值）将均分到该页面所链接的页面上。
如果所有页面都只链接至A，那么A的PR值将是B，C及D的PR值之和，即：
$$PR(A)=PR(B)&#43;PR&amp;copy;&#43;PR(D)$$
重新假设B链接到A和C，C链接到A，并且D链接到A,B,C。最初一个页面总共只有一票。所以B给A ,C每个页面半票。以此类推，D投出的票只有三分之一加到了A的PR值上：
$${\displaystyle PR(A)={\frac {PR(B)}{2}}&#43;{\frac {PR&amp;copy;}{1}}&#43;{\frac {PR(D)}{3}}}$$
换句话说，算法将根据每个页面连出总数 $L(x)$ 平分该页面的PR值，并将其加到其所指向的页面：
$$PR(A)={\frac {PR(B)}{L(B)}}&#43;{\frac {PR&amp;copy;}{L&amp;copy;}}&#43;{\frac {PR(D)}{L(D)}}$$
最后，所有这些PR值被换算成百分比形式再乘上一个修正系数 $d$。由于“没有向外链接的网页”传递出去的PR值会是0，而这会递归地导致指向它的页面的PR值的计算结果同样为零，所以赋给每个页面一个最小值
$$PR(A)=\left({\frac {PR(B)}{L(B)}}&#43;{\frac {PR&amp;copy;}{L&amp;copy;}}&#43;{\frac {PR(D)}{L(D)}}&#43;\,\cdots \right)d&#43;{\frac {1-d}{N}}$$
需要注意的是，在Sergey Brin和Lawrence Page的1998年原版论文中给每一个页面设定的最小值是 $1-d$ ，而不是这里的 $(1-d)/N$ ，这将导致集合中所有网页的PR值之和为N（N为集合中网页的数目）而非所期待的1。 因此，一个页面的PR值直接取决于指向它的的页面。如果在最初给每个网页一个随机且非零的PR值，经过重复计算，这些页面的PR值会趋向于某个定值，也就是处于收敛的状态，即最终结果。这就是搜索引擎使用该算法的原因。
2.6 各个中心性指标的联系和区别 其实在现实世界的不同网络结构中，不同定义的中心性指标的着重点不同，所以在实际的网络中各个节点的不同中心性指标可能差异很大，因该结合自身需求来寻找网络中中心性大的节点。
参考文献： wiki：网络中心性指标
3 网络可视化与分析工具 在这里向大家推荐几个比较常用的工具，对于单层网络一个是Python的NetworkX库，一个是Gephi软件，而对于多层网络而言，推荐使用MuxViz软件进行可视化分析。
 NetworkX  这是一款Python的软件包，用于创造、操作复杂网络，以及学习复杂网络的结构、动力学及其功能。 有了NetworkX你就可以用标准或者不标准的数据格式加载或者存储网络，它可以产生许多种类的随机网络或经典网络，也可以分析网络结构，建立网络模型，设计新的网络算法，绘制网络等等。可以查看官方文档
 Gephi  gephi是一款网络信息数据可视化利器，主要用于各种网络和复杂系统，动态和分层图的交互可视化。gephi的强大在于有丰富的可视化插件，足够满足你的分析需求。
Gephi 的优势在于操作简便，而且出图的效果真的非常好，还有很多的插件可以使用，可以说是做可视化分析、和后期出图的利器。
 Visualcomplexity  一个很好的网络可视化网站，涉及因特网、生物网络、社会网络、交通网络等十余个大类，最关键的是，每一张图都给出了背景项目的简介和链接。
 MuxViz  一个用R语言搭建的很好的多层网络可视化分析工具
4 社团结构 社团检测（Community Detection，又译作社区发现）是一种在网络中找出关系密切的结点的集合（社团）的技术。随着当今互联网尤其是社交网络的发展，这一研究领域也越来越被人们所重视。目前已经有多种用于进行社团检测的方法，而随着大数据时代网络规模的急剧增大，社团检测领域的发展也迎来了新的挑战和机遇。
4.1 网络中的社团结构 以我们最熟悉的网络——互联网为例，我们所上的每一个网站里，都会有链接向其他网页的链接。这种相互链接的关系也构成了一张网络。只不过因为互联网上的网站数目众多，而链接关系又十分复杂，所以其规模自然是极为庞大的。
上面已经说明了，网络可以用一个图来表示，其中顶点与顶点之间的连线即代表了它们之间的关系。那么，在这样的一个关系网中，社团又指的是什么呢？首先先下一个定义：社团（Community，又译作社区）反映的是网络中的个体行为的局部性特征以及其相互之间的关联关系。社团内的连接紧密，而社团间的连接稀疏。可能比较抽象？我们来举个例子：
我们交了朋友或者与人进行合作后，肯定得要保持联系。那么要用什么方法来保持这种联系呢？没错，大家很可能马上就会想到，可以用QQ啊！什么？你说合作者或朋友不只一个？那也好办，建Q群呗！于是，一些有着共同兴趣爱好或是目的的人就被聚集在了一起。
说到这里，大家可能已经明白了：这里的Q群就相当于一个社团，是社交网络中一部分人（顶点）的集合。在这样的一个社团里，其中的成员（群员）就可以进行更加密切的交流，或是会互加一波好友，因为他们有着共同的目标或话题。这样一来，我们就可以说这个Q群之中的人的相互关系更加紧密了。而实际上，在一个网络中的社团里，用来定义一个顶点是否在某个社团之中的方法，其实就是看它与该社团中的其他顶点的关联是否密切。或者说，正是这一簇互相关联紧密的顶点，才构造出了网络中的一个社团。
4.2 什么是社团检测 说完了社团，我们重新来看回社团检测。顾名思义，社团检测就是要在一个网络中找到这些社团，即一批关联紧密的顶点。那么要怎么找呢？其实主要的问题就出现在这个“关联紧密”上，要怎样才能说得上是紧密呢？这里我们先从上面的图下手，总结一些直观规律出来：
可以发现该社团中的每个顶点与社团内的连接都比较紧密；而相比之下，处于该社团外部的顶点就没有这么多与社团中顶点相连的边。注意到该图中有一些点是与社团中的顶点相连的，但却没有被划分到社团之中。事实上，社团的性质中就有这么一条：社团之中的成员顶点的相互关系比社团成员与非社团成员之间的关系要更加密切。还是拿Q群来比喻的话，那就是指在同一个群里的志同道合的人更有可能跟你加好友，而群外的人虽然也会有好友关系，却没有那么多。
那么，直观印象已经有了。社团检测的目的，就在于通过这些局部的密切关系，来判断网络中的顶点是否属于同一个社团中，以及有多少个这样的“密集区域”。显然，社团检测的重点在于判断“是否密切”，而对于不同领域和不同的检测算法，这一判别指标也会不尽相同。
4.3 社团检测有什么用 有人可能会问，找到这些社团有什么用呢？我们在QQ里加入Q群的时候，不是已经知道自己处于什么社团之中了吗？其实不然，因为你只知道你自己处于什么社团之中，却不知道他人的情况；而事实上，其他人可能离你的“距离”比你想象中的要近很多。什么意思呢？再度用Q群来形容的话，可以说得上是“与你同在一个群却没有和你加好友”的人吧。你们有着共同的爱好或目标，可以说是很容易就成为朋友了，但你们却又彼此不认识，怎么办？诶，这就是QQ对社团检测这一技术的现成运用了：好友推荐。
想必很多人都有着这种经历：打开QQ，猛然发现好友列表那里出现了一个红圈①，而正当我们嘀咕着是谁来加好友，打开“新朋友”列表一看，却发现是一个“好友推荐”的信息。上面写着“XXX，跟你有Y名共同好友”。这句话虽然看起来简单，但其实已经是大有文章了。还记得我们上面说的社团的定义是什么吗？没错，网络图中一批相互关系密切的顶点。那么，共同好友多，显然算是评判关系密切的一种重要指标吧。这个看似不起眼的好友推荐系统，其实已经蕴含着社团检测的核心思想了。
从上面的例子不难看出，社团检测的一个重要的应用就是这种社交网络中的推荐系统。通过检测与你关系密切的人的情况，来找出你可能会感兴趣的人或群组。在实际的运用中，判别信息可绝不仅仅是“有多少名共同好友”那么简单了，社交网络还会通过各种其他信息来帮助用户们“搭桥牵线”。比如，通过分析用户的住址，来寻找住在同一小区内的人，构成一个“某某小区社团”，这样就可以方便人们认识自己的邻居；又或者，视频网站可以根据用户看的视频类型，找到跟他们有着同样喜好的用户，毕竟有了共同话题，交流起来也更容易不是吗？
除了“找朋友”外，社团检测还可以“抓坏人”。有句话叫“物以类聚，人以群分”，如果警察发现某个人与一些已知的坏人关系密切，那么他即使没有参与违法行动，也有很多概率知道这些坏人们的一些信息。这样一来，抓捕犯人就有了线索；此外，医疗机构也可以通过调查已经感染某种传染病的人与其他人的关系，找出有可能受到传染病影响的潜在患者，以便尽早让他们脱离危险。显然，与多名传染病患者关系密切的人最有可能成为此类。可以看到，社团检测对于社会关系这张巨大的网络有着很大的作用，如果能够实施好这项技术，就可以防患于未然，解决很多潜在的问题。
那么，在社交网络以外的网络，社团检测又有什么用呢？以我们刚才所说的蛋白质相互关系网络为例，我们可以将参加同一类生命活动的蛋白质定义为一个社团，以此来分析某些特定蛋白质的作用（看它们出现在哪些社团之中），甚至是以此为基础来预测新型蛋白质的作用；而在互联网上，社团检测的应用领域也非常广泛。例如搜索引擎，可以对用户搜索的关键词进行社团检测，找出其中的“热门领域”，进而增加这方面信息的检索。可以说，社团检测技术提供了一把钥匙，让我们在面对各种实际问题之时可以打开一条“便捷通道”。
4.4 社团检测面临的问题 4.4.1 网络规模的膨胀 随着现在大数据时代下的数据量越来越大，网络的规模也在不断膨胀。随着网络尺度的增大，网络的维数也开始急剧膨胀。所谓维数，就是指一个顶点所具有的属性。例如，如果要搞一个社交网络，可以采用的属性有用户的兴趣爱好、地点和职业等。而现在，这样的属性页变得越来越多。
除了规模增大本身带来的影响以外，还有一个影响在于网络的变化速度也越来越快。还是以社交网络为例，每一天都会有大量新用户注册，并且会有新的好友关系、群组等。网络的数据量增大以及频繁变化，都迫使社团检测算法必须要快速做出应对，即要求其有着更快的计算速度。
4.4.2 重叠社团 什么是重叠社团呢？和之前一样，我们用Q群来作为例子。其实道理很简单：人们用QQ时会只加入一个Q群吗？想必绝大部分人的答案肯定是不会，而是有着多于一个Q群。那么，就可以说你同时属于两个Q群所对应的社团中。而同一种蛋白质也有可能会对多种生命活动产生影响。这样一来，不同的社团就会在这个特定的顶点这里“重叠”了。
事实上，重叠社团可不仅仅是一个点重叠这么简单。在实际情况下，往往有多个这样的结点，也就是网络中的一部分子图会处在这个重叠区域之中。根据重叠部分的顶点数量以及与其他顶点的联系，我们可以判断其重叠的稠密程度，并用图像来表示这些社团之间的重叠情况。
4.5 社团检测方法 上面已经说明了社团检测的定义、难点以及应用价值，目前社团检测的方法非常多，主要研究方向如下图所示，接下来只会介绍一些比较知名的社团检测方法。
4.5.1 Infomap Infomap是一种基于信息量的社团检测方法。你问我什么是信息量？简单来说，就是一件事情能够提供的信息的多少。这个要怎么衡量呢？还是来看一个直观例子：如果抛一枚质量均匀的硬币，那么出现正反面的概率各占50%，这意味着“知道抛这枚硬币的结果是正面”给我们所带来的信息与“知道抛这枚硬币的结果是反面”所带来的信息价值相等；现在我们对这枚硬币做些手脚，让它有着更大的可能性出现正面。这样一来，“知道抛这枚硬币的结果是正面”给我们所带来的信息就会增加吗？不，刚好相反，你已经知道了这枚硬币有更大的可能性出现正面，那知道单次为正所获得的信息不就变少了吗？相对应的，在这种正面占主导的情况下，如果出现一次反面，那么它所带来的信息就会增加，因为这是人们“难以预料到的”。通过上面这个例子，我们可以先给信息量一个粗略的结论：一个事件能够给出的信息多少有其发生概率决定，发生的概率越小获得的信息就越多。
知道了这个之后，我们接下来回到Infomap上。它使用随机游走作为网络上信息传播的代理，网络上的随机游走会产生相应的数据流。随机游走产生的信息量使用平均一步随机游走产生的码字长度衡量，即平均码字长度。[5]随机游走顾名思义，就是每一次随机到一个与当前结点相连的结点上，如此反复。那么信息量在这里有什么用呢？回想一下，社团中的结点是不是更容易互相连接？那么这样一来，它们在随机过程中被选中的概率自然就会增大。如此一来，我们就可以用信息量来作为判定社团的依据。该算法思路较为创新，效果也比较好，而且该算法的改进型也可用于重叠社团检测。
4.5.2 Clique算法 除了信息量以外，还有很多别的方式来区分网络中的社团，其中一种方法就是网格。简单来说，就是用大小、形状相同的格子来划分整个网络，然后看哪些格子里面的结点数量更多。显然，结点数量越多的网格，其存在社团的可能性也就越高。对应一个网格，Clique算法会首先判断其是不是密集网格，如果是密集网格。那么对其相邻的网格进行遍历，看是否是密集网格，如果是的话，那么属于同一个簇。该方法可以划分出重叠的社团，但对于高维数据，基于网格的聚类倾向于效果很差。
4.5.2 社团检测结果评估指标  模块度(Modularity)：通过比较现有网络与基准网络在相同社区划分下的连接密度差来衡量网络社区的优劣。 NMI (Normalized Mutual Information)：利用信息熵来衡量预测社区结构一直社区结构的差异，该值越大，则说明社区结构划分越好，最大值为1时，说明算法划分出的社区结构和一直社区结构一致，算法效果最好。 Rand Index：表示在两个划分中都属于同一社区或者都属于不同社区的节点对的数量的比值。 Jaccard Index：Jaccard 系数用来衡量样本之间的差异性，是经典的衡量指标。  参考文献： * 科普论文：漫谈社团检测 * 一文读懂社交网络分析：学术研究、应用、前沿与学习资源
3 网络传播动力学 3.1 传染病传播模型 传染病的基本数学模型，研究传染病的传播速度、空间范围、传播途径、动力学机理等问题，以指导对传染病的有效地预防和控制。常见的传染病模型按照传染病类型分为 SI、SIR、SIRS、SEIR 模型等，按照传播机理又分为基于常微分方程、偏微分方程、网络动力学的不同类型。
一般把传染病流行范围内的人群分成如下几类： 1、S 类，易感者 (Susceptible)，指未得病者，但缺乏免疫能力，与感染者接触后容易受到感染； 2、E 类，暴露者 (Exposed)，指接触过感染者，但暂无能力传染给其他人的人，对潜伏期长的传染病适用； 3、I 类，感病者 (Infectious)，指染上传染病的人，可以传播给 S 类成员，将其变为 E 类或 I 类成员； 4、R 类，康复者 (Recovered)，指被隔离或因病愈而具有免疫力的人。如免疫期有限，R 类成员可以重新变为 S 类。
SIR 模型： SI 模型只考虑了传染病爆发和传播的过程。SIR模型进一步考虑了病人的康复过程。模型的微分方程为：
    dS  dt  =&amp;#x2212;  &amp;#x03B2;IS N  ,       dI  dt  =  &amp;#x03B2;IS N  &amp;#x2212;&amp;#x03B3;I,       dR  dt  =&amp;#x03B3;I     这里 $\beta$ 为传染率, $\gamma$ 为康复概率。总人数 S(t) &#43; I(t) &#43; R(t) = 常数。这里假设病人康复后就获得了永久免疫，因而可以移出系统。对于致死性的传染病，死亡的病人也可以归入 R 类。因此 SIR 模型只有两个独立的动力学变量 I 和 S。
3.2 节点影响力评估（关键节点挖掘）、传播影响力最大化 随着各种在线社交平台的发展，社交平台（比如QQ、微博、朋友圈等）已经不仅仅是一种用户进行沟通的社交平台，它们更是社会信息产生和传播的一种主要的媒介。影响最大化（Influence Maximization）同结构平衡一样，也是针对社会网络的研究而被提出的，它来源于经济学的市场营销。2001年，影响最大化被Domins首次以一种算法问题的形式被提出。而影响最大化受到广泛的关注是在2003年Kempe等人在当年的KDD会议上发表的一篇有关影响最大化的论文之后，随后各种影响最大化算法被迅速提出，最近的十几年里，影响最大化的相关文章达到了上千篇，可见这个问题还是很值得关注的。
影响最大化问题可以这样来描述：一个商家或者企业利用一种社交平台（比如为新浪微博）为自己的新产品或者新服务进行推广，如何在资金有限的情况下雇佣微博达人来做推广可以使得推广范围达到最大？
我们再给出影响最大化的一般定义：
给定一个网络G和一个整数K（一般小于50），如何在G中找出K个节点，使得这K的节点组成的节点集合S的影响传播范围σ(S)达到最大。
根据上述影响最大化的定义我们很容易可以知道，影响最大化本身属于一种组合优化问题。常用的影响最大化传播模型有独立级联传播模型（ICM）和线性阈值传播模型（LTM）。
影响最大化方面的主要算法可以分为如下几类：
（1）基于网络中心性的启发式方法：比如最大度方法、最短平均距离方法、PageRank方法等；
（2）基于子模块性的贪婪方法：比如最经典的Greedy算法，CELF算法以及后来的NewGreedy和CELF&#43;&#43;等；
（3）基于社区结构的方法：比如CGA算法、CIM算法等；
（4）基于目标函数优化的方法：比如模拟退火算法等。
粉丝最多的不一定传播能力最强，比如存在大量的僵尸粉，如果用复杂网络的手段，可以评估粉丝或邻居的社交影响力来对其进行综合评估
宣传推广策略：例如我们会想到结合信息本身的特点，去找网络上的某些具有特殊性质的节点（例如「大 V 」），利用网络特定的拓扑结构（如社区性质）来进行传播，再结合上用户的行为的特征（例如用户们的活跃时间），我们还可以对网络动力学（如信息传播）进行简单的预测。
4 链路预测 5 深度学习与图网络 5.1 图嵌入（网络表示学习） Graph广泛存在于真实世界的多种场景中，即节点和边的集合。比如社交网络中人与人之间的联系，生物中蛋白质相互作用以及通信网络中的IP地址之间的通信等等。除此之外，我们最常见的一张图片、一个句子也可以抽象地看做是一个图模型的结构，图结构可以说是无处不在。
对于Graph的研究可以解决下面的一些问题：比如社交网络中新的关系的预测，在QQ上看到的推荐的可能认识的人；生物分子中蛋白质功能、相互作用的预测；通信网络中，异常事件的预测和监控以及网络流量的预测。如果要解决以上的问题，我们首先需要做的是对图进行表示，graph embedding 是中非常有效的技术。
5.1.1 什么是图嵌入？ 图嵌入是一种将图数据（通常为高维稠密的矩阵）映射为低微稠密向量的过程，能够很好地解决图数据难以高效输入机器学习算法的问题。图嵌入需要捕捉到图的拓扑结构，顶点与顶点的关系，以及其他的信息，如子图，连边等。如果有更多的信息被表示出来，那么下游的任务将会获得更好的表现。嵌入的过程中有一种共识：向量空间中保持连接的节点彼此靠近。基于此，研究者提出了拉普拉斯特征映射（Laplacian Eigenmaps）和局部线性嵌入（Locally Linear Embedding ，LLE）。
总的来说大致可以将图上的嵌入分为两种：节点嵌入和图嵌入。当需要对节点进行分类，节点相似度预测，节点分布可视化，一般采用节点的嵌入；当需要在图级别上进行预测或者预测整个图结构，我们需要将整个图表示为一个向量。
 后面将会介绍一下经典的方法如DeepWalk, node2vec和LINE
 5.1.2 为什么要进行图嵌入Graph embedding? 图是数据的有意义且易于理解的表示形式，但是出于下面的原因需要对图进行嵌入表示。
 在graph直接进行机器学习具有一定的局限性，我们都知道图是由节点和边构成的，这些向量关系一般只能使用数学，统计或者特定的子集进行表示，但是嵌入之后的向量空间具有更加灵活和丰富的计算方式；
 图嵌入能够压缩数据， 我们一般用邻接矩阵描述图中节点之间的连接。连接矩阵的维度是|V| x |V|，其中|V| 是图中节点的个数。矩阵中的每一列和每一行都代表一个节点。矩阵中的非零值表示两个节点已连接。将邻接矩阵用用大型图的特征空间几乎是不可能的。一个具有1M个节点和1Mx1M的邻接矩阵的图该怎么计算和表示呢？但是嵌入可以看做是一种压缩技术，能够起到降维的作用；
 向量计算比直接在图上操作更加的简单、快捷。
  但是图嵌入也需要满足一定的需求
 属性选择：确保嵌入能够很好地描述图的属性。它们需要表示图拓扑，节点连接和节点邻域。预测或可视化的性能取决于嵌入的质量；
 可扩展性：大多数真实网络都很大，包含大量节点和边。嵌入方法应具有可扩展性，能够处理大型图。定义一个可扩展的模型具有挑战性，尤其是当该模型旨在保持网络的全局属性时。网络的大小不应降低嵌入过程的速度。一个好的嵌入方法不仅在小图上高效嵌入，同时也需要在大图上能够高效地嵌入；
 嵌入的维度：实际嵌入时很难找到表示的最佳维数，维度越大能够保留的信息越多，但是通常有更高的时间和空间复杂度。较低的维度虽然时间、空间复杂度低，但无疑会损失很多图中原有的信息。
  5.1.3 图嵌入方法 节点的嵌入借鉴了word2vec的方法，该方法能够成立的原因是：图中的节点和语料库中的单词的分布都遵循幂定律。
在介绍图嵌入的方法之前首先简单回顾一下在文本领域的Word2Vec和skip-gram模型，如果比较熟悉，可以直接跳过。
Word2vec是一种将单词转换为嵌入向量的嵌入方法。相似的词应具有相似的嵌入。Word2vec使用skip-gram网络，这是具有一层隐藏层的神经网络（总共三层）。skip-gram模型是给出某一词语来预测上下文相邻的单词。下图显示了输入单词（标有绿色）和预测单词的示例。通过此任务，作者实现了两个相似的词具有相似的嵌入，因为具有相似含义的两个词可能具有相似的邻域词。
下图是skip-gram模型。网络的输入为one-hot编码，长度与单词字典的长度相同，只有一个位置为1，输出为单词的嵌入表示：
下面介绍三个节点嵌入（node embedding）的方法，这些方法都类似Word2vec的嵌入原理。
5.1.4 Deepwalk 深度游走算法是近年来第一个有影响力的大规模网络表达学习算法，它的本质是将随机游走（Random Walk）和自然语言处理中的skip-gram算法作组合所产生的算法。
随机游走（Random Walk）
随机游走是一个非常基础的基于网络的算法。它的本质就是从一个节点出发，随机选择它的一个邻接点，再从这个邻接点出发到下一个节点，重复这个步骤然后记录下所经过的所有节点。这个算法的变种在Google搜索和金融领域应用广泛。通过随机游走我们可以得到从每个节点出发的一条路径，这条路径就代表了这个节点的结构信息。
深度游走算法
深度游走的核心思想总结成一句话就是，短的随机游走路径=句子（short random walk = sentence，quoted from Bryan Perozzi），因此我们只需要设定一个随机游走的步数r，通过随机游走我们就可以得到一个长度为r的路径（节点集），此时我们将其中每一个节点都看成单词，每个节点也都有对应的one-hot编码，这样就可以直接用skip-gram模型学出节点的表达。
由于网络的节点数目可能达到百万甚至千万级，节点的one-hot编码会过于稀疏，不同于传统的skip-gram模型直接用softmax函数得到输出，deepwalk采用的是层级softmax方法，每个节点对应一个完全二叉树的叶子节点，根节点输入的是我们目标节点的表达，此时就变成一个二分类问题，我们只需要判断二叉树的左右子树就可以学出节点的表达。
算法中有一个参数r，是随机游走的步长，即需要限定随机游走的长度，不要过长，有几个好处，1）可以捕获网络中局部区域的结构信息；2）易于实现并行化，多个线程，进程，甚至服务器，可以同时随机游走网络的不同部分，实现分布式计算，这个后边还会再提一下；3）能够适应网络的变化，网络局部发生变化时，可以只对局部网络进行学习和训练，而不需要对整个网络重新学习。
DeepWalk通过随机游走去可以获图中点的局部上下文信息，因此学到的表示向量反映的是该点在图中的局部结构，两个点在图中共有的邻近点（或者高阶邻近点）越多，则对应的两个向量之间的距离就越短。但是DeepWalk方法随机执行随机游走，这意味着嵌入不能很好地保留节点的局部关系，Node2vec方法可以解决此问题。
5.1.5 Node2vec Node2vec是DeepWalk的改进版，Node2Vec认为，现有的方法无法很好的保留网络的结构信息，例如下图所示，有一些点之间的连接非常紧密(比如u, s1, s2, s3, s4)，他们之间就组成了一个社区(community)。网络中可能存在着各种各样的社区，而有的结点在社区中可能又扮演着相似的角色(比如u与s6)。Node2Vec的优化目标为以下两个：让同一个社区内的结点表示能够相互接近，或在不同社区内扮演相似角色的结点表示也要相互接近。
为此，Node2Vec就要在DeepWalk现有的基础上，对随机游走的策略进行优化。Node2Vec提出了两种游走策略：
 广度优先策略 深度优先策略  就如上图的标注所示，深度优先游走策略将会限制游走序列中出现重复的结点，防止游走掉头，促进游走向更远的地方进行。而广度优先游走策略相反将会促进游走不断的回头，去访问上一步结点的其他邻居结点。
这样一来，当使用广度优先策略时，游走将会在一个社区内长时间停留，使得一个社区内的结点互相成为context，这也就达到了第一条优化目标。相反，当使用深度优先的策略的时候，游走很难在同一个社区内停留，也就达到了第二条优化目标。
那么如何达到这样的两种随机游走策略呢，这里需要用到两个超参数p和q用来控制深度优先策略和广度优先策略的比重，如下图所示。
假设现在游走序列从t走到v，这时候需要算出三个系数，分别作为控制下一步走向方向的偏置α
其中d(t, x)代表t结点到下一步结点x的最短路，最多为2。
 当d(t, x)=0时，表示下一步游走是回到上一步的结点； 当d(t, x)=1时，表示下一步游走跳向t的另外一个邻居结点； 当d(t, x)=2时，表示下一步游走向更远的结点移动。  而Node2Vec同时还考虑了边权w的影响，所以最终的偏置系数以及游走策略为：
这样一来，就可以看出，超参数p控制的是重新访问原来结点的概率，也就是保守探索系数，而超参数q控制的是游走向更远方向的概率，也就是激进探索系数。如果q较大，那么游走策略则更偏向于广度优先策略，若q较小，则偏向于深度优先策略。
该算法引入了参数P和Q，参数Q关注随机游走中未发现部分的可能性，即控制着游走是向外还是向内: 若Q&amp;gt;1，随机游走倾向于访问接近的顶点(偏向BFS); 若Q&amp;lt;1，倾向于访问远离的顶点(偏向DFS)。
参数P控制了随机游走返回到前一个节点的概率。也就是说，参数P控制节点局部关系的表示，参数Q控制较大邻域的关系。
5.1.6 LINE LINE不再采用随机游走的方法。相反，他在图上定义了两种相似度——一阶相似度与二阶相似度。
 一阶相似度：一阶相似度就是要保证低维的嵌入中要保留两个结点之间的直接联系的紧密程度，换句话说就是保留结点之间的边权，若两个结点之间不存在边，那么他们之间的一阶相似度为0。例如下图中的6、7两个结点就拥有很高的一阶相似度。
 二阶相似度：二阶相似度用一句俗话来概括就是“我朋友的朋友也可能是我的朋友”。他所比较的是两个结点邻居的相似程度。若两个结点拥有相同的邻居，他们也更加的相似。如果将邻居看作context，那么两个二阶相似度高的结点之间拥有相似的context。这一点与DeepWalk的目标一致。例如下图中的5、6两点拥有很高的二阶相似度。
  最终要获得同时包含有一阶相似度和二阶相似度的embedding，只需要将通过一阶相似度获得的embedding与通过二阶相似度获得的embedding拼接即可。
参考文献：
 总结|为什么要进行图嵌入Graph embedding?
 图系列|图网络学习从入门到进阶：系列相关优质文章与资料汇总
  5 知识图谱 6 网络挖掘的其他研究领域 6.1 其他相关研究领域 6.2 网络挖掘相关资料和大牛</content>
    </entry>
    
     <entry>
        <title>Python之Matplotlib绘图基础</title>
        <url>http://jchenTech.github.io/post/python/python%E4%B9%8Bmatplotlib%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
        <categories>
          <category>Python</category>
        </categories>
        <tags>
          <tag>Python</tag><tag>Matplotlib</tag>
        </tags>
        <content type="html"> Python十分适合用来进行数据分析，因为它有“四板斧”，分别是Matplotlib、NumPy、SciPy/Pandas。Matplotlib是画图工具，NumPy是矩阵运算库，SciPy是数学运算工具，Pandas是数据处理的工具。本篇文章将介绍python的绘图工具Matplotlib，它是一个风格类似Matlab的基于Python的绘图库。它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。
matplotlib是一个python 2D绘图库，利用它可以画出许多高质量的图像。只需几行代码即可生成直方图，条形图，饼图，散点图等。
Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包。希望本文能帮助大家了解如何将matplotlib用于自己的可视化。
Matplotlib，pyplot和pylab？ Matplotlib是整个包，pyplot是Matplotlib中的一个模块，并且pylab是一个安装在一起的模块。
pylab和pyplot的区别是，前者将numpy导入了其命名空间中，这样会使pylab表现的和matlab更加相似。现在来说我们经常使用pyplot，因为pyplot相比pylab更加纯粹。
numpy，pandas？ matplotlib是可视化的表达，那么在图形的绘制中肯定会涉及一些数据处理。pandas和numpy则是python中最好用的两个数据分析库，使用它们，能够解决超过90%的数据分析问题。
matplotlib 绘图上手 安装Matplotlib python -m pip install matplotlib 然后打开Jupyter Notebook（安装好 Anaconda 后，Jupyter 也已装好，在应用窗口中可以找到），我们就可以直接上手了。
图的构成 以上图片来自matplotlib官网，它向我们展示了matplotlib的图的构成元素。
大多数元素都比较好理解：
坐标轴(axis)、坐标轴名称(axis label)、坐标轴刻度(tick)、坐标轴刻度标签(tick label)、网格线(grid)、图例(legend)、标题(title)&amp;hellip;&amp;hellip;
title设置 import matplotlib.pyplot as plt plt.title(&amp;#34;title&amp;#34;)#括号当中输入标题的名称 plt.show() 如果title是中文，matplotlib会乱码，这时需要加上下面这段代码：
plt.rcParams[&amp;#39;font.sans-serif&amp;#39;]=[&amp;#39;SimHei&amp;#39;] Figure对象 在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个或者多个Axes对象。每个Axes(ax)对象都是一个拥有自己坐标系统的绘图区域。
plt.figure(figsize=(6, 3)) plt.plot(6, 3) plt.plot(3, 3 * 2) plt.show() 坐标轴及标签 plt.xlim(0,6) #x轴坐标轴 plt.ylim((0, 3))#y轴坐标轴 plt.xlabel(&amp;#39;X&amp;#39;)#x轴标签 plt.ylabel(&amp;#39;Y&amp;#39;)#y轴标签 plt.show() 如果需要将数字设为负数，也可能出现乱码的情况，这时候可以加下面的代码：
plt.rcParams[&amp;#39;axes.unicode_minus&amp;#39;]=False 设置label和legend 设置 label 和 legend 的目的就是为了区分出每个数据对应的图形名称,legend的loc参数用于设置图例位置。
plt.plot(2, 3, label=&amp;#34;123&amp;#34;)#第一个label plt.plot(2, 3* 2, label=&amp;#34;456&amp;#34;)#第二个label plt.legend(loc=&amp;#39;best&amp;#39;)#图列位置，可选best，center等 plt.show() 添加注释 有时候我们需要对特定的点进行标注，我们可以使用 plt.annotate 函数来实现:
s: 注释信息内容
xy:箭头点所在的坐标位置
xytext:注释内容的坐标位置
arrowprops：设置指向箭头的参数
x=np.linspace(0,10,200)#从0到10之间等距产生200个值 y=np.sin(x) plt.plot(x,y,linestyle=&amp;#39;:&amp;#39;,color=&amp;#39;b&amp;#39;) plt.annotate(s=&amp;#39;标记点&amp;#39;,xy=(3,np.sin(3)),xytext=(4,-0.5),weight=&amp;#39;bold&amp;#39;,color=&amp;#39;b&amp;#39;,\arrowprops=dict(arrowstyle=&amp;#39;-|&amp;gt;&amp;#39;,color=&amp;#39;k&amp;#39;)) plt.show() 使用子图 如果需要将多张子图展示在一起，可以使用 subplot() 实现。即在调用 plot()函数之前需要先调用 subplot() 函数。该函数的第一个参数代表子图的总行数，第二个参数代表子图的总列数，第三个参数代表活跃区域。
ax1 = plt.subplot(2, 2, 1) plt.plot(x,np.sin(x), &amp;#39;k&amp;#39;) ax2 = plt.subplot(2, 2, 2, sharey=ax1) # 与 ax1 共享y轴 plt.plot(x, np.cos(x), &amp;#39;g&amp;#39;) ax3 = plt.subplot(2, 2, 3) plt.plot(x,x, &amp;#39;r&amp;#39;) ax4 = plt.subplot(2, 2, 4, sharey=ax3) # 与 ax3 共享y轴 plt.plot(x, 2*x, &amp;#39;y&amp;#39;) matplotlib绘图 matplotlib画图可以总结为3个步骤：获取数据——画出基本图形——设置细节。获取的数据一般包括横坐标和纵坐标的数据，这个数据可以是读取的，也可以自己生成，本文为了方便演示，使用numpy和pandas生成随机数。
matplotlib所提供的图形非常丰富，除了基本的柱状图、饼图、散点图等，还提供了极坐标图、3D图等高级图形，并且你可以自由选择和组合。每个图形函数下都有许多参数可设置，matplotlib提供的不仅仅是图形，还有更为精细的图像表达，你可以通过细节的设置来丰富你的可视化。
bar 柱状图 生成一个单系列的柱状图比较简单，只要确定x轴及y轴的数据，利用bar（）函数就能生成：
x = np.arange(10) y = np.random.randint(0,20,10) plt.bar(x, y) plt.show() 除了单系列柱状图，matplotlib还提供了其它类型的柱状图，如多系列柱状图，堆叠图，水平向的条纹图等。plt.plot()适用于基本图表的绘制，kind可选类型有线形图、柱状图、密度图、堆叠图、面积图等，以横纵坐标两个维度为主。grid是显示网格，colormap是颜色展示，括号中可填颜色参数，如不填则会展示默认颜色。
# 多系列柱状图 df = pd.DataFrame(np.random.rand(10, 3), columns = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]) df.plot(kind = &amp;#39;bar&amp;#39;， grid = True, colormap = &amp;#39;summer_r&amp;#39;) 想要实现堆叠效果，一定要加上stacked=true，否则输出图形就是一般的柱状图。
# 多系列堆叠图 df.plot(kind = &amp;#39;bar&amp;#39;, grid = True, colormap = &amp;#39;Blues_r&amp;#39;, stacked = True) 水平向的条形图调用的是barh（）:
# 水平向 df.plot.barh( grid = True, colormap = &amp;#39;BuGn_r&amp;#39;) 与垂直柱状图一样，如果想要柱状图实现堆叠效果，则加上：stacked=true
scatter 散点图 绘制散点图，主要用到plt.scatter（）这个函数。
x,y是必填参数；
c(颜色：b&amp;ndash;blue, c&amp;ndash;cyan,g&amp;ndash;green,k&amp;ndash;black,m&amp;ndash;magenta,r&amp;ndash;red,w&amp;ndash;white,y&amp;ndash;yellow)；
s：控制点的大小，默认为20)；
marker：指定散点图点的形状，默认为圆形；
alpha：指定对象的透明度；
&amp;hellip;&amp;hellip;
绘制简单的散点图：
x = np.random.rand(10) y = np.random.rand(10) plt.scatter(x,y) plt.show() 进行简单的一些参数设置：
x = np.random.rand(50) y = np.random.rand(50) colors = np.random.rand(50) s = (30 * np.random.rand(n))**2 plt.scatter(x, y,s, c=colors, alpha=0.5) plt.show() 散点矩阵图scatter_matrix，diagonal = &amp;ldquo;为每个指标的频率图，有kde及hist两个参数可选；range_padding 是图像在x轴，y轴原点附近的留白，值越大，图像离坐标原点的距离越大。
df = pd.DataFrame(np.random.randn(100, 4), columns = list(&amp;#39;abcd&amp;#39;)) pd.scatter_matrix(df, figsize = (8,6),marker = &amp;#39;o&amp;#39;,diagonal = &amp;#39;kde&amp;#39;,alpha = 0.4,range_padding = 0.05) pie 饼图 matplotlib中饼图的实现用的是pie（）函数，必须输入的参数是饼图每个部分的值。 x = np.random.randint(1, 10, 3) plt.pie(x) plt.show() 部分参数解释:
使用labels为饼图加标签；
autopct 控制饼图内百分比设置
&amp;rsquo;%1.1f&amp;rsquo;指小数点前后位数(没有用空格补齐)，
shadow是在饼图下画一个阴影，False即不画
sizes = [2,5,12] labels = [&amp;#39;娱乐&amp;#39;,&amp;#39;育儿&amp;#39;,&amp;#39;饮食&amp;#39;] plt.pie(sizes,labels=labels,autopct=&amp;#39;%1.1f%%&amp;#39;,shadow=False,startangle=100) plt.show() hist 直方图 直方图绘制为hist（）函数，参数如下：
data:必选参数，绘图数据
bins:直方图的长条形数目，可选项，默认为10
normed:是否将得到的直方图向量归一化，可选项，默认为0，代表不归一化，显示频数。normed=1，表示归一化，显示频率。
facecolor:长条形的颜色
edgecolor:长条形边框的颜色
alpha:透明度
&amp;hellip;&amp;hellip;
s = pd.Series(np.random.randn(1000)) s.hist(bins = 20,histtype = &amp;#39;bar&amp;#39;,align = &amp;#39;mid&amp;#39;,orientation = &amp;#39;vertical&amp;#39;,alpha = 0.5,normed = True) 密度图，加上： s.plot(kind = &amp;#39;kde&amp;#39;, style = &amp;#39;k--&amp;#39;) 柱状图能够实现堆叠，直方图也能实现堆叠,重点语句同样是stacked = True df = pd.DataFrame({&amp;#39;a&amp;#39;:np.random.randn(500) &#43; 1, &amp;#39;b&amp;#39;:np.random.randn(500), &amp;#39;c&amp;#39;:np.random.randn(500) - 1, &amp;#39;d&amp;#39;:np.random.randn(500)}, columns = list(&amp;#39;abcd&amp;#39;)) df.plot.hist(stacked = True,bins = 10,colormap = &amp;#39;Blues_r&amp;#39;,alpha = 0.5,grid = True) polar 极坐标图 matplotlib的pyplot子库提供了绘制极坐标图的方法。在调用subplot()创建子图时通过设置projection=&amp;lsquo;polar&amp;rsquo;,便可创建一个极坐标子图，然后调用plot()在极坐标子图中绘图。
ax1 = plt.subplot(121, projection=&amp;#39;polar&amp;#39;) 部分参数意义：
theta：角度数据
radii ：极径数据
theta_direction方法用于设置极坐标的正方向
theta_zero_location方法用于设置极坐标0°位置，0°可设置在八个位置，分别为N, NW, W, SW, S, SE, E, NE
thetagrids方法用于设置极坐标角度网格线显示
theta_offset方法用于设置角度偏离
&amp;hellip;&amp;hellip;
极区图：
N = 20 theta = np.linspace(0, 2 * np.pi, N, endpoint = False) radii = 10 * np.random.rand(N) width = np.pi / 4 * np.random.rand(N) ax = plt.subplot(111, projection = &amp;#39;polar&amp;#39;) bars = ax.bar(theta, radii, width = width, bottom = 0.0) 极散点图：
theta = np.arange(0,2*np.pi, np.pi/4) # 数据角度 r = np.arange(1,9,1) #数据极径 area = 100*np.arange(1,9,1) # 数据散点面积 colors = theta ax2 = plt.subplot(111,projection=&amp;#39;polar&amp;#39;) ax2.scatter(theta, r, c=colors, s=area, cmap=&amp;#39;hsv&amp;#39;, alpha =0.75) boxplot 箱型图 绘制箱线图，用plt.boxplot()这个函数。箱型图是利用数据中的五个统计量：最小值、第一四分位数、中位数、第三四分位数与最大值来描述数据的一种方法。它也可以粗略地看出数据是否具有有对称性，分布的分散程度等信息，特别可以用于对几个样本的比较。
箱线图各部分含义
部分参数：sym：异常值的形状 ；whis：用于调节上下垂直线的长度
生成单个箱型图：
np.random.seed(100)#生成随机数 data=np.random.normal(size=1000,loc=0,scale=1) plt.boxplot(data,sym=&amp;#39;o&amp;#39;,whis=1.5) plt.show() 多个箱型图：
np.random.seed(100)#生成随机数 data=np.random.normal(size=(1000,4),loc=0,scale=1) #1000个值得4维数组 lables = [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;D&amp;#39;] plt.boxplot(data,labels=lables) plt.show() 箱型图也可以是横向的，加上vert=False即可：
heatmap 热图 热图是数据分析的常用方法，通过色差、亮度来展示数据的差异、易于理解。matplotlib中生成热图是调用的函数imshow（）。
X = [[1,2],[3,4],[5,6]] plt.imshow(X) plt.show() 增加颜色类标的代码是plt.colorbar()：
可视化控制 前面我们用matplotlib绘制了许多不同类型的图像，对于基本的数据分析已经完全掌握。但在一些细节的调节、颜色、美观度上我们没有做过多强调，matplotlib所提供的不仅仅是图形的基本绘制，它也提供了让图像展示更精细的工具。
颜色表示 八种内件颜色缩写： b:blue g:green r:red c:cyan m:magenta y:yellow k:black w:white 先用numpy生成四条线，再对四条线的颜色进行设置： import numpy as np import pandas as pd import matplotlib.pyplot as plt y=np.arange(1,5) 简单颜色展示 plt.plot(y,color=&amp;#39;b&amp;#39;) 灰色度 plt.plot(y&#43;1,color=&amp;#39;0.5&amp;#39;) #灰色 程度为0.5 十六进制颜色表示 十六进制颜色代码可通过百度颜色代码（对照表查找）
plt.plot(y&#43;2,color=&amp;#39;#FFEC8B&amp;#39;) RGB 表示 此时注意要将R，G，B每个值除以255，使其属于0~1之间，如下为红色:
plt.plot(y&#43;3,color=(1,0,0)) 效果图：
点、线样式 四种线型 plt.plot(y,&amp;#39;-&amp;#39;) #实线 plt.plot(y&#43;1,&amp;#39;--&amp;#39;)#虚线 plt.plot(y&#43;2,&amp;#39;-.&amp;#39;)#点划线 plt.plot(y&#43;3,&amp;#39;:&amp;#39;)#点线 点样式 plt.plot(y,&amp;#39;o&amp;#39;) plt.plot(y&#43;1,&amp;#39;D&amp;#39;) plt.plot(y&#43;2,&amp;#39;^&amp;#39;) plt.plot(y&#43;3,&amp;#39;p&amp;#39;) 指定marker时，会画出线段：
plt.plot(y,marker=&amp;#39;o&amp;#39;) plt.plot(y&#43;1,marker=&amp;#39;D&amp;#39;) 样式字符串 将颜色，点型，线型写成一个字符串，如:gx：，mo&amp;ndash;等
plt.plot(y,&amp;#39;gx:&amp;#39;) plt.plot(y&#43;1,&amp;#39;mo--&amp;#39;) plt.plot(y&#43;2,&amp;#39;bp-&amp;#39;) 保存图片 plt.savefig() # 保存 关于 matplotlib，基本的图形绘制到这里就差不多了，虽然只是最常规的图形，但是足够让你开始尝试探索数据，快速绘图并获得分析结果。
参考文献  matplotlib官方文档 十分钟|matplotlib上手，开启你的python可视化 </content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; primer plus 第16章String类和标准模板库</title>
        <url>http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC16%E7%AB%A0string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
        <categories>
          <category>C&#43;&#43;</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> C&#43;&#43; primer plus 第16章String类和标准模板库
String类</content>
    </entry>
    
     <entry>
        <title>循环神经网络RNN介绍</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Crnn%E4%BB%8B%E7%BB%8D/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>循环神经网络</tag><tag>RNN</tag>
        </tags>
        <content type="html"> 循环神经网络(Recurrent Neural Networks，RNN)已经在众多自然语言处理(Natural Language Processing, NLP)中取得了巨大成功以及广泛应用。本文将对RNN进行简单介绍。
神经网络基础 神经网络可以当做是能够拟合任意函数的黑盒子，只要训练数据足够，给定特定的x，就能得到希望的y，结构图如下：
将神经网络模型训练好之后，在输入层给定一个x，通过网络之后就能够在输出层得到特定的y，那么既然有了这么强大的模型，为什么还需要RNN（循环神经网络）呢？
为什么需要RNN 他们都只能单独的取处理一个个的输入，前一个输入和后一个输入是完全没有关系的。但是，某些任务需要能够更好的处理序列的信息，即前面的输入和后面的输入是有关系的。
 比如，当我们在理解一句话意思时，孤立的理解这句话的每个词是不够的，我们需要处理这些词连接起来的整个序列； 当我们处理视频的时候，我们也不能只单独的去分析每一帧，而要分析这些帧连接起来的整个序列。
 以nlp的一个最简单词性标注任务来说，将我 吃 苹果 三个单词标注词性为 我/nn 吃/v 苹果/nn。
那么这个任务的输入就是：
我 吃 苹果 （已经分词好的句子）
这个任务的输出是：
我/nn 吃/v 苹果/nn(词性标注好的句子)
对于这个任务来说，我们当然可以直接用普通的神经网络来做，给网络的训练数据格式了就是我-&amp;gt; 我/nn 这样的多个单独的单词-&amp;gt;词性标注好的单词。
但是很明显，一个句子中，前一个单词其实对于当前单词的词性预测是有很大影响的，比如预测苹果的时候，由于前面的吃是一个动词，那么很显然苹果作为名词的概率就会远大于动词的概率，因为动词后面接名词很常见，而动词后面接动词很少见。
所以为了解决一些这样类似的问题，能够更好的处理序列的信息，RNN就诞生了。
RNN结构 首先看一个简单的循环神经网络如，它由输入层、一个隐藏层和一个输出层组成：
不知道初学的同学能够理解这个图吗，反正我刚开始学习的时候是懵逼的，每个结点到底代表的是一个值的输入，还是说一层的向量结点集合，如何隐藏层又可以连接到自己，等等这些疑惑~这个图是一个比较抽象的图。
我们现在这样来理解，如果把上面有W的那个带箭头的圈去掉，它就变成了最普通的全连接神经网络。x是一个向量，它表示输入层的值（这里面没有画出来表示神经元节点的圆圈）；s是一个向量，它表示隐藏层的值（这里隐藏层面画了一个节点，你也可以想象这一层其实是多个节点，节点数与向量s的维度相同）；
U是输入层到隐藏层的权重矩阵，o也是一个向量，它表示输出层的值；V是隐藏层到输出层的权重矩阵。
那么，现在我们来看看W是什么。循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。权重矩阵 W就是隐藏层上一次的值作为这一次的输入的权重。
我们给出这个抽象图对应的具体图：
我们从上图就能够很清楚的看到，上一时刻的隐藏层是如何影响当前时刻的隐藏层的。
如果我们把上面的图展开，循环神经网络也可以画成下面这个样子：
我们可以用下面的公式来表示循环神经网络的计算方法：
总结 好了，到这里大概讲解了RNN最基本的几个知识点，能够帮助大家直观的感受RNN和了解为什么需要RNN，后续总结它的反向求导知识点。
注意：为了简单说明问题，偏置都没有包含在公式里面。
</content>
    </entry>
    
     <entry>
        <title>深度学习目标检测：R-CNN, SSPNet, Fast R-CNN, Faster R-CNN, YOLO, SSD</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8Br-cnn-sspnet-fast-r-cnn-faster-r-cnn-yolo-ssd/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>R-CNN</tag><tag>SSPNet</tag><tag>Fast R-CNN</tag><tag>Faster R-CNN</tag><tag>YOLO</tag><tag>SSD</tag>
        </tags>
        <content type="html"> Object Detection，在给定的图像中，找到目标图像的位置，并标注出来。 或者是，图像中有那些目标，目标的位置在那。这个目标，是限定在数据集中包含的目标种类，比如数据集中有两种目标:狗，猫。 就在图像找出来猫，狗的位置，并标注出来 是狗还是猫。
这就涉及到两个问题：
 目标识别，识别出来目标是猫还是狗，Image Classification解决了图像的识别问题。 定位，找出来猫狗的位置。  本文将详细介绍目前深度学习目标检测算法的几种热门算法R-CNN, SSPNet, Fast R-CNN, Faster R-CNN, YOLO, SSD的比较
1. R-CNN RCNN (论文：Rich feature hierarchies for accurate object detection and semantic segmentation) 是将CNN方法引入目标检测领域， 大大提高了目标检测效果，可以说改变了目标检测领域的主要研究思路， 紧随其后的系列文章：（RCNN）,Fast RCNN, Faster RCNN 代表该领域当前最高水准。
【论文主要特点】（相对传统方法的改进）
 速度： 经典的目标检测算法使用滑动窗法依次判断所有可能的区域。本文则(采用Selective Search方法)预先提取一系列较可能是物体的候选区域，之后仅在这些候选区域上(采用CNN)提取特征，进行判断。
 训练集： 经典的目标检测算法在区域中提取人工设定的特征。本文则采用深度网络进行特征提取。使用两个数据库： 一个较大的识别库（ImageNet ILSVC 2012）：标定每张图片中物体的类别。一千万图像，1000类。 一个较小的检测库（PASCAL VOC 2007）：标定每张图片中，物体的类别和位置，一万图像，20类。 本文使用识别库进行预训练得到CNN（有监督预训练），而后用检测库调优参数，最后在检测库上评测。
  RCNN算法分为4个步骤:
 候选区域生成： 一张图像生成1K~2K个候选区域（采用Selective Search 方法） 特征提取：对每个候选区域，使用深度卷积网络提取特征 （CNN） 类别判断：特征送入每一类的SVM 分类器，判别是否属于该类 位置精修：使用回归器精细修正候选框位置  下图给出了R-CNN过程
1.1 参考文献：  RCNN- 将CNN引入目标检测的开山之作 R-CNN论文详解 目标检测之R-CNN系列 深度学习目标检测：RCNN，Fast，Faster，YOLO，SSD比较 </content>
    </entry>
    
     <entry>
        <title>hugo博客建立归档页面</title>
        <url>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/hugo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%9D%A2/</url>
        <categories>
          <category>博客</category>
        </categories>
        <tags>
          <tag>Hugo</tag><tag>归档页面</tag>
        </tags>
        <content type="html"> 在 Hugo 中默认只生成 tags 和 categories 两个页面，没有 archives （归档）页面，所以我们需要自己实现
新建归档单页面模板 首先，在 themes/主题/layouts 目录创建一个目录 archives 然后在里面新建一个文件 single.html。
替换归档页面模板代码 注意我们接下来要覆盖 themes/主题/layouts/_default/baseof.html 中的 main 模块：
{{ define &amp;#34;main&amp;#34; }} &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;{{ &amp;#34;css/archives.css&amp;#34; | absURL }}&amp;#34;&amp;gt; &amp;lt;article class=&amp;#34;article article-type-post&amp;#34; itemscope=&amp;#34;&amp;#34; itemprop=&amp;#34;blogPost&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;article-inner&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;post-archive&amp;#34;&amp;gt; {{ range (where (where .Site.Pages &amp;#34;Type&amp;#34; &amp;#34;post&amp;#34;) &amp;#34;Kind&amp;#34; &amp;#34;page&amp;#34;).GroupByDate &amp;#34;2006&amp;#34; }} &amp;lt;h2&amp;gt; {{ .Key }} &amp;lt;/h2&amp;gt; &amp;lt;ul class=&amp;#34;listing&amp;#34;&amp;gt; {{ range .Pages }} &amp;lt;li&amp;gt; &amp;lt;date class=&amp;#34;meta-date&amp;#34;&amp;gt;{{ .Date.Format &amp;#34;2006/01/02&amp;#34; }}&amp;lt;/date&amp;gt; &amp;lt;a class=&amp;#34;archive-title&amp;#34; href=&amp;#34;{{ .Permalink }}&amp;#34; title=&amp;#34;{{ .Title }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; {{ end }} &amp;lt;/ul&amp;gt; {{ end }} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/article&amp;gt; {{ end }} 新建归档页面 接着在 content 目录创建文件 archives.md 将 type 设置为 archives 就可以了：
--- title: &amp;#34;归档&amp;#34; type: &amp;#34;archives&amp;#34; prevnext: false --- 总结 在 Hugo 中定一个页面模板 baseof.html 我们可以去修改这个模板，然后再去填充或者覆盖对应的区域
</content>
    </entry>
    
     <entry>
        <title>Hugo插入图片</title>
        <url>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/hugo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
        <categories>
          <category>博客</category>
        </categories>
        <tags>
          <tag>Hugo</tag><tag>图片插入</tag>
        </tags>
        <content type="html"> 在写博客时，常常需要在文章中插入图片，Hugo有多种图片插入方式，可以将图片存在本地引用、将图片放在CDN引用或建立图床。
本地引用 绝对路径 当图片使用较少时，可以将图片存在 static/images/具体文章 目录下的，在部署当github page上面时，会将图片推到github上
![alt](/images/具体文章/image_1.jpg) 图片既可以在文章中访问到，也可以在首页访问到。
相对路径 图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.toml来生成。
在新建文章时，得到的是包含文章和图片的文件夹。
注意事项 注意:你可能在你本地markdown编辑器上显示不出这张图片,你可以在本地运行hugo,在你的浏览器中就可以看到了
CDN引用 CDN引用 除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如Cloudinary提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。
By the way：可以在github上新建一个repo，专门存储图片，将图片按文章进行分类，方便管理。
建立图床 具体参考：Code show——GitHub&#43;jsDelivr&#43;PicGo打造稳定快速高效图床
</content>
    </entry>
    
     <entry>
        <title>卷积神经网络</title>
        <url>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
        <categories>
          <category>图像处理与深度学习</category>
        </categories>
        <tags>
          <tag>卷积神经网络</tag>
        </tags>
        <content type="html"> 卷积神经网络（CNN）是一种深层神经网络，已被证明在计算机视觉任务中表现出色，例如图像分类，目标检测，目标定位和神经样式转换。 在这篇文章中，我将详细地介绍构成卷积神经网络的不同层：卷积层，池化层和完全连接层。
前言——卷积神经网络介绍 为什么不用全连接神经网络？ 如果用全连接神经网络处理大尺寸图像具有三个明显的缺点：
 首先将图像展开为向量会丢失空间信息； 其次参数过多效率低下，训练困难； 同时大量的参数也很快会导致网络过拟合。  而使用卷积神经网络可以很好地解决上面的三个问题。
卷积神经网络 卷积神经网络的真谛：
 卷积神经网络主要由两部分组成 一部分是特征提取（卷积、激活函数、池化），另一部分是分类识别（全连接）
 如今，CNN被用来应用于各个领域，比如物体分割、风格转换、自动上色……
————但是，CNN真正能做的，只是起到一个图像特征提取器的作用！
引子：边界检测 我们来看一个最简单的例子：“边界检测（edge detection）”，假设我们有这样的一张图片，大小8×8：
图片中的数字代表该位置的像素值，我们知道，像素值越大，颜色越亮，所以为了示意，我们把右边小像素的地方画成深色。图的中间两个颜色的分界线就是我们要检测的边界。
怎么检测这个边界呢？我们可以设计这样的一个 滤波器（filter，也称为kernel），大小3×3：
然后，我们用这个filter，往我们的图片上“盖”，覆盖一块跟filter一样大的区域之后，对应元素相乘，然后求和。计算一个区域之后，就向其他区域挪动，接着计算，直到把原图片的每一个角落都覆盖到了为止。这个过程就是 “卷积”。
（我们不用管卷积在数学上到底是指什么运算，我们只用知道在CNN中是怎么计算的。）
这里的“挪动”，就涉及到一个步长了，假如我们的步长是1，那么覆盖了一个地方之后，就挪一格，容易知道，总共可以覆盖6×6个不同的区域。
那么，我们将这6×6个区域的卷积结果，拼成一个矩阵：
诶？！发现了什么？ 这个图片，中间颜色浅，两边颜色深，这说明咱们的原图片中间的边界，在这里被反映出来了!
从上面这个例子中，我们发现，我们可以通过设计特定的filter，让它去跟图片做卷积，就可以识别出图片中的某些特征，比如边界。
上面的例子是检测竖直边界，我们也可以设计出检测水平边界的，只用把刚刚的filter旋转90°即可。对于其他的特征，理论上只要我们经过精细的设计，总是可以设计出合适的filter的。
我们的CNN（convolutional neural network），主要就是通过一个个的filter，不断地提取特征，从局部的特征到总体的特征，从而进行图像识别等等功能。
那么问题来了，我们怎么可能去设计这么多各种各样的filter呀？首先，我们都不一定清楚对于一大推图片，我们需要识别哪些特征，其次，就算知道了有哪些特征，想真的去设计出对应的filter，恐怕也并非易事，要知道，特征的数量可能是成千上万的。
其实学过神经网络之后，我们就知道，这些filter，根本就不用我们去设计，每个filter中的各个数字，不就是参数吗，我们可以通过大量的数据，来 让机器自己去“学习”这些参数嘛。这，就是CNN的原理。
卷积神经网络结构 卷积神经网络主要由这几类层构成：输入层、卷积层，ReLU层、池化（Pooling）层和全连接层（全连接层和常规神经网络中的一样）。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络。在实际应用中往往将卷积层与ReLU层共同称之为卷积层，所以卷积层经过卷积操作也是要经过激活函数的。具体说来，卷积层和全连接层（CONV/FC）对输入执行变换操作的时候，不仅会用到激活函数，还会用到很多参数，即神经元的权值w和偏差b；而ReLU层和池化层则是进行一个固定不变的函数操作。卷积层和全连接层中的参数会随着梯度下降被训练，这样卷积神经网络计算出的分类评分就能和训练集中的每个图像的标签吻合了。
卷积层 卷积层对输入图像进行转换，以从中提取特征。在这种转换中，图像与内核（或滤波器）卷积。
核是一个小的矩阵，其高度和宽度小于要卷积的图像。 它也被称为卷积矩阵或卷积掩码。 该核在图像输入的高度和宽度上滑动，并且核的点积和图像在每个空间位置处进行计算。 籽粒滑动的长度称为步幅长度。 在下面的图像中，输入图像的大小为5X5，内核的大小为3X3，步幅为1。输出图像也称为卷积特征。
当使用通道3卷积彩色图像（RGB图像）时，滤镜的通道也必须为3。 换句话说，在卷积中，内核中的通道数必须与输入图像中的通道数相同。
当我们想使用卷积从一个图像中提取多个特征时，我们可以使用多个内核而不是仅使用一个。 在这种情况下，所有内核的大小必须相同。 输入图像和输出图像的卷积特征一个接一个地堆叠在一起以创建输出，因此通道数等于使用的滤波器个数。 请参阅下图以供参考。
更具体的是，在加入偏置bias之后，每个filter对应每个通道有一组w权重，一个filter滑动到一个位置后计算三个通道的卷积，求和，加bias，得到这个filter在该位置的最终结果，每个filter的输出是各个通道的汇总。请参阅下图以供参考：
非线性激活层——重点理解激活函数ReLu 什么是ReLu 官方解释：
 卷积层对原图运算多个卷积，产生一组线性激活响应，而非线性激活层是对之前的结果进行一个非线性的激活响应。
 激活函数的作用是用来加入非线性因素，把卷积层输出结果做非线性映射。
在卷积神经网络中用到最多的非线性激活函数是Relu函数，
它的公式定义：f(x)=max(0,x)
 即，保留大于等于0的值，其余所有小于0的数值直接改写为0,&amp;gt;=0的值全部保持不变：
 常见的激活函数——sigmoid、tanh和relu三种非线性函数 隐藏层:
 tanh函数要优于sigmoid函数，优势在于其取值范围介于-1 ~ 1之间，数据的平均值为0，而不像sigmoid为0.5，有类似数据中心化的效果。 可以认为是sigmoid的平移版本，
 输出层:
 sigmoid也许会优于tanh函数，原因在于你希望输出结果的概率落在0 ~ 1 之间，比如二元分类，sigmoid可作为输出层的激活函数。
 实际应用中，特别是深层网络在训练时:
 tanh和sigmoid会在端值趋于饱和，造成训练速度减慢，故深层网络的激活函数默认大多采用relu函数，浅层网络可以采用sigmoid和tanh函数。
 那么为什么现在这么多网络，都更多地使用ReLU函数呢？
 一个重要原因就是上面提到的，其稀疏激活性。
1、标准的sigmoid函数输出不具备稀疏性，需要用一些惩罚因子来训练出一大堆接近0的冗余数据来，从而产生稀疏数据
2、而ReLU是线性修正。它的作用是如果计算出的值小于0，就让它等于0，否则保持原来的值不变。
这是一种简单粗暴地强制某些数据为0的方法，然而经实践证明，训练后的网络完全具备适度的稀疏性。而且训练后的可视化效果和传统方式预训练出的效果很相似，这也说明了ReLU具备引导适度稀疏的能力。
因此，ReLu的使用，使得网络可以自行引入稀疏性，同时大大地提高了训练速度。
 激活函数是卷积层的最后一个组成部分，可增加输出中的非线性。通常，在卷积层中将ReLu函数或Tanh函数用作激活函数。 这是一个简单卷积层的图像，其中将6X6X3输入图像与大小为4X4X3的两个内核卷积以得到大小为3X3X2的卷积特征，对其应用激活函数以获取输出，这也称为特征地图feature map。
池化层pooling 池化的作用 （1）卷积操作后，我们得到了一张张有着不同值的feature map，尽管数据量比原图少了很多，但还是过于庞大（深度学习动不动就几十万张训练图片），这时候该怎么办？？
池化操作，最大的作用就是减少数据量。
 池化层的引入，是仿照人的视觉系统对视觉输入对象进行降维和抽象。
 （2）【官方说明】在卷积神经网络过去的工作中，研究者普遍认为池化层有如下三个功效：
 1、特征不变形：池化操作使得模型更加关注是否存在某些特征，而不是特征具体的位置。
2、特征降维：池化相当于在空间范围内做了维度约减，从而使模型可以抽取更加广范围的特征。同时减小了下一层的输入大小，进而减少计算量和参数个数。
3、在一定程度上防止过拟合，更方便优化。 （由1、2可知，这种池化机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。）
 池化的分类 池操作也使用内核和跨步。 在下面的示例图像中，使用2X2滤波器合并大小为4，跨度为2的4X4输入图像。
有不同类型的池。 最大池和平均池是卷积神经网络中最常用的池方法。
最大池化：在最大池化中，从要素图的每个面片中选择最大值以创建缩小图。
平均池化：在平均池化中，从要素图的每个面片中选择平均值以创建缩小图。
总结  因为最大池化保留了每一个小块内的最大值，所以它相当于保留了这一块最佳匹配结果。
 这也就意味着：池化操作不会具体关注窗口内到底是哪一个地方匹配了，而只关注是不是有某个地方匹配上了。
 侧面说明——CNN能够发现图像中是否具有某种特征，而不用在意到底在哪里具有这种特征。这也就帮助解决，之前提到的计算机逐一像素匹配的死板做法。
 到这里就介绍了CNN的基本配置&amp;mdash;卷积层、Relu层、池化层。
在常见的几种CNN中，这三层都是可以堆叠使用的，将前一层的输入作为后一层的输出。
比如：
全连接层 全连接层的作用  为什么是全连接？   卷积取的是局部特征，全连接就是把以前的局部特征重新通过权值矩阵，组装成完整的图，因为用到了所有的局部特征，所以叫全连接。
  全连接层要做的，是什么？  起到“分类”的作用
 全连接层要做的，就是对之前的所有操作进行一个总结。对特征图进行维度上的改变，来得到每个分类类别对应的概率值。
 全连接操作 完全连接的层位于卷积神经网络的末端。 由较早层产生的特征图将展平为矢量。然后，此向量被馈送到完全连接的层，以便它捕获高级要素之间的复杂关系。该层的外面是一维特征向量。
（1）接着上面的例子，原图片尺寸为9X9，在一系列的卷积、relu、池化操作后，得到尺寸被压缩为2X2的三张特征图。
得到了2X2的特征图后，对其应用全连接网络，再全连接层中有一个非常重要的函数——Softmax，它是一个分类函数，输出的是每个对应类别的概率值。
 比如：【0.5，0.03，0.89，0.97，0.42，0.15】就表示有6个类别，并且属于第四个类别的概率值0.97最大，因此判定属于第四个类别。
 （2）将三个特征图改变维度直接变成一维的数据，展开的数据即为属于类别X的概率值，值大小也在对应X的线条粗细中表现出来了。
现在，您知道什么是卷积神经网络以及组成卷积神经网络的不同层，即卷积层，池化层和完全连接的层。
下面是用于二进制图像分类的卷积神经网络的简单架构。该网络将两个不同类别之间的输入分类。 该网络接收大小为32x32x3的RBG图像，输出大小为2（等于分类的类数）。 该网络的第一层是具有5x5x3内核的卷积层，第二层是具有2x2内核大小的最大池化层，第三层是具有5x5x3内核的卷积层，第四层是最大池化层 如果内核大小为2x2，则将输出展平为一个向量，并馈入最后两个都是完全连接的层。
CNN中一些基本概念  padding 填白 从上面的引子中，我们可以知道，原图像在经过filter卷积之后，变小了，从(8,8)变成了(6,6)。假设我们再卷一次，那大小就变成了(4,4)了。  这样有啥问题呢？ 主要有两个问题：
 每次卷积，图像都缩小，这样卷不了几次就没了； 相比于图片中间的点，图片边缘的点在卷积中被计算的次数很少。这样的话，边缘的信息就易于丢失。  为了解决这个问题，我们可以采用padding的方法。我们每次卷积前，先给图片周围都补一圈空白，让卷积之后图片跟原来一样大，同时，原来的边缘也被计算了更多次。
比如，我们把(8,8)的图片给补成(10,10)，那么经过(3,3)的filter之后，就是(8,8)，没有变。
我们把上面这种“让卷积之后的大小不变”的padding方式，称为 “Same”方式， 把不经过任何填白的，称为 “Valid”方式。这个是我们在使用一些框架的时候，需要设置的超参数。
 stride 步长  前面我们所介绍的卷积，都是默认步长是1，但实际上，我们可以设置步长为其他的值。
比如，对于(8,8)的输入，我们用(3,3)的filter， 如果stride=1，则输出为(6,6); 如果stride=2，则输出为(3,3);（这里例子举得不大好，除不断就向下取整）
卷积神经网络 VS. 传统神经网络 其实现在回过头来看，CNN跟我们之前学习的神经网络，也没有很大的差别。
传统的神经网络，其实就是多个FC层叠加起来。 CNN，无非就是把FC改成了CONV和POOL，就是把传统的由一个个神经元组成的layer，变成了由filters组成的layer。
那么，为什么要这样变？有什么好处？ 具体说来有两点：
 参数共享机制（parameters sharing） 我们对比一下传统神经网络的层和由filters构成的CONV层： 假设我们的图像是8×8大小，也就是64个像素，假设我们用一个有9个单元的全连接层：  那这一层我们需要多少个参数呢？需要 64×9 = 576个参数（先不考虑偏置项b）。因为每一个链接都需要一个权重w。
那我们看看 同样有9个单元的filter是怎么样的：
其实不用看就知道，有几个单元就几个参数，所以总共就9个参数！
因为，对于不同的区域，我们都共享同一个filter，因此就共享这同一组参数。
这也是有道理的，通过前面的讲解我们知道，filter是用来检测特征的，那一个特征一般情况下很可能在不止一个地方出现，比如“竖直边界”，就可能在一幅图中多出出现，那么 我们共享同一个filter不仅是合理的，而且是应该这么做的。
由此可见，参数共享机制，让我们的网络的参数数量大大地减少。这样，我们可以用较少的参数，训练出更加好的模型，典型的事半功倍，而且可以有效地 避免过拟合。
同样，由于filter的参数共享，即使图片进行了一定的平移操作，我们照样可以识别出特征，这叫做** “平移不变性”**。因此，模型就更加稳健了。
2.连接的稀疏性（sparsity of connections）
由卷积的操作可知，输出图像中的任何一个单元，只跟输入图像的一部分有关系。
而传统神经网络中，由于都是全连接，所以输出的任何一个单元，都要受输入的所有的单元的影响。这样无形中会对图像的识别效果大打折扣。比较，每一个区域都有自己的专属特征，我们不希望它受到其他区域的影响。
正是由于上面这两大优势，使得CNN超越了传统的NN，开启了神经网络的新时代。
案例学习 下面是卷积神经网络领域中比较有名的几种结构：
 LeNet ，第一个成功的卷积神经网络应用，是Yann LeCun在上世纪90年代实现的。当然，最著名还是被应用在识别数字和邮政编码等的LeNet结构。
 AlexNet ，AlexNet卷积神经网络在计算机视觉领域中受到欢迎，它由Alex Krizhevsky，Ilya Sutskever和Geoff Hinton实现。AlexNet在2012年的ImageNet ILSVRC 竞赛中夺冠，性能远远超出第二名（16%的top5错误率，第二名是26%的top5错误率）。这个网络的结构和LeNet非常类似，但是更深更大，并且使用了层叠的卷积层来获取特征（之前通常是只用一个卷积层并且在其后马上跟着一个汇聚层）。
 ZF Net ，Matthew Zeiler和Rob Fergus发明的网络在ILSVRC 2013比赛中夺冠，它被称为 ZFNet（Zeiler &amp;amp; Fergus Net的简称）。它通过修改结构中的超参数来实现对AlexNet的改良，具体说来就是增加了中间卷积层的尺寸，让第一层的步长和滤波器尺寸更小。
 GoogLeNet ，ILSVRC 2014的胜利者是谷歌的Szeged等实现的卷积神经网络。它主要的贡献就是实现了一个奠基模块，它能够显著地减少网络中参数的数量（AlexNet中有60M，该网络中只有4M）。还有，这个论文中没有使用卷积神经网络顶部使用全连接层，而是使用了一个平均汇聚，把大量不是很重要的参数都去除掉了。GooLeNet还有几种改进的版本，最新的一个是Inception-v4。
 VGGNet ，ILSVRC 2014的第二名是Karen Simonyan和 Andrew Zisserman实现的卷积神经网络，现在称其为VGGNet。它主要的贡献是展示出网络的深度是算法优良性能的关键部分。他们最好的网络包含了16个卷积/全连接层。网络的结构非常一致，从头到尾全部使用的是3x3的卷积和2x2的汇聚。他们的预训练模型是可以在网络上获得并在Caffe中使用的。VGGNet不好的一点是它耗费更多计算资源，并且使用了更多的参数，导致更多的内存占用（140M）。其中绝大多数的参数都是来自于第一个全连接层。后来发现这些全连接层即使被去除，对于性能也没有什么影响，这样就显著降低了参数数量。
 ResNet ，残差网络（Residual Network）是ILSVRC2015的胜利者，由何恺明等实现。它使用了特殊的跳跃链接，大量使用了批量归一化（batch normalization）。这个结构同样在最后没有使用全连接层。读者可以查看何恺明的的演讲（视频，PPT），以及一些使用Torch重现网络的实验。ResNet当前最好的卷积神经网络模型（2016年五月）。何开明等最近的工作是对原始结构做一些优化，可以看论文Identity Mappings in Deep Residual Networks，2016年3月发表。
  参考文章：  卷积神经网络初学者指南 【DL笔记6】从此明白了卷积神经网络（CNN） 【专题知识】—详解卷积神经网络CNN 卷积神经网络（CNN）详解 </content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; primer plus 第15章友元、异常和其他</title>
        <url>http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC15%E7%AB%A0%E5%8F%8B%E5%85%83%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/</url>
        <categories>
          <category>C&#43;&#43;</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> C&#43;&#43; primer plus 第15章友元、异常和其他
友元 友元类 友元函数：不是类的成员函数，但是能够访问类的私有数据成员。
之前有个矛盾就是规定非成员函数不能直接访问类的私有数据，但是这会儿却可以，但那只是针对常规非成员函数而言，特殊的非成员函数就可以访问类的私有数据——友元函数。
友元函数就是这么特殊，虽然在类中声明，却不是类的成员函数，这是因为加了前缀friend。
友元不仅包含函数，类也可以当友元，也就是友元类。
友元类的所有方法都可以访问原始类的私有成员和保护成员。
也可以做更严格的限制，只将限定的成员函数指定为另一类的友元。
尽管友元被授予从外部访问类的私有部分的权限，但它们并不与面向对象的编程思想相违背。
接下来就是讨论友元类：
假定要编写一个模拟电视机和遥控器的简单程序。
决定定义一个Tv类和一个Remote类，来分别表示电视机和遥控器。
很明显，这两个类之间应当存在某种关系，遥控器并非电视机，反之亦然，但是遥控器却可以改变电视机的状态。这样的关系可以将Remote类作为Tv类的一个友元来实现。
友元类声明位置无关紧要，可以声明在公有、私有、保护部分；
定义一个电视机类，用一些状态成员来表示电视机： * 开/关； * 频道设置； * 音量设置； * 有线电视or天线调节模式； * TV调谐或A/V输入。
tv.h文件，声明tv和remote的类
#ifndef TV_H_ #define TV_H_ class Tv { public: friend class Remote; enum{Off, On}; enum{MinVal, MaxVal=20}; enum{Antenna, Cable}; enum{TV,DVD}; Tv():state(s),volume(5),maxchannel(mc),channel(2),mode(Cable),input(TV){} void onoff() {state=(state == On)?Off:On;} bool ison() const {return state==On;} bool volup(); bool voldown(); void chanup(); void chandown(); void set_mode() {mode=(mode == Antenna)?Cable:Antenna;} void set_input() {input=(input == TV)?Cable:Antenna;} void settings() const; //display all settings; private: int state; //on or off int volume; int maxchannel; int channel; //current channel setting int mode; //broadcast or cable int inputs; //TV or DVD }; class Remote //Remote方法以TV的对象引用作为参数，这表明遥控器必须针对特定的电视机 { private: int mode; //controls TV or DVD; public: Remote(int m=Tv::Tv): mode(m) {} bool volup(Tv &amp;amp; t) {return t.volup();} bool voldown(Tv &amp;amp; t) {return t.voldown();} void onoff(Tv &amp;amp; t) {t.onoff();} void chanup(Tv &amp;amp; t) {t.chanup();} void chandown(Tv &amp;amp; t) {t.chandown();} void set_chan(Tv &amp;amp; t, int c) {t.channel = c;} void set_mode(Tv &amp;amp; t) {t.set_mode();} void set_input(Tv &amp;amp; t) {t.set_input();} }; #endif tv.cpp
#include &amp;lt;iostream&amp;gt; #include &amp;#34;tv.h&amp;#34; bool Tv::volup() { if(volume&amp;lt;MaxVal) { volume&#43;&#43;; return true; } else return false; } bool Tv::voldown() { if(volume&amp;gt;MinVal) { volume--; return true; } else return false; } void Tv:chanup() { if(channel&amp;lt;maxchannel) channel&#43;&#43;; else channel=1; } void Tv::chandown() { if(channel&amp;gt;1) channel--; else channel = maxchannel; } void Tv::Settings() const { using std::cout; using std::endl; cout&amp;lt;&amp;lt;&amp;#34;TV is &amp;#34;&amp;lt;&amp;lt;(state==Off?&amp;#34;Off&amp;#34;:&amp;#34;On&amp;#34;)&amp;lt;&amp;lt;endl; if(state == On) { cout&amp;lt;&amp;lt;&amp;#34;Volume setting = &amp;#34;&amp;lt;&amp;lt;volume&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;&amp;#34;Channel setting = &amp;#34;&amp;lt;&amp;lt;channel&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;&amp;#34;Mode = &amp;#34;&amp;lt;&amp;lt;(mode == Antenna? &amp;#34;antenna&amp;#34;:&amp;#34;cable&amp;#34;)&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;&amp;#34;Input = &amp;#34;&amp;lt;&amp;lt;(mode == TV? &amp;#34;TV&amp;#34;:&amp;#34;DVD&amp;#34;)&amp;lt;&amp;lt;endl; } } use_tv.cpp
#include&amp;lt;iostream&amp;gt; #include &amp;#34;tv.h&amp;#34; int main() { using std::cout; Tv s42; cout&amp;lt;&amp;lt;&amp;#34;Initial settings for 42\&amp;#34; TV:\n&amp;#34;; s42.settings(); s42.onoff(); s42.chanup(); cout&amp;lt;&amp;lt;&amp;#34;\nAdjusted settings for 42\&amp;#34; TV:\n&amp;#34;; s42.chanup(); cout&amp;lt;&amp;lt;&amp;#34;\nAdjusted settings for 42\&amp;#34; TV:\n&amp;#34;; s42.settings(); Remote grey; grey.set_chan(s42, 10); grey.volup(s42); grey.volup(s42); cout&amp;lt;&amp;lt;&amp;#34;\n42\&amp;#34; settings after using remote:\n&amp;#34;; s42.settings(); Tv s58(Tv::On); s58.set_mode(); grey.set_chan(s58,28); cout&amp;lt;&amp;lt;&amp;#34;\n58\&amp;#34; settings:\n&amp;#34;; s58.settings(); return 0; } 友元成员函数 我们发现Remote友元类的大多数方法都是用Tv类的公有接口实现。这意味着这些方法并不是真正需要友元。
事实上唯一直接访问Tv成员的Remote方法是Remote::set_chan()，因此它是唯一需要作为友元的方法。
确实可以仅让特定的类成员成为另一类的友元。
这种做法稍微有点麻烦，必须小心排列各种声明和定义的顺序。
让Remote::set_chan()成为Tv类的友元的方法是，在Tv类声明中将其声明为友元：
class Tv { friend void Remote::set_chan(Tv &amp;amp; t, int c); } 要让编译器能够处理这条语句，它必须知道Remote的定义。否则，它无法知道Remote是一个类，而set_chan是一个类方法；
这就意味着要把Remote的定义放到Tv类定义之前。
但是Remote方法提到了Tv对象，而这就意味着Tv定义应当放在Remote定义之前。
这就产生了循环依赖的问题。要避免循环依赖关系，就要使用前向声明（forward declaration）。
解决方法如下：
class Tv; //forward declaration 告诉编译器Tv是一个类 class Remote {...}; //然后再Remote中出现set_chan 方法时，知道其中Tv是一个类 class Tv {...}; 这里补充一句，让整个Remote类成为友元并不需要前向声明，因为友元语句本身已经指出Remote是一个类；
friend class Remote; 但是能否像下面这样排列呢？
class Remote ; //forward declaration class Tv {...}; class Remote {...}; 答案是不能，因为在编译器看到Tv类的声明中看到Remote的一个方法被声明为Tv类的友元之前，应先看到Remote类的声明和set_chan()方法的声明。
还有一个麻烦就是。Remote声明中包含了内联代码
void onoff(Tv &amp;amp; t) {t.onoff();} 由于这将调用Tv的一个方法，所以编译器此时必须已经看到了Tv类的声明。这样才能知道Tv有哪些方法，但正如看到的，该声明位于Remote声明的后面。
这种问题的解决方法是，使Remote声明中只包含方法声明，并将实际的定义放在Tv类之后。
class Tv; //forward declaration class Remote {...}; //Tv-using methods as prototypes only 只包含方法的声明 class Tv {...}; //put Remote method definitions here 定义在这里写 Remote方法的声明与下面类似
void onoff(Tv &amp;amp; t); 检查该原型时，编译器都需要知道Tv是一个类，而向前声明提供了这样的信息。
当编译器到达真正的方法定义时，它已经读取到了Tv类的声明，并拥有编译这些方法的所需信息。
通过在方法定义中使用inline关键字，仍然可以使其成为内联方法。
//这种友元成员函数的声明、定义顺序非常微妙，令人抓狂。很容易造成错误，一旦问题复杂起来，定位bug都很困难。难怪C&#43;&#43;是个大坑。友元的存在就是其中一个大坑。把类的关系，函数的关系搞复杂了。
#ifndef TVFM_H_ #define TVFM_H_ class Tv; //forward declaration class Remote { public: enum State{Off,On}; enum {MinVal, Maxval=20}; enum {Antenna, Cable}; enum {TV, DVD}; private: int mode; public: Remote(int m = TV):mode(m) {} bool volup(Tv &amp;amp; t); bool voldown(Tv &amp;amp; t); bool onoff(Tv &amp;amp; t); bool chanup(Tv &amp;amp; t); bool chandown(Tv &amp;amp; t); void set_mode(Tv &amp;amp; t); void set_input(Tv &amp;amp; t); void set_chan(Tv &amp;amp; t, int c); }; class Tv { public: friend void Remote::set_chan(Tv &amp;amp; t, int c); enum State{Off, On}; enum {Minval, Maxval =20}; enum {Antenna, Cable}; enum {Tv, DVD}; Tv(int s=Off, int mc=125):state(s),volume(5),maxchannel(mc),channel(2),mode(Cable),input(TV) {} void onoff() {state = (state==On)?Off:On;} bool ison() const {return state == On;} bool volup(); bool voldown(); void chanup(); void chandown(); void set_mode() {mode = (mode == Antenna)?Cable:Antenna;} void set_input() {input = (input == TV)?DVD:TV;} void settings() const; private: int state; int volume; int channel; int maxchannel; int mode; int input; }; //Remote methods as inline functions inline bool Remote::volup(Tv &amp;amp; t) {return t.volup();} inline bool Remote::voldown(Tv &amp;amp; t) {return t.voldown();} inline void Remote::onoff(Tv &amp;amp; t) {t.onoff();} inline void Remote::chanup(Tv &amp;amp; t) {t.chanup();} inline void Remote::chandown(Tv &amp;amp; t) {t.chandown();} inline void Remote::set_mode(Tv &amp;amp; t) {t.set_mode();} inline void Remote::set_input(Tv &amp;amp; t) {t.set_input();} inline void Remote::set_chan(Tv &amp;amp; t, int c) {t.channel = c;} 其他友元关系 友元和类的关系还可以更复杂。
举个例子，假设出现了交互式遥控器，交互式遥控器能够让您回答电视节目中的问题，如果回答错误，电视将在控制器上产生嗡嗡声。
这个例子的问题，可以使用新的友元关系来解决。我把它叫做相互的友情。
即一些Remote方法能够像前面那样访问Tv对象，而一些Tv方法也能影响Remote对象。
这可以通过让类彼此成为对方的友元来实现。即相互的友元
即除了Remote是Tv的友元外，Tv还是Remote的友元。
这里对于使用Remote对象的Tv方法，其原型可以再Remote方法类声明之前声明，但必须在Remote声明之后定义，以便编译器有足够的信息来编译该方法。
方法如下：（两个类互为友元类）
class Tv { frirend class Remote; public: void buzz(Remote &amp;amp; r); ... }; class Remote { friend class Tv; public: void Bool volup(Tv &amp;amp; t) {t.volup();} } //buzz方法的声明和定义是分开的，定义要在Remote声明之后 //这是因为这个时候编译器编译该方法时，知道Remote指的是什么了； inline void Tv::buzz(Remote &amp;amp; r) { ... } 共同的友元 需要使用友元的另一种情况是，函数需要访问两个类的私有数据。
从逻辑上看，这样的函数是每个类的成员函数，但是这是不可能的。
它可以是一个类的成员，同时是另一个类的友元，但有时将函数作为两个类的友元更加合理。
例如，假定有一个Probe类和一个Analyzer类，前者表示某种可编程的测量设备，后者表示某种可编程的分析设备。
这两个类中都有内部时钟，且希望它们能够同步，则应包含下述代码行：
class Analyzer //forward declaration class Probe { friend void sync(Analyzer &amp;amp; a, const Probe &amp;amp; p); // sync a to p friend void sync(Probe &amp;amp; p, const Analyzer &amp;amp; a); // sync p to a ... } class Analyzer { friend void sync(Analyzer &amp;amp; a, const Probe &amp;amp; p); // sync a to p friend void sync(Probe &amp;amp; p, const Analyzer &amp;amp; a); // sync p to a ... } //define the friend functions inline void sync(Analyzer &amp;amp; a, const Probe &amp;amp; p) { ... } inline void sync(Probe &amp;amp; p, const Analyzer &amp;amp; a) { ... } 前向声明使得编译器看到Probe类声明中的友元声明时，知道Analyzer是一种类型。
关于友元的总结：
理解友元的产生和意义，首先要从类说起；
类对象的私有和保护数据成员只能通过类的公有方法访问。（这里暂时不讨论类的继承）
这样做的好处是提高了数据的安全性和封装性，接口简洁。
但是这种对数据的访问和修改的强限制手段，有时候会在某些场景下不方便。
有些情况可能需要直接去访问或修改类的私有数据成员。那么为了提高类修改私有数据的灵活性，引入友元的概念。
举个例子：假如你把一个人定义成朋友，那么这个朋友也获得了进出你家的资格，而不仅仅是你的家人。
但是你的朋友不是你的家人，是有别于你的家人。所以友元不是类的成员。
友元可以是函数，类的成员函数，甚至类；
其实还可以这样理解：把友元看成与类方法一样都是表达类接口的一种方式。
嵌套类 在C&#43;&#43;中, 可以将类声明放在另一个类中. 在另一个类中声明的类被称为嵌套类(nested class), 它通过提供新的类型类作用域来避免名称混乱. 包含类的成员函数可以创建和使用被嵌套类的对象; 而仅当声明位于共有部分, 才能在包含类的外面使用嵌套类, 而且必须使用作用域解析运算符。
对类进行嵌套和包含并不同, 包含意味着将类对象作为另一个类的成员, 而对类进行嵌套不创建类成员, 而是定义了一种类型, 该类型仅在包含嵌套类声明的类中有效.
我们先看一个之前的一个例子, 自定义实现的简化版的队列:
class Queue { private: // 这里Node是一个嵌套的结构体定义 // Item是一个别名, 详见之前的笔记 struct Node {Item item; struct Node * next;} ... }; 由于结构是一种其成员在默认情况下为共有的类, 所以Node实际上是一个嵌套类.
在之前的笔记中创建Node对象的方法是这么写的:
bool Queue::enqueue(const Item &amp;amp; item) { if(isfull()) return false; Node * add = new Node; add-&amp;gt;item = item; add-&amp;gt;next = NULL: ... } 现在我们将Node由struct改为嵌套类:
class Queue { // 嵌套类 class Node { public: Item item; Node * next; // 构造函数, 将item赋值为i, next指针设置为0, 也就是空值指针 Node(const Item &amp;amp; i): item(i), next(0) {} }; ... }; 然后, 重新使用构造函数编写enqueue():
bool Queue::enqueue(const Item &amp;amp; item) { if(isfull()) return false; Node * add = new Node(item); ... } 这个例子中是在类声明中定义了构造函数, 假设想在方法文件中定义构造函数, 则定义必须指出Node类是在Queue类中定义的, 我们可以通过两次作用域解析运算符来完成:
Queue::Node::Node(const Item &amp;amp; i): item(i), next(0) {} 嵌套类和访问权限 首先.嵌套类的声明位置决定了嵌套类的作用域, 即它决定了程序的那些部分可以创建这种类的对象.
其次.嵌套类的共有部分, 保护部分和私有部分控制了对类成员的访问.
1.作用域 如果嵌套类是在另一个类的私有部分声明的, 则只有后者知道它. 前面的例子中Node就是这种情况, 虽然Node没有明确写是private的, 但是默认就是private的. 因此Queue成员可以使用Node对象和指向Node对象的指针, 但是程序的其他部分不知道存在Node类, 对于从Queue派生而来的类, Node也是不可见的, 因为派生类不能直接访问基类的私有部分.
如果嵌套类是在另一个类的保护部分声明的, 则它对于后者可见, 但是对于外部世界是不可见的. 但是这种情况中, 派生类是知道嵌套类的, 并可以直接创建这种类型的对象.
如果嵌套类是在另一个类的共有部分声明的, 则允许后者, 后者的派生类以及外部世界使用它, 因为它是共有的. 然而, 由于嵌套类的作用域为包含它的类, 因此在外部世界使用它时, 必须使用类限定符.
假设有如下的声明:
class Team { public: class Coach {...}; ... }; 如果要在Team外面创建Coach对象, 可以这么写:
Team::Coach forhire; 表15.1 嵌套类、结构和枚举的作用域特征
   声名位置 包含他的类是否能使用 从包含它的类派生而来的类 在外部类     私有部分 是 否 否   保护部分 是 是 否   公有部分 是 是 是，通过限定符来使用    2.访问控制 对嵌套类的访问控制规则与常规类相同. 在Queue类声明中声明Node类并没有赋予Queue类的访问特权, 也没有赋予Node类任何对Queue类的访问特权. 因此Queue类对象只能显示的访问Node对象的公有成员。
类声明的位置决定了类的作用域或可见性, 类可见后, 访问控制规则(共有, 保护, 私有, 友元)将决定程序对嵌套类成员的访问权限。
模板中的嵌套 模板类中同样可以使用嵌套类
异常 异常是相对较新的C&#43;&#43;功能，有些老式编译器可能没有实现。另外有些编译器可能默认关闭这一特性，需要使用编译器选项来打开它。
这里先讨论一个基本问题：
2.0 * x * y / (x&#43;y) 如果y是x的负值，则上述公式将导致被零除。这是一种不允许的运算。很多新式编译器通过生产一个表示无穷大的特殊浮点值来处理。
例如Inf,inf,INF等。
调用abort() 对于这种问题，处理方式之一就是，如果其中一个参数是另一个参数的负值，则调用abort()函数。
Abort()函数的原型位于头文件cstdlib中，其典型实现是向标准错误流发送消息abnormal program termination(程序异常终止)，然后终止程序。
它还返回一个随实现而异的值，告诉操作系统，实现失败。
abort()函数是否刷新文件缓冲区取决于实现。
如果愿意，也可以使用exit()，该函数刷新文件缓冲区，但不显示消息。
文件缓冲区：用于存储读写到文件的数据的内存区域。
#error1.cpp --using the abort() function #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; double hmean(double a, double b); int main() { double x,y,z; std::cout&amp;lt;&amp;lt;&amp;#34;Enter two numbers:&amp;#34;; while() { z=hmean(x,y); std::cout&amp;lt;&amp;lt;&amp;#34;Harmonic mean of&amp;#34;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;#34;and&amp;#34;&amp;lt;&amp;lt;y &amp;lt;&amp;lt;&amp;#34;is&amp;#34;&amp;lt;&amp;lt;z&amp;lt;&amp;lt;std:endl; std::cout&amp;lt;&amp;lt;&amp;#34;Enter next set of numbers&amp;lt;q to quit&amp;gt;:&amp;#34;; } std::cout&amp;lt;&amp;lt;&amp;#34;Bye!\n&amp;#34;; return 0; } double hmean(double a, double b) { if(a == -b) { std::cout&amp;lt;&amp;lt;&amp;#34;untenable arguments to hmean()\n&amp;#34;; std::abort(); } return 2.0*a*b/(a&#43;b); } 为了避免异常终止，程序应在调用hmean()函数之前检查x和y的值。然而，依靠程序员来执行这种检查是不安全的。
返回错误码 一种比异常终止更灵活的办法是，使用函数的返回值来指出问题。
例如，ostream类的get(void)成员通常返回下一个输入字符的ASCII码，但到达文件尾时，将返回EOF。
对hmean()来说，这种方法不管用。任何数值都是有效的返回值，因此不存在可以指出问题的特殊值。
在这种情况下，可以使用指针参数或引用参数来将值返回给调用程序，并使用函数的返回值来指出成功还是失败。
iostream族重载&amp;gt;&amp;gt;运算符使用了这个技术的变体。通过告知调用程序是成功了还是失败了，使得程序可以采取除异常终止程序之外的其他措施。
下列程序就是采用这种方法，它将hmean()的返回值重新定义为bool，让返回值指出成功了，还是失败了。另外还给该函数增加了第三个参数，用于提供答案。
//error2.cpp --returning an error code #include&amp;lt;iostream&amp;gt; #include&amp;lt;cfloat&amp;gt; //(or float.h) for DBL_MAX bool hmean(double a, double b, double * ans); int main() { double x, y, z; std::cout&amp;lt;&amp;lt;&amp;#34;Enter two numbers: &amp;#34;; while(std::cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y) { if(hmean(x,y,&amp;amp;z)) std::cout&amp;lt;&amp;lt;&amp;#34;Harmonic mean of &amp;#34;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;#34; and &amp;#34;&amp;lt;&amp;lt; y &amp;lt;&amp;lt;&amp;#34; is &amp;#34;&amp;lt;&amp;lt;z&amp;lt;&amp;lt;std::end; else std::cout&amp;lt;&amp;lt;&amp;#34;One value should not be the negative&amp;#34; &amp;lt;&amp;lt;&amp;#34;of the other- try again.\n&amp;#34;; } std::cout&amp;lt;&amp;lt;&amp;#34;Bye!\n&amp;#34;; return 0; } bool mean(double a, double b, double * ans) { if(a == -b) { *ans =DBL_MAX; return false; } else { *ans = 2.0 * a * b / (a&#43;b); return true; } } 这个程序设计避免了错误输入导致的恶果，让用户能够继续输入。
当然，设计确实依靠用户检查函数的返回值。这项工作不是程序员经常做的。
第三个参数可以是指针或引用。很多程序员都倾向于使用指针，因为这样可以明显看出是哪个参数用于提供答案。
另外一种在某个地方存储返回条件的方法是使用一个全局变量。
可能出现问题的函数可以在出现问题时将该全局变量设置为特定的值，而调用程序可以检查该变量。
异常机制 下面介绍如何使用异常机制来处理错误。
C&#43;&#43;异常是对程序运行过程中发生的异常情况的一种响应。异常提供了将控制权从程序的一部分传递到另一部分的途径。
对异常的处理有3个组成部分：
 引发异常 &amp;mdash;-throw 使用处理程序捕获异常 &amp;mdash;- catch 使用try块。 &amp;mdash;- try  程序在出现问题时将引发异常，例如之前的hmean()，使之引发异常，而不是调用abort()函数。
throw()语句实际上是跳转，即命令程序跳到另一条语句。
throw关键字表示引发异常，紧随其后的值指出来异常的特征。
程序使用异常处理程序（exception handler）来捕获异常，异常处理程序位于要处理问题的程序中。catch关键字表示捕获异常。处理程序以catch关键字开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型；然后是用花括号括起来的代码段，指出要采取的措施。
catch关键字和异常类型用作标签，指出当异常被引发时，程序应跳到这个位置执行。
异常处理程序也被称为catch块。
try块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个catch块。try块是由关键字try指示的。
关键字try的后面是一个由花括号括起来的代码块，表明需要注意这些代码引发的异常。
了解这三个关键字是如何协同工作的，最简单的方法是看下面一个例子：
// error3.cpp -- using an exception #include &amp;lt;iostream&amp;gt; double hmean(double a, double b); int main() { double x, y, z; std::cout &amp;lt;&amp;lt; &amp;#34;Enter two numbers: &amp;#34;; while (std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y) { try { // start of try block z = hmean(x,y); } // end of try block catch (const char * s) // start of exception handler { std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;Enter a new pair of numbers: &amp;#34;; continue; } // end of handler std::cout &amp;lt;&amp;lt; &amp;#34;Harmonic mean of &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34; and &amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &amp;#34; is &amp;#34; &amp;lt;&amp;lt; z &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;Enter next set of numbers &amp;lt;q to quit&amp;gt;: &amp;#34;; } std::cout &amp;lt;&amp;lt; &amp;#34;Bye!\n&amp;#34;; return 0; } double hmean(double a, double b) { if (a == -b) throw &amp;#34;bad hmean() arguments: a = -b not allowed&amp;#34;; return 2.0 * a * b / (a &#43; b); } 上面那个程序，如果在try块中调用hmean()，将无法处理异常。
引发异常的语句：throw &amp;ldquo;bad hmean() arguments; a= -b not allowed&amp;rdquo;; 这个语句异常类型是字符串。
执行throw语句，类似于执行返回语句，因为它也将终止函数的执行；
但throw不是讲控制权返回给调用程序，而是将程序沿函数调用序列后退，直到找到包含try块的函数。
catch块类似于函数定义，但并不是函数定义。关键字catch表明这是一个处理程序，而 char * s 表明该处理程序与字符串的异常匹配。
s与函数参数定义极其类似，因为匹配的引发将被赋给s。
另外，当异常与该处理程序匹配时，程序将执行括号中的代码。
执行完try块后，如果没有引发任何异常，将跳过后面的catch块，直接执行处理程序后面的第一条语句。
整个过程为：
 程序在try块中调用hmean() hmean()引发异常，将从而执行catch块，并将异常字符串赋给s catch块返回到while循环的开始位置  这里可能有个疑问，如果函数引发了异常，而没有try块或者没有匹配的处理程序时，将会发生什么情况。
在默认情况下，程序最终会调用abort()函数，但可以修改这种行为。
将对象用作异常类型 通常，引发异常的函数将传递一个对象。这样做的重要优点之一就是，可以利用不同的异常类型来区分不同的函数在不同的情况下引发的异常。
对象可以携带信息，程序员可以根据这些信息来确定异常的原因。
同时，catch块可以根据这些信息来决定采取什么样的措施。
下面是针对函数引发的异常而提供的一种设计：
class bad_hmean { private: double v1; double v2; public: bad_hmean(int a =0, int b=0):v1(a), v2(b) {} void mesg(); }; inline void bad_hmean::mesg() { std::cout&amp;lt;&amp;lt;&amp;#34;hmean(&amp;#34;&amp;lt;&amp;lt;v1&amp;lt;&amp;lt;&amp;#34;,&amp;#34;&amp;lt;&amp;lt;v2&amp;lt;&amp;lt;&amp;#34;):&amp;#34; &amp;lt;&amp;lt;&amp;#34;invalid arguments: a = -b\n&amp;#34;; } 可以将bad_hmean对象初始化为传递给含税hmean()的值，而方法mesg()可用于报告问题。
函数hmean()可以使用如下代码：
if (a == -b) throw bad_hmean(a,b); 上述代码调用构造函数bad_hmean()，以初始化对象，使其存储参数值。
接下来看一个新的例子：
添加了一个新的异常类bad_gmean，类bad_gmean中的函数gmean()计算两个数的几何平均值，即乘积的平方根。
bad_hmean()和bad_gmean()使用的技术不一样，
bad_gmean()使用的是公有方法和公有数据，该方法返回一个C-风格字符串；
异常规范和C&#43;&#43;11 异常规范的理念看似有前途，但实际的使用效果并不好。
忽视异常规范之前，您至少应该知道它是什么样的，如下所示：
double harm(double a) throw(bad_thing); //may throw bad_thing exception double harm(double a) throw(); //doesn&amp;#39;t throw an exception 其中throw()部分就是异常规范，它可能出现在函数原型和函数定义中，可包含类型列表，也可不包含。
异常规范的另一个作用是，让编译器添加执行运行阶段检查的代码，检查是否违反了异常规范。
这很难检查；
marm()可能不会引发异常，但它可能调用一个函数，而这个函数调用的另一个函数引发了异常。
另外，您给函数编写代码时它不会引发异常，但库更新后它却会引发异常。
总之，编程社区达成的意见是不要使用这个功能。
栈解退 假设try块没有直接调用引发异常的函数B，而是调用了对引发异常的函数B进行调用的函数A，即A调用了B。
则程序流程将从引发异常的函数B跳到包含try块和处理程序的函数。这涉及到栈解退。
首先要了解C&#43;&#43;是如何处理函数调用和返回的。C&#43;&#43;通常通过将信息放到栈中来处理函数调用。
具体来说，程序将调用函数的指令和地址（返回地址）放到栈中。
当被调用的函数执行完毕后，程序将使用该地址来决定从哪里开始继续执行。
另外函数调用将函数A参数放到栈中。在栈中这些函数参数被视为自动变量。
如果被调用函数B创建了新的自动变量，则这些变量也将被添加到栈中。
如果被调用函数B调用了另一个函数C，则函数C的信息也将被添加到栈中。以此类推；
当函数C结束时，程序流程将跳到该函数C被调用时存储的地址（返回地址）处，同时栈顶的元素被释放。
因此函数都通常返回到调用它的函数处，同时每个函数都在结束时释放器自动变量。
如果自动变量是类对象，则类的析构函数（如果有的话）也将被调用。
现在假设函数由于出现异常（而不是由于return）而终止，则程序也将释放栈中的内存。
但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块中的返回地址。
随后控制权将转移到位于try块尾的异常处理程序，而不是函数调用后面的第一条语句。
这个过程就被称为栈解退。
和函数返回一样，对于栈中的自动类对象，类的析构函数将被调用。
然而函数返回仅仅处理该函数放在栈中的对象。
而throw语句则处理try块和throw之间整个函数调用序列放在栈中的对象。
其他异常特性 throw-catch机制类似于函数参数和函数返回返回机制，但还是有些不同：
 函数func()中的返回语句将控制权返回到调用func()的函数，但throw语句将控制权向上返回到第一个这样的函数：包含能够捕获相应异常的try-catch组合。
 引发异常时，编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。
  class problem {...}; ... void super() throw(problem) { ... if (1) { problem opps; //construct object throw opps; // throw it //or use this func throw problem(); //construct and throw default problem object } ... } try { super(); }; catch(problem &amp;amp; p) { //statements } 此处p将指向opp的副本，而不是p本身。这是件好事，因为函数super()执行完毕后，opps将不复存在。
同时此处catch捕捉异常对象的引用还有一个重要特征：基类引用可以执行派生类对象。假设有一组通过继承关联起来的异常类型，则在异常规范中只需列出一个基类引用，它将于任何派生类对象匹配。由于这个特性，当如果有一个异常类继承层次结构，应当这样排列catch块：将捕获位于层次结构最下面的异常类的catch语句放在最前面，将捕获基类异常的catch语句放在最后面。
也可以创建捕获对象而不是引用的处理程序。在catch语句中使用基类对象时，将捕获所有的派生类对象，但派生特性将被剥去，因此将统一使用虚方法的基类版本。
可以在不知道异常类型的情况下，捕获异常，方法是：使用省略号来表示异常类型，从而捕获任何异常。
catch(...){//statements} 如果知道一些异常的类型，可以将捕获所有异常的catch块放在最后面，这一点优点类似于switch语句中的default：
try { super(); }; catch(bad_case1 &amp;amp;be) {//...} catch(bad_case2 &amp;amp;be) {//...} catch(bad_case3 &amp;amp;be) {//...} catch(...) {//statements} exception类 exception头文件定义了exception类，C&#43;&#43;可以把它用作其他异常的基类。代码可以引发exception异常，也可以将exception类作为基类。
有一个名为what()的虚拟成员函数，它返回一个字符串，该字符串的特征随实现而异。然而，由于这是一个虚方法，因此可以再exception派生类中重新定义它。
 stdexcept异常类  定义了，logic_error和runtime_error类，他们都是从exception类公有派生出来的。
这些类的构造函数接受一个string对象作为参数，作为方法what()的返回数据。
logic_error公有派生出4个类：
 domain_error; invalid_argument; length_error; out_of_bounds;  runtime_error公有派生出3个类：
 range_error; overflow_error; underflow_error;  他们之间的主要区别在于：可以根据不同的类名分别处理每种异常。另一方面，由于是继承关系也可以一起处理它们(如果愿意的话)。
 bad_alloc异常和new  new导致的内存分配问题，C&#43;&#43;的处理方式是让new引发bad_alloc异常。头文件new包含bad_alloc类的声明，它是exception类公有派生而来的。但在以前，当无法分配请求的内存量时，new返回一个空指针。
 空指针和new  很多代码都是在new失败时返回空指针时编写的。
为处理new的变化，有些编译器提供了一个标记（开关），让用户选择所需的行为。
当前，C&#43;&#43;标准提供了一种在失败时返回空指针的new，其用法如下
int * pi = new (std::nothrow) int; int * pa = new (std::nowthrow) int[500]; 使用这种new，可将上面程序的核心代码修改如下：
Big * pb; pb = new(std::nothrow) Big [10000]; if(pb ==0) { cout&amp;lt;&amp;lt;&amp;#34;Could not allocate memory. Bye.\n&amp;#34;; exit(EXIT_FAILURE); } 异常、类和继承 异常、类和继承以3种方式向关联：
 可以像C&#43;&#43;库那样，从一个异常类派生出另一个；
 可以在类定义中嵌套异常类声明，来组合异常；
 这种嵌套声明本身可以被继承，还可以用作基类。
  异常何时会迷失方向 异常被引发后，在两种情况下会引发问题：
如果它是在带异常规范的函数中引发的，则必须与规范列表中的某种异常匹配，否则称为意外异常。
如果异常不是在函数中引发的(或者函数没有异常规范)，则必须捕获它。如果没有捕获，则异常被称为未捕获异常。
总之，如果要捕获所有的异常(不管事预期异常还是意外异常)，则可以这样做：
首先确保异常头文件的声明可用：
#include &amp;lt;exception&amp;gt; using namespace std 然后设计一个替代函数，将异常转换为bad_exception异常，该函数的原型如下：
void myUnexpected() { throw std::bad_exception(); } 接下来在程序的开始位置，将意外异常操作指定为调用该函数：
set_unexpected(myUnexpected); 最后，将bad_exception类型包括在异常规范中，并添加如下catch块序列：
double Argh(double,double)throw(out_of_range,bad_exception); ... try { x = Argh(a,b); } catch (out_of_range&amp;amp; e) { ... } catch (bad_exception&amp;amp; e) { ... } 有关异常的处理事项 RTTI RTTI的用途 假如，有一个类层次结构，其中的类都是从同一个基类派生而来的，利用多态性，则基类指针或者引用可以指向任意一个派生类对象。但如何知道指针指向的是哪种对象呢？可能有三种情况：
 该类层次结构中所有的成员都拥有虚函数，则基类指针可以根据所指对象的类型，调用相应派生类的方法。
 派生对象可能包含不是继承而来的方法，这种情况下，只有某些类型的对象可以使用该方法。
 也可能是出于调试的目的，想跟踪生成的对象的类型。
  对于后两种情况，RTTI提供解决方案。
RTTI工作原理 C&#43;&#43;有3个支持RTTI的元素：
 如果可能的话，dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则该运算符返回0&amp;mdash;空指针。
 typeid运算符返回一个指出对象的类型的值。
 type_info结构存储了有关特定类型的信息。
  只能将RTTI用于包含虚函数的类层次结构，原因在于只有对这种类层次结构，才应该将派生对象的地址赋给基类指针。
 dynamic_cast运算符  dynamic_cast不能回答“指针指向的是哪类对象”，但能够回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题。
通常，如果指向的对象(*pt)的类型为Type或者是从Type直接或者间接派生而来的类型，则下面的表达式将指针pt转换为类型为Type类型的指针：
dynamic_cast&amp;lt;Type *&amp;gt; (pt) 否则，结果为0，即空指针。
也可以将dynamic_cast用于引用，其用法稍微有点不同：没有与空指针对应的引用值，因此无法使用特殊的引用值来只是失败。当请求不准确时，dynamic_cast将引发类型为bad_cast的异常，这种异常是从exception类派生而来的，它是在头文件typeinfo中定义的。因此可以像下面这样使用该运算符，其中rg是对Grand对象的引用，Superb是从Grand派生出的对象：
#include &amp;lt;typeinfo&amp;gt; ... try { Superb &amp;amp; rs = dynamic_cast&amp;lt;Superb &amp;amp;&amp;gt; (rg); } catch (bad_cast &amp;amp;) { ... };  typeid运算符和type_info类  typeid运算符是的能够确定两个对象是否为同种类型。它与sizeof有些相似，可以接受两种参数：
 类名 结果为对象的表达式  typeid运算符返回一个type_info对象的引用，其中，type_info是在头文件type_info中定义的一个类。type_info重载了==和！=运算符，以便可以使用这些运算符来对类型进行判断。例如，如果pg执行的是一个Superb对象，则下述表达式的结果为bool值true，否则为false：
typeid(Superb) == typeid(*pg) 如果pg是一个空指针，程序将引发bad_typeid异常。该异常类型是从exception类派生而来的，是在头文件typeinfo中声明的。
type_info类实现随厂商而异，但包含一个name()成员，该函数返回一个随实现而异的字符串：通常(但并非一定)是类名。例如，下面的语句显示指针pg指向的对象所属类定义的字符串：
cout::typeid(*pg).name()&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; 类型转换运算符 四种类型转换运算符，他们的语法相同：
 dynamic_cast，语法：dynamic_cast (expression) const_cast，语法：const_cast (expression) static_cast，语法：static_cast (expression) reinterpret_cast，语法：reinterpret_cast (expression)  dynamic_cast运算符 dynamic_cast运算符在前面已经介绍过了，假设High和Low是两个类，而ph和pl的类型分别为High *和Low *。
则仅当Low是High的可访问基类时，下面的语句才将一个Low*指针赋给pl：
pl = dynamic_cast&amp;lt;Low *&amp;gt; ph; 该运算符的用途是，使得能够在类层次结构中进行向上转换（由于是is-a关系，这种转换是安全的），而不允许其他转换。
（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
（2）不能用于内置的基本数据类型的强制转换。
（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
（4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。
基类中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。
这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见）中，只有定义了虚函数的类才有虚函数表。
（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
向上转换，即为子类指针指向父类指针（一般不会出问题）；
向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。
在C&#43;&#43;中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。
const_cast运算符 const运算符用于执行只有一种用途的类型转换。即改变值为const或volatile，其语法与dynamic_cast运算符相同：
如果类型的其他方面也被修改，则上述类型的转换将出错。
也就是说除了const和volatile特征可以不同外，type_name和expression的类型必须相同。
再次假设High和Low是两个类：
High bar; const High * pbar = &amp;amp;bar; ... High * pb = const_cast&amp;lt;High *&amp;gt; (pbar); //valid const Low * pl = const_cast&amp;lt;const Low *&amp;gt; (pbar); //invalid 第一个类型转换使得*pb成为一个可用于修改bar对象值的指针，它删除const标签。
第二个类型转换是非法的，因为它同时尝试将类型从const High*改为const Low*。
提供该运算符的原因是，有时候可能需要这样一个值，它在大多数时候是常量，而有时又是可修改的。
在这种情况下，可以将这个值声明为const，并在需要修改它的时候，使用const_cast。
需注意const_cast可以修改指向一个值的指针，但不可以修改const值。
void change(const int * pt) { int * pc; pc = const_cast&amp;lt;int *&amp;gt;(pt); *pc = 100; } int main() { int pop1 = 38383; const int pop2 = 2000; change(&amp;amp;pop1); change(&amp;amp;pop2); return 0; } 在change()中，指针pt被声明为const int *，因此不能用来修改指向的int。指针pc删除了const特诊，因此可以用来修改指针指向的值，但仅当指向的不是const时才行，因此，pc可用于修改pop1的值，但不能修改pop2的值。
static_cast运算符 static_cast运算符仅当type_name可被隐式转换为expression所属的类型或expression可被隐式转换为type_name所属的类型时，上述转换才是合法的，否则将会出错。
假设High是Low的基类，而Pond是一个无关的类，则从High到Low的转换，从Low到High的转换都是合法的，而从Low到Pond的转换时不允许的。
High bar; Low blow; ... High *pb = static_cast&amp;lt;High *&amp;gt;(&amp;amp;blow); //valid Low *pl = static_cast&amp;lt;Low *&amp;gt;(&amp;amp;bar); //valid Pond *pb = static_cast&amp;lt;Pond *&amp;gt;(&amp;amp;blow); //invalid,Pond unrelated 它主要有如下几种用法： * 用于类层次结构中基类和派生类之间指针或引用的转换 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的 进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的 * 用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证 * 把空指针转换成目标类型的空指针 * 把任何类型的表达式转换为void类型 注意：static_cast不能转换掉expression的const、volitale或者__unaligned属性。
reinterpret_cast运算符 reinterpret_cast用于天生危险的类型转换,主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。
reinterpret_cast不支持所有类型的转换，如不能将指针类型转换为更小的整型或浮点型，不能将函数指针转换为数据指针，反之亦然。
</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; primer plus 第14章C&#43;&#43;中的代码重用</title>
        <url>http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC14%E7%AB%A0c&#43;&#43;%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/</url>
        <categories>
          <category>C&#43;&#43;</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> C&#43;&#43; primer plus 第14章C&#43;&#43;中的代码重用
[toc]
C&#43;&#43;的主要目的是促进代码重用。
公有继承是实现这一目标的机制之一；
本身是另一个类的成员，这种方法称为包含、组合、层次化。
另一种方法是使用私有、保护继承。
通常包含、私有继承和保护继承用于实现has-a关系，即新的类型包含另一个类的对象。
多重继承使得能够使用两个或更多的基类派生出新的类，将基类的功能组合在一起。
还有类模板——另一种重用代码的方法。类模板能够使用通用术语定义类，然后使用模板来创建针对特定类型定义的特殊类。例如，可以定义一个通用的栈模板，然后使用该模板创建一个用于表示int值栈的类和一个用于表示double值栈的类。
包含对象成员的类 对于姓名可以使用字符数组来表示，但这将限制姓名的长度。当然，还可以使用char指针和动态内存分配，但这要求提供大量的支持代码。有一个好的方法就是使用一个他人开发好的类的对象来表示。如果C&#43;&#43;库提供了合适的类，实现起来将更简单。姓名可以采用string类。而对于考试分数，存在类似的选择，可以使用一个定长数组，还可以采用C&#43;&#43;库提供的一个这样的类，它就是valarray。
valarray类简介 valarray是一个模板类，模板类在使用时需要指定具体数据类型。
valarray&amp;lt;int&amp;gt; q_values; //an array of int valarray&amp;lt;double&amp;gt; weights; //an array of double valarray类的构造函数和其他类方法举例如下：
double gps[5]={3.1, 3.5, 3.8, 2.9, 3.3}; valarray&amp;lt;double&amp;gt; v1; //double类型的空数组 valarray&amp;lt;int&amp;gt; v2(8); //长度为8的整型元素。 valarray&amp;lt;int&amp;gt; v3(10,8); //长度为8的整型元素，每个长度为10。 valarray&amp;lt;double&amp;gt; v4(gpa,4) //使用gpa数组的前4个元素给v4赋值。 valarray&amp;lt;int&amp;gt; v5 = {20,32,17,9}; //C&#43;&#43;11使用初始化列表进行初始化 下面是这个类的一些方法：
operator[]() 能够访问各个元素； size() 返回包含的元素数 xum() 返回所有元素的总和 max() 返回最大的元素 min() 返回最小的元素 Student类的设计 class Student { private: string name; valarray&amp;lt;double&amp;gt; scores; … }; Student类获得了其成员对象的实现，但没有继承接口。这意味着Student类成员函数可以使用string和valarray类的公有接口来访问和修改name和scores对象。但在类外不能这样做，而只能通过Student类的公有接口访问name和scores。
接口与实现的概念
获得接口是is-a关系的组成部分。
而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。
对于has-a关系而言，类对象不能获得包含对象的接口是一件好事。
Student类示例 //studentc.h--defining a Student class using containment #ifndef STUDENTC_H_ #define STUDENTC_H_ #include &amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;valarray&amp;gt; class Student { private: typedef std::valarray&amp;lt;double&amp;gt; ArrayDb; std::string name; ArrayDb scores; std::ostream &amp;amp; arr_out(std::ostream &amp;amp; os) const; public: Student():name(&amp;#34;Null Student&amp;#34;),scores() {} explicit Student(const std::string &amp;amp; s):name(s),scores() {} explicit Student(int n):name(s), scores() {} Student(const std::string &amp;amp; s, int n):name(s),scores(n) {} Student(const char * str, const double *pd, int n):name(str),scores(pd,n) {} ~Student() {} double Average() const; const std::string &amp;amp; Name() const; double &amp;amp; operator[] (int i); double operator[] (int i) const; //friend friend std::istream &amp;amp; operator&amp;gt;&amp;gt;(std::istream &amp;amp; is, Student &amp;amp; stu); friend std::istream &amp;amp; getline(std::istream &amp;amp; is, Student &amp;amp; stu); friend std::ostream &amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp; os, const Student &amp;amp; stu); } #endif 注意：如果不使用explicit，可以编写如下的代码：
Student doh(&amp;#34;Homer&amp;#34;,10); doh = 5;  粗心的程序员键入了doh而不是doh[0]，这会导致使用构造函数调用Student（5）将5替换为一个临时Student对象，并使用&amp;quot;Nully&amp;quot;来设置成员name的值。因此赋值操作将使用临时对象来替换原来doh值，使用了explicit之后，编译器将认为上述运算符是错误的。
C&#43;&#43;和约束
使用explict防止但参数构造函数的隐式转换，使用const限制方法修改数据。这样做的根本原因是：在编译阶段出现错误优于在运行阶段出现错误。
 初始化被包含的对象  构造函数使用您熟悉的成员初始化列表来初始化name和score成员对象。
Queue::Queue(int qs) : qsize(qs) {…} 还可以使用成员初始化列表来初始化派生对象的基类部分：
hasDMA::hasDMA(): baseDMA(hs) {…} 初始化列表中的每一项都调用与之匹配的构造函数。
初始化顺序：当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。
 使用被包含对象的接口  被包含对象的接口不是公有的，但可以在类方法中使用它。
私有继承 使用包含：易于理解，类声明中包含表示被包含类的显式命名对象，代码可以通过名称引用这些对象；
使用继承：将使关系更抽象，且继承会引起很多问题，尤其是从多个基类继承时。
私有继承所提供的特性确实比包含多。
通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。
使用包含还是私有继承 通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护乘员，或需要重新定义虚函数，则应使用私有继承。
14.2.3 保护继承 保护继承：基类的公有成员和保护成员都将成为派生类的保护成员。
私有继承与保护继承的区别，在第三代继承中就体现出来了。使用私有继承时，第三代类不能使用基类的接口，因为公有方法在派生类中将变成私有方法；使用保护继承时，基类的公有方法在第二代中将变成受保护的，因此第三代派生类可以使用它们。
使用using重新定义访问权限 （在继承提供了一种机制来对基类公有方法的访问权限的控制，属性的改变）：使用保护派生或私有派生时，基类的公有成员将成为保护成员或私有成员。
假设要让基类的方法在派生类中可用，可以有两种方法：
1）定义一个使用该基类方法的派生类方法：
double Student::sum() const { return std::valarray&amp;lt;double&amp;gt;::sum(); } 2）将函数调用包装在另一个函数调用中：
在类声明中使用using；
class Student:private std::string, private std::valarray&amp;lt;double&amp;gt; { … public: using std::valarray&amp;lt;double&amp;gt;::min; using std::valarray&amp;lt;double&amp;gt;::max; ... } using声明使得valarray类的min，max方法可用，就像是Student类的公有方法一样；
而且注意使用using声明时，只使用成员名，没有圆括号，函数特征标，返回类型。
Using声明只适用于继承，而不适用与包含。
多重继承 继承使用时要注意，默认是私有派生。所以要公有派生时必须记得加关键字Public来限定每一个基类。
class SingingWaiter : public Waiter, Singer {...}; //Singer是私有派生 MI（Multi Inheritance）会带来哪些问题？以及如何解决它们？
两个主要问题：
 从两个不同的基类继承同名方法； 从两个或更多相关基类那里继承同一个类的多个实例；  有多少Worker Worker公有派生出Singer和Waiter；
然后Singer和Waiter公有派生出SingingWaiter（即多重继承）；
这样会导致一个问题，就是SingingWaiter中有两个Worker组件。通常可以将派生类对象的地址赋值给基类指针。但是在这样的情况下这么做的话，将出现二义性。所以必须使用类型转换来指定对象。但这又增加了指针引用的复杂度。C&#43;&#43;在引入多重继承的同时，也引入新技术——虚基类，来解决该问题。
 虚基类  虚基类也用关键字virtual，虚基类与虚函数之间并不存在明显的联系。这么做是为了给程序员减少压力，类似于关键字的重载。
虚基类使得从多个类（他们的基类相同）派生出的对象只继承一个基类对象。例如使用关键字virtual，可以使Worker被用作Singer和Waiter的虚基类。
class Singer: virtual public Worker{…}; class Waiter: public virtual Worker{…}; (virtual和public的次序无关紧要) 现在SingingWaiter对象将只包含Worker对象的一个副本，从本质上说，继承的Singer和Waiter对象共享一个Worker对象。
那么为什么不使虚行为成为MI的默认准则呢？
在一些情况下，可能需要基类的多个拷贝；
将基类作为虚的要求程序完成额外的计算，为不需要的程序付出代价是不应当的；
 新的构造函数规则  使用虚基类时，必须对构造函数采用新的方法；
对于非虚基类，唯一可以出现在初始化列表中的构造函数是即时基类构造函数。
A派生B，B派生C；&amp;mdash;&amp;gt;C类的构造函数只能调用B类的构造函数，B类的构造函数只能调用A类构造函数。
但对于虚基类而言，这种信息自动传递方式不可用。这是因为对于多重继承而言，信息传递将通过两条不同的途径。为避免这种冲突，当基类是虚的，将禁止信息通过中间类自动传递给基类。
这就要求显式地调用所需的基类构造函数：
SingingWaiter(参数列表):Worker(wk),Waiter(wk,p),Singer(wk,v) { } 上述格式对虚基类来说是合法的，对非虚基类来说是非法的。
警告：如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。
哪个方法 对于单继承，如果没有重新定义show，将调用最近祖先中的show定义。对于多重继承，如果每个祖先都有一个Show函数，那么会导致函数调用的二义性。
有几种解决方法：
 使用作用域解析运算符来澄清编程者的意图； 或是在多重继承的类中重新定义show方法，并指出要使用哪个show；  这种递增的方法对于单继承来说是有效的；
但是对于多重继承来说，还是有问题：
SingingWaiter：：Show { Singer::Show(); Waiter::Show(); } //这将显示姓名和ID两次。 该如何解决呢？使用模块化方法，而不是递增的方法；即提供一个只显示worker组件的方法，提供一个只显示waiter组件及singer组件的方法。
将所有数据组件都设置为保护的方法，而不是私有的，可以更严格地控制对数据的访问；
如果数据组件的方法是保护的，则只能在继承层次结构中的类中使用它，在其他地方则不能使用。
MI小结 MI会增加编程的复杂度。然而，这种复杂度主要是由于派生类通过多条途径继承同一个基类引起的。
 当派生类使用关键字virtual来指示派生时，基类就称为了虚基类。其构造函数的规则有所变化，不会自动进行信息不换传递，需要显式地调用基类构造函数。
 通过优先规则解决名称二义性。如果一个类从两个不同的类那里继承了两个同名的成员，则需要在派生类中使用类限定符来区分它们。否则，编译器将指出二义性。
 有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，这对于间接非虚基类来说是非法的。
  类模板 如果两种类只是数据类型不同，而其他代码是相同的，与其编写新的类声明，不如编写一种泛型（独立于类型的）栈。然后将具体的类型作为参数传递给这个类。这样就可以使用通用的代码生成存储不同类型值的栈。
可以使用typedef处理这样的需求，但是有两个问题，一、每次修改类型都必须重新编辑头文件；二、在每个程序中都只能使用这种技术生成一种栈。
C&#43;&#43;的类模板为生成通用的类声明提供了一种更好的方法；模板提供参数化类型，能够将类型名作为参数传递给接收方来建立类或函数。
C&#43;&#43;标准模板库（STL）提供了几种功能强大而灵活的容器类模板。
定义类模板 template &amp;lt;class Type&amp;gt; template告诉编译器，将要定义一个模板。尖括号内容相当于函数的参数列表。
也可以这么写：
template &amp;lt;typename Type&amp;gt; 或是： template &amp;lt;class T&amp;gt; template &amp;lt;typename T&amp;gt; 当模板被调用时，Type将被具体的类型值（int或string）取代。
原来类的声明：
typedef unsigned long Item; class Stack { private: enum {MAX = 10}; Item items[MAX]; int top; public: Stack( ); bool isempty( ) const; bool isfull( ) const; bool push (const Item &amp;amp; item); bool pop(Item &amp;amp; item); } 类模板信息必须都放在头文件中，不能把模板成员函数放到独立的实现文件中。因为模板不是函数，不能单独编译。在要使用这些模板的文件中包含该头文件。
类模板：
template&amp;lt;class Type&amp;gt; Stack&amp;lt;Type&amp;gt;::Stack() { } template &amp;lt;class Type&amp;gt; bool Stack&amp;lt;Type&amp;gt;::isempty() { } template &amp;lt;class Type&amp;gt; bool Stack&amp;lt;Type&amp;gt;::isfull() { } template &amp;lt;class Type&amp;gt; bool Stack&amp;lt;Type&amp;gt;::push(const Type &amp;amp; item) { } template &amp;lt;class Type&amp;gt; bool Stack&amp;lt;Type&amp;gt;::pop(Type &amp;amp; item) { } 使用模板类 仅在程序包含模板并不能生成模板类，而必须请求实例化。需要声明一个类型为模板类的对象，并且使用所需的具体类型替换泛型名。
Stack&amp;lt;int&amp;gt; kernels; Stack&amp;lt;string&amp;gt; colonels; 看到上述两个声明后，编译器将按Stack&amp;lt;Type&amp;gt;模板来生成两个独立的类声明和两组独立的类方法。
泛型标识符——Type——被称为类型参数，这意味着它类似于变量，但是赋给它们的不能是数字，而只能是类型。
必须，显式地提供所需的类型，这与常规的函数模板是不同的。
深入探讨模板类 可以将内置类型或对象作为类模板Stack&amp;lt;Type&amp;gt;的类型。指针也是可以的。但是如果不对程序做重大修改，将无法很好地工作。
创建不同的指针是调用程序的职责，而不是栈的职责。栈的任务是管理指针，而不是创建指针。
字符串本身永远不会移动，把字符串压入栈实际上是新建一个指向该字符串的指针，即创建一个指针，该指针的值是现有字符串的地址。
构造函数使用new创建一个用于保存指针的数组，析构函数删除该数组，而不是数组元素指向的字符串。
数组模板示例和非类型参数 常用作容器类，这是因为类型参数的概念非常适合于将相同的存储方案用于不同的类型。引入模板的主要动机是：容器类可提供重用的代码。
深入探讨模板设计和使用的其他几个方面。
具体来说，探讨一些非类型（或表达式）参数以及如何使用数组来处理继承族。
实现一种允许指定数组大小的简单数组模板：
方法一：在类中使用动态数组和构造函数参数来提供元素数目(旧方法)
方法二：使用模板参数来提供数组的大小；
模板头：templateclass 关键字标识这是类型参数，int指出n的类型为int，这是非类型参数，或表达式参数；
表达式参数有一些限制：可以是整型，枚举，引用或指针。
表达式参数的优点：使用自动变量维护内存栈，而不是用构造函数方法使用的new，delete来管理内存。
表达式参数的缺点：下面的声明将生成两个独立的类声明；
ArrayTP&amp;lt;double, 12&amp;gt; eggweights; ArrayTP&amp;lt; double, 13&amp;gt; eggweights; 而构造函数的方法，就只要一份类声明。
另一个区别是：构造函数的方法更通用。数组大小是作为类数据成员存储在定义中。
模板多功能性 模板的作用：
 用作基类 用作组件类 用作其他模板的类型参数 数组模板实现栈模板 数组模板来构造数组   递归使用模板
 使用多个类型参数
  template&amp;lt;class T1, class T2&amp;gt;  默认类型模板参数  可以为类型参数提供默认值；
template&amp;lt;class T1, class T2=int&amp;gt; 类模板：类型参数可提供默认值；
函数模板的类型参数不可提供默认值；
非类型参数：类模板，函数模板都可以提供默认值；
模板的具体化 模板以泛型的方式描述类；
而具体化是使用具体的类型生成类声明；
1、 隐式实例化
是指在需要对象之前，不会生成类；
ArrayTP&amp;lt;double,30&amp;gt; * pt; //一个指针，还没有对象被创建 pt = new ArrayTP&amp;lt;double,30&amp;gt;; //创建一个对象 2、 显式实例化
template class ArrayTP&amp;lt;string,100&amp;gt;; //会产生一个类的实例，声明一个类； 虽然没有创建或提及类对象，编译器也将生成类声明。
3、 显式具体化
指的是特定类型的定义。
4、部分具体化
成员模板 模板可用作结构、类或模板类的成员。
类的成员（数据，方法）都可以用模板表示；
而不仅仅是类用模板表示；
模板之中有模板，嵌套的；还可以在模板之外定义方法模板，成员模板；
将模板用作参数 将模板用作模板的参数；
模板包含类型参数和非类型参数：
template &amp;lt;template &amp;lt;typename T&amp;gt; class Thing&amp;gt; 其中template &amp;lt;typename T&amp;gt; class Thing是模板的参数；
其中template &amp;lt;typename T&amp;gt; class是参数模板（把模板作为参数用）的类型；
假设有以下声明：
Crab&amp;lt;King&amp;gt; legs; Crab&amp;lt;King&amp;gt;是模板Crab具体的类型；模板参数是King，King也必须是一个模板类。
template &amp;lt;typename T&amp;gt; class King {…}; 模板类和友元 模板类声明也可以有友元。（友元：模板or非模板， 约束or非约束）
 非模板友元； 约束模板友元，即友元的类型取决于类被实例化时的类型； 非约束模板友元，即友元的所有具体化都是类的每一个具体化的友元；  1、 模板类的非模板友元函数
在模板类中将一个常规函数声明为友元：
template &amp;lt;class T&amp;gt; class HasFriend { public: friend void counts(); }; counts()函数成为模板所有实例化的友元。例如，它将是类HasFriend&amp;lt;int&amp;gt;和HasFriend&amp;lt;string&amp;gt;的友元。该友元与所有模板实例化的对象都具有友元关系（一对多）。该函数不是通过对象调用，没有对象参数。
template &amp;lt;class T&amp;gt; class HasFriend { public: friend void report(HasFriend&amp;lt;T&amp;gt; &amp;amp;); }; 这一种带模板类参数的友元。这是一种一对一的友元关系，即该友元只是某个具体类型的模板的友元函数。
2、 模板类的约束模板友元函数
3、 模板类的非约束模板友元函数
普通类&#43;普通友元 （一对一）友元-类而言
普通类&#43;模板友元 （多对一）友元-类而言
模板类&#43;普通友元 （一对多）友元-类而言
模板类&#43;模板友元 （多对多）友元-类而言
模板别名（C&#43;&#43;11）</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; primer plus 第13章类继承</title>
        <url>http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC13%E7%AB%A0%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
        <categories>
          <category>C&#43;&#43;</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> C&#43;&#43; primer plus 第13章类继承
[toc]
一个简单得基类 从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
派生一个类 class RatedPlayer :public TableTennisPlayer { } 冒号指出RatedPlayer 类的基类是TableTennisPlayer类。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将称为派生类的一部分，但是只能通过基类的公有和保护方法访问。
 派生类对象存储了基类得数据成员（派生类继承了积累的实现） 派生类对象可以使用基类的方法（派生类继承了基类的接口）  需要在继承特性中添加什么呢？
 派生类需要自己的构造函数 派生类可以根据需要添加额外的数据成员和成员函数。  构造函数：访问权限的考虑 派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。因此派生类构造函数必须使用基类构造函数；
创建派生类对象时，程序首先创建基类对象。从概念上讲，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C&#43;&#43;使用成员初始化列表来完成这种工作。
RatedPlayer::RatedPlayer(unsigned int r, const string &amp;amp; fn, const string &amp;amp; ln, bool ht):TableTennisPlayer(fn,ln,ht) { rating = r; } 如果省略了基类构造函数的话：
RatedPlayer::RatedPlayer(unsigned int r, const string &amp;amp; fn, const string &amp;amp; ln, bool ht) { rating = r; } 首先还是创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数。
因此上述代码与下面等效：
RatedPlayer::RatedPlayer(unsigned int r, const string &amp;amp; fn, const string &amp;amp; ln, bool ht):TableTennisPlayer() { rating = r; } 除非要使用默认构造函数，否则应该显式调用正确的基类构造函数。
还有一种构造函数代码：
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &amp;amp; tp):TableTennisPlayer(tp) { rating = r; } 这里也是将TableTennisPlayer的信息传递给了TableTennisPlayer构造函数。
这种方式将调用基类的复制构造函数，如果基类没有定义复制构造函数，但又要使用它，则编译器将自动生成一个。
甚至还可以对派生类成员使用成员初始化列表语法：
RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &amp;amp; tp):TableTennisPlayer(tp)，rating(r) { } 派生类构造函数的要点总结：
 首先创建基类对象； 派生类构造函数应通过成员初始化列表(TableTennisPlayer(tp))将基类信息传递给基类构造函数； 派生类构造函数应初始化派生类新增的数据成员(rating = r)  释放对象的顺序与创建对象的顺序相反：首先执行派生类的析构函数，然后自动调用基类的析构函数。
使用派生类 使用派生类，程序必须要能够访问基类声明。可以把两个类的声明放在同一个头文件中，也可以放在不同的头文件中。
派生类和基类之间的特殊关系 派生类可以使用基类的方法，条件是方法不是私有的。
基类指针可以在不进行显式类型转换的情况下指向派生类对象。基类引用可以在不进行显式类型转换的情况下引用派生类对象。但是基类指针和引用只能调用基类的方法。
C&#43;&#43;中要求引用和指针类型与赋予的类型匹配，但这一规则对继承来说是例外。这例外是单向的，也就是说不能将基类对象和地址赋给派生类引用和指针。
这样要求是有道理的：如果允许基类引用隐式地调用派生类方法，则可以使用基类引用为派生类对象调用基类的方法。因为派生类继承了基类的方法，所以这样做不会有问题。
如果可以将基类对象赋给派生类引用，将发生什么情况？派生类引用能够为基类对象调用派生类方法，这是没有意义的。例如TableTennisPlayer没有rating成员。
继承：is-a关系 多态公有继承 有时候希望同一个方法在派生类和基类中的行为是不同的。换句话说，方法的行为取决于调用该方法的对象。这种较复杂的行为称为多态——具有多种形态。即同一种方法其行为随上下文而异。有两种重要的机制可用于实现多态公有继承：
 在派生类中重新定义基类的方法。 使用虚方法。  如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。注意virtual只用在声明中，不能用在定义中。
虚方法的演示：
假设要同时管理Brass和BrassPlus账户，如果能使用同一个数组来保存Brass和BrassPlus对象，将很有帮助。这是可能的使用指向Brass类型的指针，就能保证这个数组来表示多种类型的对象，又保证数组的元素都是同一种类型的。这样由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象，也可以指向BrassPlus对象。
为何要使用虚析构函数：
如果析构函数不是虚的话，则将只调用对应指针类型的析构函数。
虚方法就是给引用或指针调用对象时根据对象的类型确定调用哪个方法而设计的。不加virtual的话，就会根据引用或指针的类型调用方法了，这就容易造成一些问题。
静态联编和动态联编 程序调用函数时，将使用哪个可执行代码块呢？编译器负责回答这个问题。
将源代码中的函数调用解释为特定的函数代码块被称为函数名联编（binding）。
在C语言中，这非常简单，因为每个函数名对应一个不同的函数。
但是在C&#43;&#43;中由于函数重载的缘故，这项任务非常复杂。编译器必须查看函数参数才能确定使用哪个函数。编译器可以在编译过程中完成联编，这被称作静态联编，又称为早期联编。然而，虚函数使这项工作变得更加困难。使用哪个函数不是在编译时就能确定的，因为编译器不知道用户将选择哪个类型的对象。所以编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编，又称为晚期联编。
指针和引用类型的兼容性 将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting）。这使公有继承不需要进行显式类型转换。该规则是is-a关系的一部分。
相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换（downcasting）。如果不使用显式类型转换，向下强制转换是不允许的。
is-a关系是不可逆的，派生类可以新增数据成员，因此使用这些数据成员的类成员函数不能应用于基类。
虚成员函数和动态联编 编译器对非虚方法使用静态联编。对虚方法采用动态联编。
 为什么有两种类型的联编以及为什么默认为静态联编？  这涉及到效率和概念模型。为了使程序能够在运行阶段进行决策，必须采用一些方法跟踪基类指针或引用指向的对象类型，这增加了额外的的处理开销。例如，如果这个类不用做基类，则不需要动态联编。如果派生类不重新定义基类的任何方法，也不需要使用动态联编。这些情况下使用静态联编更合理，效率也更高。因此被设置为C&#43;&#43;的默认选择。C&#43;&#43;的指导原则之一就是不要为不使用的特性付出代价（内存或处理时间）。仅当程序确实需要虚函数时，才使用它们。
概念模型：仅将那些预期被重新定义的方法声明为虚的。如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。在设计类时，方法属于哪种情况有时候并不那么明显。与现实世界中的很多方面一样，类设计并不是一个线性过程。
 虚函数的工作原理  有关虚函数的注意事项  在基类方法的声明中使用关键字virtual可使该方法在基类以及所有派生类（包括从派生类派生出来的类）当中都是虚的。
 如果使用指向对象的指针或引用来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。
 如果定义的类将被用作基类，则应该将那些要在派生类中重新定义的类方法声明为虚的。
   构造函数  构造函数不能是虚函数，因为调用构造函数是明确的，创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数。然后，派生类的构造函数将调用基类的构造函数，这种顺序不同于继承机制。派生类不继承基类的构造函数，所以将派生类的构造函数声明为虚的没什么意义。
 析构函数  基类的析构函数必须是虚函数，除非不用作基类，因为这样编译器才知道调用对象类型对应的析构函数，而不是指针或引用类型对应的析构函数。通常应该给基类提供一个虚析构函数，即使它不需要析构函数。
 友元  友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数。
 没有重新定义  如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。
 重新定义将隐藏方法  class Dwelling { public: virtual void showperks(int a) const; }; class Hovel :public Dwelling { public: virtual void showperks() const; }Hovel trump; trump.showperks(); //valid trump.showperks(5); //invalid 新定义将showperks()定义为一个不接受任何参数的函数。重新定义不会生成函数的两个重载版本。
载版本，而是隐藏了接受一个int参数的基类版本。总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法。
总结两条经验：
1、如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变。因为允许返回类型随类类型的变化而变化。
2、 如果基类声明被重载了，则应该在派生类中重新定义所有基类版本。如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。
访问控制：protected public和private来控制对类成员的访问。
还存在另外一个访问类别，这种类别用关键字protected表示。protected和private相似，在类外只能用公有类成员来访问protected部分中的类成员。但是它们之间的区别体现在基类派生的类中。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。对于外部世界来说，保护成员的行为和私有成员相似。但对于派生类来说，保护成员的行为与公有成员相似。
保护访问控制的好处是，让派生类能够访问公众不能使用的内部函数。最好对数据成员采用私有访问控制，不要使用保护访问控制，同时通过基类方法使派生类能够访问基类数据。
使用保护数据成员可以简化代码的编写工作，但存在设计缺陷，就是派生类如果把继承的保护数据成员的修改方式写到公有成员函数里，这样通过派生类的成员函数来访问该保护成员，这样实际上使得该保护数据成员成为公有变量。
抽象基类 abstract base class，ABC 抽象基类
有时候is-a规则并不像看上去那么简单，例如圆和椭圆的关系。圆是椭圆的特殊情况。椭圆可以派生出圆。但是椭圆的数据成员及方法对于圆来说是信息冗余。圆类继承椭圆类会显得很繁琐。
如果把圆和椭圆分开定义，这种方法效率不高，因为它忽略了圆类和椭圆类的许多共同点。
还有一种方法：将圆和椭圆的共性抽象出来，放到ABC中，再由ABC派生出圆类和椭圆类。这样便可以使用基类指针数组同时管理圆类和椭圆类对象。即可以使用多态方法。
例如圆和椭圆的共同点是中心坐标，Move()方法（对于这两个类来说是相同的）和Area()方法（对于这两个类来说是不同的）。Area()方法不能在ABC中实现，没有包含必要的数据成员，C&#43;&#43;通过使用纯虚函数提供未实现的函数。在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。
纯虚函数的结尾为=0；
class BaseEllipse { private: double x; double y; public: BaseEllipse(double x0=0,double y0=0):x(x0),y(yo){} virtual ~BaseEllipse() {} void Move(int nx, ny) {x=nx; y=ny} virtual double Area() const=0; //a pure virtual function } 如果一个类定义了纯虚函数的话，则这个类无法创建该类的对象。包含纯虚函数的类属于基类，要成为真正的ABC，必须至少包含一个纯虚函数。原型中使用=0使虚函数称为纯虚函数。
BaseEllipse类是Ellipse类和Circle类的基类，后两者都是具体类（concrete）。
如果要设计类继承层次，则只能将那些不会被用作基类的类设计为具体的类。这种方法的设计更清晰，复杂程序更低。
可以将ABC看作是必须实施的接口。ABC要求具体派生类覆盖其纯虚函数——迫使派生类遵循ABC设置的接口规则。这种模型在基于组件的编程模式中很常见。使用ABC使得组件设计人员能够制定“接口约定”，这样确保了从ABC派生的所有组件都至少支持ABC指定的功能。
继承和动态内存分配 如果基类使用动态内存分配，并重新定义赋值和复制构造函数，这将怎样影响派生类的实现？这个问题的答案取决于派生类的属性。如果派生类也使用动态内存分配，那就需要注意学习新的小技巧。
第一种情况：派生类不适用new //Base Class Using DMA class baseDMA { private: char * label; int rating; public: baseDMA(const char * l =&amp;#34;null&amp;#34;, int r=0); baseDMA(const baseDMA &amp;amp; rs); virtual ~baseDMA(); base DMA &amp;amp; operator =(const baseDMA &amp;amp; rs); ... }; //derived class without DMA class lacksDMA : public baseDMA { private: char color[40]; public: ... } 派生类不使用new，不需要定义显式的析构函数，因为我们假设lackDMA成员不需执行任何特殊操作，所以默认析构函数时合适的。
复制构造函数：默认复制构造函数执行成员复制，这对于动态内存分配来说是不合适的，但对于新的lacksDMA成员来说是合适的。LacksDMA类的默认复制构造函数使用显式baseDMA复制构造函数来复制lackDMA对象的baseDMA部分。因此，默认复制构造函数对于新的lackDMA成员来说是合适的，同时对于继承的baseDMA对象来说也是合适的。
对于赋值来说，也是如此。类的默认赋值运算符将自动使用基类的赋值运算符对基类组件进行赋值。因此，默认赋值运算符也是合适的。
派生类对象的这些属性也适用于本身就是对象的类成员。
第二种情况：派生类使用new 这种情况下，必须为派生类定义显式析构函数，赋值构造函数和赋值运算符。
//derived class with DMA class hasDMA:public baseDMA { private: char * style; public: ... } 派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。因此，hasDMA析构函数必须释放指针style管理的内存，并依赖于baseDMA的析构函数来释放指针label管理的内存。
baseDMA::~baseDMA() // takes care of baseDMA stuff { delete [] label; } hasDMA::~hasDMA() // takes care of hasDMA stuff { delete [] style; } 接下来看复制构造函数。BaseDMA的复制构造函数遵循用于
baseDMA::baseDMA(const baseDMA &amp;amp; rs) { label = new char[std::strlen(rs.label)&#43;1]; std::strcpy(label,rs.label); rating = rs.rating; } hasDMA复制构造函数只能访问hasDMA的数据，因此它必须调用baseDMA复制构造函数来处理共享的baseDMA数据：
hasDMA::hasDMA(const hasDMA &amp;amp; hs) :baseDMA(hs) { style = new char[std::strlen(hs.style)&#43;1]; std::strcpy(style, hs.style); } 需要注意一点是，成员初始化列表将一个hasDMA引用传递给baseDMA构造函数。
接下来看赋值运算符。BaseDMA赋值运算符遵循下述常规模式：
baseDMA &amp;amp; baseDMA::operator=(const baseDMA &amp;amp; rs) { if (this == &amp;amp;rs) return *this; delete [] label; label = new char[std::strlen(rs.label)&#43;1]; std::strcpy(label, rs.label); rating = rs.rating; return *this; } hasDMA &amp;amp; hasDMA::operator=(const hasDMA &amp;amp; hs) { if(this == &amp;amp;hs) return *this; baseDMA::operator=(hs); delete [] style; style = new char[std::strlen(hs.style)&#43;1]; std::strcpy(style,hs.style); return *this; } 以下语句看起来有点奇怪：
baseDMA::operator=(hs); 但通过使用函数表示法，而不是运算符表示法，可以使用作用域解析运算符。实际上该语句的含义如下：
*this = hs; 当基类和派生类都采用动态内存分配时，派生类的析构函数，复制构造函数，赋值运算符都必须使用相应的基类方法处理基类元素。
但这种要求是通过三种不同的方式来满足的。
对于析构函数：这是自动完成的；
对于构造函数：这是通过在初始化成员列表中调用基类的复制构造函数来完成的；
对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的；
类设计回顾 编译器生成的成员函数 编译器会自动生成一些公有的成员函数——特殊成员函数。
1、 默认构造函数
提供构造函数的动机之一是确保对象总能被正确地初始化。如果类包含指针成员，则必须初始化这些成员。最好提供一个显式默认构造函数，将所有的类数据成员都初始化为合理的值。
如果定义了某种构造函数，编译器将不会定义默认构造函数。如果没有定义任何构造函数，编译器将定义默认构造函数。
默认构造函数要么没有参数，要么所有的参数都有默认值。
2、 复制构造函数
复制构造函数接受其所属类的对象作为参数。例如，Star类的复制构造函数的原型如下：
Star(const Star &amp;amp;); 在下述情况下，将使用复制构造函数：
 将新对象初始化为一个同类对象； 按值将对象传递给函数； 函数按值返回对象； 编译器生成临时对象；  3、 赋值运算符
初始化和赋值不是一回事；
Star sirius; Star alpha = sirius; //initialization 初始化 Star dogstar; dogstar = sirius; //assignment 赋值 默认的赋值运算符用于处理同类对象之间的赋值；
如果需要显式定义复制构造函数，基于相同的原因，也需要显式定义赋值运算符。
其他的类方法 1、构造函数
构造函数不同于其他类方法，因为它创建新的对象。而其他类方法知识被现有的对象调用。这是构造函数不被继承的原因之一。
2、析构函数
一定要定义显式析构函数来释放类构造函数使用new分配的所有内存，并完成类对象所需的任何特殊的清理工作。对于基类，即使它不需要析构函数，也应提供一个虚析构函数。
3、转换
4、按值传递对象与传递引用
编写使用对象作为参数的函数时，应将参数声明为const引用。这样可以提高程序运行的效率。
按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义为接受基类引用参数的函数可以接受派生类。
5、返回对象和返回引用
返回对象需要生成临时副本，这就要调用复制构造函数来生成副本和调用析构函数来删除副本。
返回引用可以节约内存空间和时间，但是并不总是要返回引用。如果函数返回在函数中创建的临时对象，则不要使用引用，例如返回两个对象相加的临时对象时不返回引用。
6、使用const
使用const来确保方法不修改调用它的对象。
公有继承的考虑因素 在程序中使用继承，有很多问题需要注意。
1、is-a关系
必须是is-a关系，无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象。
2、什么不能被继承
构造函数、析构函数、赋值运算符；都不可以；
3、赋值运算符
如果编译器发现程序将一个对象赋给同一个类的另一个对象，它将自动为这个类提供一个赋值运算符。
4、私有成员与保护成员
对于派生类而言，保护成员类似于公有成员。
但对于外部而言，保护成员与私有成员类似。
派生类可以直接访问基类的保护成员，但只能通过基类的成员函数来访问私有成员。
5、虚方法
设计基类时，必须确定是否将类方法声明为虚的。如果希望派生类能够重新定义方法，则应在基类中将方法定义为虚的。这样可以启动动态联编。
6、析构函数
基类的析构函数应当是虚的。这样，当通过通过对象的基类指针或引用来删除派生对象时，程序将首先调用派生类的析构函数，然后调用基类的析构函数，而不仅仅是调用基类的析构函数。
7、友元函数
友元函数并非类成员，因此不能被继承。
8、有关使用基类方法的说明
以公有方式派生的类的对象可以通过多种方式来使用基类的方法。
 派生类对象自动使用继承而来的基类方法，如果派生类没有重新定义该方法； 派生类的构造函数自动调用基类的构造函数； 派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数； 派生类构造函数显式地调用成员初始化列表中指定的基类构造函数； 派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法； 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针；  类函数小结 见书P530表13.1
</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; primer plus 第12章类和动态内存分配</title>
        <url>http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC12%E7%AB%A0%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
        <categories>
          <category>C&#43;&#43;</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> C&#43;&#43; primer plus 第12章类和动态内存分配
[toc]
动态内存和类 C&#43;&#43;在分配内存时是让程序在运行时决定内存分配，而不是在编译时决定。这样，可根据程序的需要，而不是根据一系列严格的存储类型规则来使用内存。C&#43;&#43;使用new和delete运算符来动态控制内存。
复习示例和静态类成员 这个程序使用了一个新的存储类型：静态类成员：
//strngbad.h #include&amp;lt;iostream&amp;gt; #ifndef STRNGBAD_H_ #define STRNGBAD_H_ class StringBad { private: char * str; //指向字符串的指针 int len; //字符串的长度 static int num_strings; //对象个数 public: StringBad(const char * s); //构造函数 StringBad(); //默认构造函数 ~StringBad(); //析构函数 //友元函数 friend std::ostream &amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp; os, const StringBad &amp;amp; st); }; #endif 首先，它使用char指针（而不是char数组）来表示姓名。这意味着类声明没有为字符串本身分配存储空间，而是在构造函数中使用new来为字符串分配空间。 这避免了在类声明中预先定义字符串的长度。
其次，将num_strings成员声明为静态存储类。 静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。 也就是说，类的所有对象共享同一个静态成员。 假设创建了10个StringBad对象，将有10个str成员和10个len成员，但只有一个共享的num_strings成员。这对于所有类对象都具有相同值的类私有数据是非常方便的。 例如，num_strings成员可以记录所创建的对象数目。
//strngbad.cpp #include&amp;lt;cstring&amp;gt; #include&amp;#34;strngbad.h&amp;#34; using std::cout; //初始化静态类成员 int StringBad::num_strings = 0; //类方法 //以C字符型构造StringBad StringBad::StringBad(const char * s) { len = std::strlen(s); //设置长度 str = new char[len &#43; 1]; //分配内存 std::strcpy(str, s); //初始化指针 num_strings&#43;&#43;; //设置对象数量 cout &amp;lt;&amp;lt; num_strings &amp;lt;&amp;lt; &amp;#34;: \&amp;#34;&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;#34;\&amp;#34; object created\n&amp;#34;; } StringBad::StringBad() //默认构造函数 { len = 4; str = new char[4]; std::strcpy(str, &amp;#34;C&#43;&#43;&amp;#34;); //默认字符串 num_strings&#43;&#43;; cout &amp;lt;&amp;lt; num_strings &amp;lt;&amp;lt; &amp;#34;: \&amp;#34;&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;#34;\&amp;#34; default object created\n&amp;#34;; } StringBad::~StringBad() //必要的析构函数 { cout &amp;lt;&amp;lt; &amp;#34;\&amp;#34;&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;#34;\&amp;#34; object deleted, &amp;#34;; --num_strings; //有要求 cout &amp;lt;&amp;lt; num_strings &amp;lt;&amp;lt; &amp;#34; left\n&amp;#34;; delete[] str; //有要求 } std::ostream &amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp; os, const StringBad &amp;amp; st) { os &amp;lt;&amp;lt; st.str; return os; } 程序中使用了下面语句：
int StringBad::num_strings = 0; 注意： 不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。 对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。
注意： 静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态类成员所属的类。但如果静态成员是const整数类型或枚举型，则可以在类声明中初始化。
析构函数：str成员指向new分配的内存。当StringBad对象过期时，str指针也将过期。但str指向的内存仍被分配，除非使用delete将其释放。删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句可确保对象过期时，由构造函数使用new分配的内存被释放。
当类对象作为函数参数值传递时，析构函数将被调用。
另外，下面的代码：
StringBad sailor= sports; 这使用的是哪个构造函数呢？不是默认构造函数，也不是参数为const char*的构造函数。记住，这种形式的初始化等效于下面的语句：
StringBad sailor = StringBad(sports); //使用sports的构造函数 因为sports的类型为StringBad，因此相应的构造函数原型应该如下：
StringBad(const StringBad &amp;amp;); 当您使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）。自动生成的构造函数不知道需要更新静态变量num_string，因此会将计数方案搞乱。 实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的。
特殊成员函数 StringBad类的问题是由特殊成员函数引起的。 这些成员函数是自动定义的，就StringBad而言，这些函数的行为与类设计不符。 具体地说，C&#43;&#43;自动提供了这些成员函数：
 默认构造函数，如果没有定义构造函数； 默认析构函数，如果没有定义； 复制构造函数，如果没有定义； 赋值运算符，如果没有定义； 地址运算符，如果没有定义。   默认构造函数：  如果没有提供任何构造函数，C&#43;&#43;将创建默认构造函数。 例如，加入定义了一个Klunk类，但没有提供任何构造函数，则编译器将提供下述默认构造函数：
Klunk::Klunk() { } //隐式默认构造函数 Klunk lunk; //调用默认构造函数 默认构造函数使Lunk类似于一个常规的自动变量，也就是说，它的值在初始化时是未知的。
如果定义了构造函数，C&#43;&#43;将不会定义默认构造函数。 如果希望在创建对象时不显式地对它进行初始化，则必须显式地定义默认构造函数。这种构造函数没有参数，但可以使用它来设置特定地值：
Klunk::Klunk() //显式默认构造函数 { klunk_ct=0; … } 带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。 例如，Klunk类可以包含下述内联构造函数：
Klunk(int n = 0) {klunk_ct = n;} 但只能有一个默认构造函数。 也就是说，不能这样做：
Klunk() {klunk_ct = 0;} //构造函数#1 Klunk(int n =0) {klunk_ct=n;} //具有二义性的构造函数#2 例如：
Klunk kar(10); //明确地与#1匹配 Klunk bus; //与两个构造函数均可匹配 第二个声明既与构造函数#1（没有参数）匹配，也与构造函数#2（使用默认参数0）匹配。
 复制构造函数  复制构造函数用于将一个对象复制到新创建的对象中。 类的复制构造函数的原型如下：
Class_name(const Class_name &amp;amp;); 它接受一个指向类对象的常量引用作为参数。 例如，StringBad类的复制构造函数原型如下 ：
StringBad(const StringBad &amp;amp;); 对于复制构造函数，需要知道两点：何时调用和有何功能。
 何时调用复制构造函数  新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。 这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有地对象。例如，假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数：
StringBad ditto(motto); //调用StringBad(const StringBad &amp;amp;) StringBad metoo = motto; //调用StringBad(const StringBad &amp;amp;) StringBad also = StringBad(motto); //调用StringBad(const StringBad &amp;amp;) StringBad * pStringBad = new StringBad(motto); ////调用StringBad(const StringBad &amp;amp;) 每当程序生成了对象副本时，编译器都将使用复制构造函数。由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。
 默认的复制构造函数的功能  默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。
StringBad sailor = sports; 与下面代码等价（由于私有成员是无法访问的，因此这些代码不能通过便于）：
StringBad sailor; sailor.str=sports.str; sailor.len=sports.len; 如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。 静态函数（如num_strings）不受影响，因为它们属于整个类，而不是各个对象。
复制构造函数哪里出了问题 当callme2()被调用时，复制构造函数被用来初始化callme2()的形参，还被用来将对象sailor初始化为对象sports。 默认的复制构造函数不说明其行为，因此它不指出创建过程，也不增加计数器num_strings的值。但析构函数更新了计数，并且在任何对象过期时都将被调用，而不管对象是如何被创建的。 这是一个问题，因为这意味着程序无法准确地记录对象计数。 解决方法是提供一个对计数进行更新地显式复制构造函数：
StringBad::StringBad(const StringBad &amp;amp; s) { num_strings&#43;&#43;; ... } 解决类设计种这种问题的方法时进行深度复制（deep copy）。 也就是说，复制构造函数应当复制字符串并将副本的地址赋给str成员，而不仅仅是复制字符串地址。 这样每个对象都有自己的字符串，而不是引用另一个对象的字符串。 调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。可以这样编写String的复制构造函数：
StringBad::StringBad(const StringBad &amp;amp; st) { num_strings&#43;&#43;; //处理静态成员更新 len= st.len; //相同长度 str = new char[len &#43; 1]; //分配空间 std::strcpy(str,st.str); //将字符串复制到新位置 cout&amp;lt;&amp;lt; num_strings &amp;lt;&amp;lt; &amp;#34;:\&amp;#34;&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;#34;\&amp;#34; object created\n&amp;#34;; } 必须定义复制构造函数的原因在于，一些类成员是使用new初始化的、指向数据的指针，而不是数据本身。
赋值运算符 C&#43;&#43;允许类对象赋值，这是通过自动为类重载赋值运算符实现的。 这种运算符的原型如下：
Class_name &amp;amp; Class_name::operator=(const Class_name &amp;amp;); 它接受并返回一个指向类对象的引用。 例如，StringBad类的赋值运算符的原型如下：
StringBad &amp;amp; StringBad::operator=(constStringBad &amp;amp;);  赋值运算符的功能以及何时使用它:  StringBad headline1(“Celery Stalks atMidnight”); … StringBad knot; Knot = headline1; //赋值运算符被调用 初始化对象时，并不一定会使用赋值运算符：
StringBad metoo=knot; //可能使用复制构造函数，也可能是赋值运算符 这里，metoo是一个新创建的对象，被初始化为knot的值，因此使用复制构造函数。 然而，正如前面指出的，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中。这就是说，初始化总是会调用复制构造函数，而使用=运算符时也允许调用赋值运算符。
 解决赋值的问题  对于由于默认赋值运算符不合适导致的问题，解决办法时提供赋值运算符（进行深度复制）定义。 其实现与复制构造函数相似，但也有一些差别。
由于目标对象可能引用了以前分配的数据，所以函数应使用delete[]来释放这些数据。
函数应当避免将对象赋给自身；否则，对对象重新赋值前，释放内存操作可能删除对象的内容。
函数返回一个指向调用对象的引用。
StringBad &amp;amp; StringBad::operator=(const StringBad &amp;amp; st) { if (this == &amp;amp;st) //对象赋值给自身 return *this; //结束 delete[] str; //释放老字符串 len = st.len; str = new char[len &#43; 1]; //为新字符串开辟空间 std::strcpy(str,st.str); //复制字符串 return *this; } 如果地址相同，程序将返回*this，然后结束。 如果地址不同，函数将释放str指向的内存，这是因为稍后把一个新字符串的地址赋给str。 如果不首先使用delete运算符，则上述字符串将保留在内存中。赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值。
改进后的新String类 修订后的默认构造函数 String::String() { len = 0; str = new char[1]; //这是为了和类析构函数兼容； str[0] = ’\0’; } delete[ ]与使用new[ ]初始化的指针和空指针都兼容。空指针建议用nullptr表示：
str = nullptr; //C&#43;&#43;11的空指针表示法 以其他方式初始化的指针，使用delete[]时，结果将是不确定的。
比较成员函数 friend bool operator==(const String &amp;amp;st1, const String &amp;amp;st2); 将比较函数作为友元，有助于将String类对象与常规的C字符串进行比较。
if (&amp;#34;love&amp;#34; == answer) 将被转换为
if (operator==(&amp;#34;love&amp;#34;, answer)); 然后编译器将使用某个构造函数将代码转换为：
if (operator==(String(&amp;#34;love&amp;#34;), answer)); 使用中括号表示法访问字符 String opera(&amp;#34;The Magic Flute&amp;#34;); 对于表达式opera[4]，C&#43;&#43;将查找名称与特征标与此相同的方法；
String::operator[](int i) 如果找到匹配的原型，编译器将使用下面的函数调用来替代表达式opera[4]:
opera.operator[ ](4) opera对象调用该方法，数组下标4成为该函数的参数。
有了上述定义：
cout &amp;lt;&amp;lt;opera[4]; 被转换为：
cout &amp;lt;&amp;lt;opera.operator[4]; 返回值将是opera.str[4]。由此公有方法可以访问私有数据。
将返回类型声明为char &amp;amp;，便可以给特定元素赋值。
String means(&amp;#34;might&amp;#34;); means[0] = &amp;#39;r&amp;#39;; 第二条语句被转换为一个重载运算符函数调用：
means.operator[](0) = &amp;lsquo;r&amp;rsquo;;
这里将r赋给方法的返回值，上述代码等同于：
means.str[0] = &amp;#39;r&amp;#39;; 但在重载时，C&#43;&#43;将区分常量和非常量函数的特征标，因此可以提供另一个仅供const String对象使用的operator[]()版本。
静态类成员函数 可以将成员函数声明为静态的，函数声明必须包含关键字static。但如果函数定义是独立的，则其中不能包含关键字static，这样做有两个重要的后果。
首先，不能通过对象调用静态成员函数 ，实际上，静态成员函数甚至不能使用this指针。
如果静态成员函数是在公有部分声明的，则可以使用类名和作用域运算符来调用它。
例如：可以给String类添加一个名为HowMany()的静态成员函数，方法是在类声明中添加如下原型定义：
static int HowMany() {return num_strings;} 由于静态成员函数不与特定的对象相关联，只能使用静态数据成员。
可以使用静态成员函数设置类级标记，以控制某些类接口的行为，例如：类级标记可以控制显示类内容的方法所使用的格式。
进一步重载赋值运算符 在构造函数总使用new时应注意的事项 如果在构造函数中使用new来初始化对象的指针成员时必须特别小心。
 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。
 new和delete必须相互兼容。new对应于delete，new[ ]对应于delete[ ]。
 如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。可以再一个构造函数中使用new初始化指针，也可以在另一个构造函数中使指针为空。
 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。通常，这种构造函数与下面类似。
  String::String(const String &amp;amp; st) { num_string&#43;&#43;; len = st.len; str = new char [len&#43;1]; std::strcpy(str, st.str); }  应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象，  StringBad &amp;amp; StringBad::operator=(const StringBad &amp;amp; st) { if(this == &amp;amp;st) return *this delete [] str; len = st.len; str = new char [len&#43;1]; std::strcpy(str, st.str); return *this; } 应该和不应该 包含类成员的类的逐成员复制 class Magazine { private: String title; string publisher; ... }; String和string都使用动态内存分配，这是否意味着需要为Magazine类编写复制构造函数和赋值运算符？不，至少对这个类本身来说不需要。默认的逐成员复制和赋值行为有一定的智能。如果您将一个Magazine对象复制或赋值给另一个Magazine对象，逐成员复制将使用成员类型定义的赋值构造函数和赋值运算符。也就是说，复制成员title时，将使用String的复制构造函数，而将成员title赋给另一个Magazine对象时，将使用String赋值运算符，以此类推。
然而，如果Magazine类因其他成员需要定义复制构造函数和赋值运算符，情况将更加复杂；在这种情况下，这些函数必须显式地调用String和string的复制构造函数和赋值运算符，这将在第13章中介绍。
有关返回对象的说明 返回方式： * 返回指向对象的引用； * 返回指向对象的const引用； * 返回const对象；
 返回指向const对象的引用  使用const引用的常见原因是旨在提高效率，但对于何时可以采用这种方式存在一些限制。
假如要编写函数Max()，它返回两个Vector对象中较大的一个，其中Vector是第11章开发的一个类。
Vector force1(50, 60); Vector force2(10,70); Vector max; max = Max(force1, force2);//version 1 Vector Max(const Vector &amp;amp; v1, const Vector &amp;amp; v2) { if (v1.magval() &amp;gt; v2.magval()) return v1; else return v2; } //version 2 const Vector &amp;amp; Max(const Vector &amp;amp; v1, const Vector &amp;amp; v2) { if (v1.magval() &amp;gt; v2.magval()) return v1; else return v2; } 返回对象将调用复制构造函数，而返回引用不会。因此第二个版本所做的工作更少，效率更高。引用指向的对象应该在调用函数执行时同时存在。
注意v1和v2被声明为const引用，所以返回类型必须为const，这样才匹配。
 返回指向非const对象的引用   常用于两种情况：
 重载赋值运算符  Operator=()的返回值作用域连续赋值；
String s1(&amp;#34;Good stuff&amp;#34;); String s2,s3; s3=s2=s1; 上述代码中，s2.operator=()的返回值被赋给s3。为此，返回String对象或String对象的引用都是可行的。但是通过引用可以避免调用复制构造函数，提高效率。
 重载与cout连用的&amp;lt;&amp;lt;运算符  Operator&amp;lt;&amp;lt;()的返回值用于串接输出：
String s1(&amp;ldquo;Good stuff&amp;rdquo;);
cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; &amp;ldquo;is coming!&amp;rdquo;;
operator&amp;lt;&amp;lt;(cout, s1)的返回值成员一个用于显示字符串&amp;rdquo;is coming!&amp;ldquo;的对象。返回类型必须是ostream &amp;amp;，而不能仅仅是ostream。如果使用返回类型ostream，将要求调用ostream类的赋值构造函数，而ostream没有公有的赋值构造函数。幸运的是，返回一个指向cout的引用不会带来任何问题，因为cout已经在调用函数的作用域内。
返回对象 如果被返回的对象是被调用函数的局部变量，则不应该按引用方式去返回它，因为在被调用函数执行完毕时，局部对象将调用析构函数。因此，当控制权回到调用函数时，引用指向的对象将不再存在。在这种情况下，应返回对象而不是引用。
通常，被重载的算术运算符属于这一类。
Vector force1(); Vector force2(); Vector net; net = force1&#43;force2; 返回的不是force1，也不是force2，force1和force2在这个过程中应该保持不变。因此，返回值不能是指向在调用函数中已存在的对象的引用。相反，在Vector::operator&#43;()中计算得到的两个矢量和被存储在一个新的临时对象中，该函数也不应返回指向该临时对象的引用，而应该返回实际的Vector对象，而不是引用。
在这种情况下，存在调用复制构造函数来创建被返回的对象的开销，然而这时无法避免的。
返回const对象 前面的Vector::operator&#43;()的定义中有一个奇异的属性
net = force1 &#43;force2; //语句1 force1 &#43;force2 =net; //语句2 这种代码都可行，是因为复制构造函数将创建一个临时对象来表示返回值。因此，在前面的代码中，表达式force1&#43;force2的结果为一个临时对象。在语句1中，该临时对象被赋给一个net；在语句2中，net被赋给该临时对象。
如果您担心这种行为引发滥用。有个简单的解决方案，就是把返回类型声明为const Vector。那么语句2就非法了，因为返回对象无法被赋值，只能赋值给别人。
 总之，如果方法或函数要返回局部对象，就必须要返回对象，而不是返回对象的引用。这种情况下将使用赋值构造函数来生成返回的对象。这样的开销是不可避免的，也是必须的。
如果方法或函数要返回一个没有公有复制构造函数的类（例如ostream类）的对象，它必须返回一个指向这种对象的引用。
最后，有些方法和函数可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，因为其效率更高。
 使用指向对象的指针 再探new和delete new为创建的每一个对象的名称字符串分配存储空间，这是在构造函数中进行的；
析构函数使用delete来释放这些内存。
字符串是一个字符数组，所以析构函数使用的是带中括号的delete。使用new来为整个对象分配内存：
String * favorite = new String(saying[choice]); 这不是为要存储的字符串分配内存，而是为对象分配内存；也就是说，为保存字符串地址的str指针和len成员分配内存。
指针和对象小结  使用常规表示法来声明指向对象的指针：  String * glamour;  可以将指针初始化为指向已有的对象；  String * first = &amp;amp;saying[0];  可以使用new来初始化指针，这将创建一个新的对象  String * favorite = new String(sayings[choice]);  对类使用new将调用相应的类构造函数来初始化新创建的对象：  //调用默认构造函数 String * gleep = new String; //调用 String(const char *) 构造函数 String * glop = new String(&amp;#34;my my my&amp;#34;); //调用 String(const String &amp;amp;)构造函数 String * favorite = new String(saying[choice]);  可以使用-&amp;gt;运算符通过指针访问类方法：  if (saying[i].length()&amp;lt; shortest-&amp;gt;length())  可以对对象指针应用解除引用运算符（*）来获得对象  if (saying[i]&amp;lt;*first) first = &amp;amp;saying[i]; 再谈定位new运算符 这里说的定位new运算符，是一种相对于普通的new运算符，可以指定内存地址的运算符，程序直接使用我们提供的地址，不管它是否已经被使用，而且可以看到新值直接覆盖在旧值上面。
定位new运算符直接使用传递给它的地址，它不负责判断哪些内存单元已被使用，也不查找未使用的内存块。
char * buffer = new char[BUF]； JustTesting * pc1; pc1 = new (buffer) JustTesting; //定位new运算符 pc2 = new JustTesting(&amp;#34;Heap&amp;#34;, 20); pc3 = new (buffer &#43;sizeof(JustTesting)) JustTesting(&amp;#34;Better Idea&amp;#34;, 6); 使用定位new运算符来为对象分配内存，必须确保其析构函数被调用。如何确保呢?、对于在堆中创建的对象，可以这样做。
delete pc2; 但是对于pc1却不可以，原因在于delete可以与常规new运算符配合使用，却不能与定位new运算符配合使用。
Pc3没有收到new运算符返回的地址。因此delete pc3将导致运行阶段错误。
Delete pc1将释放buffer，而不是pc1；
系统没有为定位new运算符在该内存块中创建的对象调用析构函数。
对于这种情况，需要显式地为定位new运算符创建的对象调用析构函数。这是少数几个需要显式调用析构函数的情形。
pc3-&amp;gt;~JustTesting(); pc1-&amp;gt;~JustTesting();//销毁对象的顺序，先销毁后创建的对象。类似于栈的先进后出顺序。 仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。
复习各种技术 队列模拟 队列：是一种抽象的数据类型（Abstract Data Type），可以存储有序的项目序列。新项目被添加在队尾，并可以删除队首的项目。队列有些像栈。栈是在同一端进行添加和删除。这使得栈是一种后进先出的结构，队列是先进先出的。
问题：Heather银行要在Food Hea超市门口开设一个ATM机。Food Heap需要了解ATM对超市交通可能造成的影响。Heather银行希望对顾客排队等待的时间进行评估，编写一个程序模拟这种情况。
设计：设计一个队列类，队列中的项目是顾客。设计一个表示顾客的类，编写一个程序来模拟顾客和队列之间的交互。
队列类 队列的特征：
 队列能够存储有序的项目序列； 队列所能容纳的项目数有一定的限制； 应当能够创建空队列； 应当能够检查队列是否为空； 应当能够检查队列是否是满的； 应当能够在队尾添加项目； 应当能够在队首删除项目； 应当能够确定队列中的项目数；  总结 本章介绍了定义和使用类的许多重要方面。其中一些方面是非常微妙甚至是很难理解的。
在类构造函数中，可以使用new为数据分配内存。然后将内存地址赋给类成员。这样，类便可以处理长度不同的字符串，而不用在类设计时提前固定数组的长度。
在类构造函数中使用new，也可能在对象过期时引发问题。
如果对象包含成员指针，同时它指向的内存是由new分配的。则释放用于保存对象的内存并不会自动释放对象成员指针所指向的内存。因此在构造函数中使用new来分配内存时，应在类析构函数中使用delete来释放分配的内存。这样，当对象过期时，将自动释放其指针成员指向的内存。
如果对象包含指向new分配的内存的指针成员，则将一个对象初始化为另一个对象，或将一个对象赋给另一个对象时，也会出现问题。（浅复制），在默认情况下，C&#43;&#43;逐个对成员初始化和赋值，这意味着被初始化或被赋值的对象的成员将与原始对象完全相同。如果原始对象的成员指向一个数据块，则副本成员将指向同一个数据块。当程序最终删除这两个对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。
解决方法是：定义一个特殊的复制构造函数来重新定义初始化，并重载赋值运算符。在上述任何一种情况下，新的定义都将创建指向数据的副本，并使新的对象指向这些副本。这样，旧对象和新对象都将引用独立的，相同的数据，而不会重叠。由于同样的原因，必须定义赋值运算符。对于每一种情况，最终目的都是执行深度复制，也就是说，复制实际的数据，而不仅仅是复制指向数据的指针。
对象的存储持续性为自动或外部时，在它不再存在时将自动调用其析构函数。如果使用new运算符为对象分配内存，并将其地址赋给一个指针，则当您将delete用于该指针时将自动为该对象调用析构函数。
然而使用定位new运算符（而不是常规new运算符），为对象分配内存，必须显式地为该对象调用析构函数。方法是使用指向该对象的指针调用析构函数的方法。
C&#43;&#43;允许在类中包含结构、类和枚举定义。这些嵌套类型的作用域为整个类，这意味着它们被局限于类中，不会与其他地方定义的同名结构、类和枚举发生冲突。
C&#43;&#43;为类构造函数提供了一种可用来初始化数据成员的特殊语法。这种语法包括冒号和有逗号分隔的初始化列表。被放在构造函数参数的右括号后，函数体的左括号前。每个初始化器都有被初始化的成员的名称和包含初始值的括号组成。从概念上讲，这些初始化操作是在对象创建时进行的，此时函数体中的语句还没有被执行。语法如下：
Queue(int qs): qsize(qs), items(0), front(NULL), rear(NULL){ } 如果数据成员是非静态const成员或引用，则必须采用这种格式，但可将C&#43;&#43;11新增的类内初始化用于非静态const成员。
C&#43;&#43;允许类内初始化，即在类定义中进行初始化：
这与使用成员初始化列表等价。然而，使用成员初始化列表的构造函数将覆盖相应的类内初始化。
Class Queue { … private: Node * front = NULL; enum {Q_SIZE = 10}; node * rear = NULL; int items = 0; const int qsize =Q_SIZE; … };</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; primer plus 第11章使用类</title>
        <url>http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC11%E7%AB%A0%E4%BD%BF%E7%94%A8%E7%B1%BB/</url>
        <categories>
          <category>C&#43;&#43;</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> C&#43;&#43; primer plus 第11章使用类
[toc]
运算符重载 operatorop(argumnt-list) 例如，operator&#43;()重载&#43;运算符。
计算时间：一个运算符重载示例 如果要计算两个时间之和，如2小时40分与1小时30分之和，可以重载运算符&#43;，在类中的成员函数为：
Time operator&#43;(const Time &amp;amp; t) const; 重载限制  重载后的运算符至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符（-）重载为两个double值的和。 使用运算符不能违反运算符原来的句法规则，例如不能将求模运算符（%）重载成使用一个操作数。 不能创建新运算符。例如operator**() 不能从在下面的运算符：  sizeof：sizeof 运算符 .: 成员运算符 .*: 成员指针运算符 ::: 作用域解析运算符 ?:: 条件运算符 typeid: 一个RTTI运算符 强制转换类型运算符  大多数运算符都可以通过成员或非成员函数进行重载，但是下面运算符只能通过成员函数进行重载  =: 赋值运算符 (): 函数调用运算符 []: 下表运算符 -&amp;gt;: 通过指针访问类成员运算符   友元 C&#43;&#43;控制对类对象私有部分的访问时，通常共有类方法是访问的唯一途径，但是C&#43;&#43;还提供了另外一种形式的访问权限：友元。友元有三种：
 友元函数 友元类 友元成员函数  创建友元函数的第一步是将其原型放在类声明总，并在原型声明前加上关键字friend：
friend Time operator*(double m, const Time &amp;amp; t); 该原型意味着下面两点: * 虽然operator*()函数是在类声明中声明的，但是它不是成员函数，因此不能使用成员运算符进行调用。 * 虽然operator*()函数不是成员函数，但是它与成员函数的访问权限相同。
在编写函数定义时，因为它不是成员函数，所以不要使用::限定符。另外，不要再定义中用关键字 friend，定义应如下：
Time operator*(double m, const Time &amp;amp; t) { ... ... ... } 提示：如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以使用友元函数来反转操作数的顺序。
重载运算符：作为成员函数或非成员函数 对于很多运算符，可以选择使用成员函数和非成员函数来实现运算符重载。一般来说非成员函数应该是友元函数，这样才可以访问类的私有数据。
再谈重载：一个矢量类 可以为Vector类重载运算符，实现矢量的加法和乘法，同时还可以使用Vector类来模拟随机游走
// randwalk.cpp -- using the Vector class // compile with the vect.cpp file #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; // rand(), srand() prototypes #include &amp;lt;ctime&amp;gt; // time() prototype #include &amp;#34;vect.h&amp;#34; int main() { using namespace std; using VECTOR::Vector; srand(time(0)); // seed random-number generator double direction; Vector step; Vector result(0.0, 0.0); unsigned long steps = 0; double target; double dstep; cout &amp;lt;&amp;lt; &amp;#34;Enter target distance (q to quit): &amp;#34;; while (cin &amp;gt;&amp;gt; target) { cout &amp;lt;&amp;lt; &amp;#34;Enter step length: &amp;#34;; if (!(cin &amp;gt;&amp;gt; dstep)) break; while (result.magval() &amp;lt; target) { direction = rand() % 360; step.reset(dstep, direction, Vector::POL); result = result &#43; step; steps&#43;&#43;; } cout &amp;lt;&amp;lt; &amp;#34;After &amp;#34; &amp;lt;&amp;lt; steps &amp;lt;&amp;lt; &amp;#34; steps, the subject &amp;#34; &amp;#34;has the following location:\n&amp;#34;; cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl; result.polar_mode(); cout &amp;lt;&amp;lt; &amp;#34; or\n&amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;Average outward distance per step = &amp;#34; &amp;lt;&amp;lt; result.magval()/steps &amp;lt;&amp;lt; endl; steps = 0; result.reset(0.0, 0.0); cout &amp;lt;&amp;lt; &amp;#34;Enter target distance (q to quit): &amp;#34;; } cout &amp;lt;&amp;lt; &amp;#34;Bye!\n&amp;#34;; /* keep window open cin.clear(); while (cin.get() != &amp;#39;\n&amp;#39;) continue; cin.get(); */ return 0; } 类的自动转换和强制类型转换 分为三种情况：
（1）如果要进行的转换之间是兼容的，C&#43;&#43;自动将值转换为接收变量的类型：
int count = 8.8; double time= 3; long day = 8; （2）C&#43;&#43;不自动转换不兼容的类型：
int * pr = 10; （3）强制类型转换：
int *pr = （int *） 10; 这条语句通过类型的强制转换的结果是这条语句可以正常进行。表示：定义一个地址为10 的指针。（这种赋值是没有什么意义的）
将别的数据类型转换为类对象 将类定义成与基本类型相关或者是与另一个类相关，使得从一个类到另一个类的转换时有意义的。在这种情况下可以指示C&#43;&#43;如何进行自动类型转换，或者通过强制类型转换来完成：
下面我们通过一个例子来详细介绍：
需求：计量单位磅转换为英石：
// stonewt.h -- definition for the Stonewt class #ifndef STONEWT_H_ #define STONEWT_H_ class Stonewt { private: enum {Lbs_per_stn = 14}; // pounds per stone int stone; // whole stones double pds_left; // fractional pounds double pounds; // entire weight in pounds public: Stonewt(double lbs); // constructor for double pounds Stonewt(int stn, double lbs); // constructor for stone, lbs Stonewt(); // default constructor ~Stonewt(); void show_lbs() const; // show weight in pounds format void show_stn() const; // show weight in stone format }; #endif// stonewt.cpp -- Stonewt methods #include &amp;lt;iostream&amp;gt; using std::cout; #include &amp;#34;stonewt.h&amp;#34; // construct Stonewt object from double value Stonewt::Stonewt(double lbs) { stone = int (lbs) / Lbs_per_stn; // integer division pds_left = int (lbs) % Lbs_per_stn &#43; lbs - int(lbs); pounds = lbs; } // construct Stonewt object from stone, double values Stonewt::Stonewt(int stn, double lbs) { stone = stn; pds_left = lbs; pounds = stn * Lbs_per_stn &#43;lbs; } Stonewt::Stonewt() // default constructor, wt = 0 { stone = pounds = pds_left = 0; } Stonewt::~Stonewt() // destructor { } // show weight in stones void Stonewt::show_stn() const { cout &amp;lt;&amp;lt; stone &amp;lt;&amp;lt; &amp;#34; stone, &amp;#34; &amp;lt;&amp;lt; pds_left &amp;lt;&amp;lt; &amp;#34; pounds\n&amp;#34;; } // show weight in pounds void Stonewt::show_lbs() const { cout &amp;lt;&amp;lt; pounds &amp;lt;&amp;lt; &amp;#34; pounds\n&amp;#34;; } Stonewt类有三个构造函数，可以允许将Stonewt对象初始化为一个浮点数或者两个浮点数，也可以不进行初始化。
隐式的自动类型转换 下面我们先来看一下这个构造函数：
Stonewt(double lbs);
这个构造函数允许将double类型的值转化为Stonewt类型，因此可以编写：
CStonewt myCat; myCat = 19.6; 原理：程序使用Stonewt(double lbs)，来创建一个临时的Stonewt对象，然后将19.6赋值给它，随后，采用逐成员赋值的方式将该对象的内容赋值到myCat中，这一过程成为隐式转换，因为他是自动进行的。而不需要显示强制类型转换。
只有接受一个参数的构造函数才能作为转换函数，例如：Stonewt(int stn, double lbs);不能作为转换类型。但是如果给第二个参数提供默认值，它便可以转换int：
Stonewt(int stn,double lbs = 0); 显式类型强制转换 将构造函数用作自动类型转换函数似乎是一种非常好的特性，但是这种自动类型转换并不是总是合乎需要的，因为这可能导致意外的类型转换：
解决方法：C&#43;&#43;新增了 关键字explicit用于关闭这种自动特性，也就是说可以这样声明构造函数:
explicit Stonewt(double lbs); 这将关闭隐式类型转换，但仍然允许显示类型转换，即显式类型转换：
Stonewt myCat; myCat = 19.6; //(这种方式是错的) myCat = Stonewt(19.6); //(允许的) myCat = (Stonewt) 19.6; //（允许的） 那么问题来了，编译器都在什么时候调用Stonewt(double lbs)函数呢？（如果声明为explict，则只能显式类型转换，不支持以下几点）：
 将Stonewt对象初始化为double值时； 将double值传递给接受Stonewt参数的函数时； 返回值被声明为Stonewt得到函数试图返回double值时； 将double值赋给Stonewt对象时； 在上述任一一种情况下，使用可转换为double类型的内置类型时；  最重要的一点：
函数原型化提供的参数匹配过程中，允许使用Stonewt(double)构造函数来转换其他数值类型。
stonewt Jumb(7000); Jumb = 7300; 这两条语句都是先将int 转化为double，然后使用Stonewt(double)构造函数。然而这是有前提性的：
即不存在二义性。如果还存在Stonewt(long)，则编译器将拒绝执行这些语句，因为int可以转为long 或者double，一次调用会出现二义性。
将类类型转换为别的类型（转换函数） 构造函数只用于从某种类型到类类型的转换，要进行相应的反转，必须使用特殊的C&#43;&#43;运算符函数&amp;ndash;转换函数
转换函数是用户自定义的强制类型转换，可以像使用强制类型转换那样使用它们。
Stonewt wolfe =(285.7); double host = double (wolfe); double thinker = (double) wolfe;  注意点：
 转换函数必须是类方法 转换函数不能指定返回类型 转换函数不能有参数  要将类类型转换为double和int类型，则：
1.在Stonewt.h文件中声明类方法：
operator double () const; operator int () const;  2.在cpp文件中完成定义：
Stonewt::operator int() const { erturn pounds; } Stonewt::operator double () const { cout &amp;lt;&amp;lt; int(pounds &#43; 0.5); }  3.此时，我们就可以在main函数中将Stonewt赋值给int、double 了
CStonewt poppins(9, 2.8); double p_wt = poppins; cout &amp;lt;&amp;lt;(int) poppins&amp;lt;&amp;lt;endl; 还有一种情况需要注意：
long temp = popins; 这条语句是不正确的，因为存在二义性，因为int、double都可以转换为long 类型。如果删除一个int或者double的转换函数，则这条语句将可以执行。
总结 1.要谨慎的使用隐式转换函数，通常最好的选择是仅在被显示的调用时才会执行。
2.只有一个参数的类构造函数将用于类型与该参数相同的值转换为类类型。 例如：将int类型转换为CStonewt对象是，接受int 参数的CStonewt类构造函数将自动被调用，然而在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换。
3.被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。
转换函数是类成员，没有返回类型，没有参数名为 operator typeName();
其中 typeName是对象将被转换为的类型，将类对象赋给typeName变量或者将其强制转换为typeName类型时，该转换函数将会被自动调用。
4.尤其要注意过多的转换函数将导致出现二义性的几率变大，要谨慎防止二义性的出现。
转换函数和友元函数 普通成员函数和友元函数都能实现操作符的重载，如重载&#43;运算符实现两个类对象的相加。有的时候你声明的操作符重载函数的形参是两个对象，但是实参中有一个类型兼容类型变量，这个时候如果你的类中存在类型转换函数，它就可能把原来是对象的那个实参通过类型转换函数转换成类型兼容类型。
成员函数和友元函数都可以实现：
Stonewt jennySt(9, 12); double kennyD = 146.0; Stonewt total; total = jennySt &#43; kennyD; 转换为： total = operator&#43;(jennySt &#43; kennyD); 或 total = jennySt.operator&#43;(kennyD); 但是只有友元函数才能实现：
Stonewt jennySt(9, 12); double pennyD = 146.0; Stonewt total; total = pennyD &#43; jennySt； 转换为： total = operator&#43;(pennyD, jennySt); 不能转换为 total = pennyD.operator&#43;(jennySt); 这是因为当你使用一个成员函数版的操作符重载函数时，原本的调用者应该是该类的对象，但实际上调用者是一个类型兼容类型的变量，它显然不能成为成员重载函数的调用者，于是调用失败了。而一个友元函数却不会出现此状况，并且友元函数在接受实参时会使用构造函数将一个类型兼容类型转换为类类型。
</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; primer plus 第10章对象和类</title>
        <url>http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC10%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
        <categories>
          <category>C&#43;&#43;</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag>
        </tags>
        <content type="html"> C&#43;&#43; primer plus 第10章对象和类
[TOC]
过程性编程和面向对象编程 抽象和类 ifndef 文件中的#ifndef
头件的中的#ifndef，这是一个很关键的东西。
需要注意的是，#ifndef起到的效果是防止一个源文件两次包含同一个头文件，而不是防止两个源文件包含同一个头文件。
而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。
还是把头文件的内容都放在#ifndef和#endif中吧。不管你的头文件会不会被多个文件引用，你都要加上这个。一般格式是这样的：
#ifndef &amp;lt;标识&amp;gt; #define &amp;lt;标识&amp;gt; ...... ...... #endif 访问控制 公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏。
 类表示人们可以类方法的公有接口对类对象执行的操作，这是抽象。
类的数据成员可以是私有的（默认值），这意味着只能通过成员函数来访问这些数据，这是数据隐藏。
实现的具体细节，（如数据表示和方法的代码）都是隐藏的，这是封装。
 类和结构 类对象的默认访问控制是private，而结构的默认访问类型是public。
class World { float mass; char name[20]; //默认是private public: void tellall(void); } 实现类成员函数 类成员函数有两个特征：
 定义成员函数时，使用作用域解析运算符::来标识函数所属的类 类方法可以访问类的private组件  void Stock::update(double price) 类的构造函数和析构函数 每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
声明和定义构造函数 构造函数原型（声明）：
Stock(const &amp;amp; co, long n = 0, double pr = 0.0) 构造函数定义（没有返回类型）：
Stock::Stock(const &amp;amp; co, long n = 0, double pr = 0.0) { company = co; shares = n; share_val = pr; set_tot(); } 成员名和参数名不能相同！！！
使用构造函数 Stock food = Stock(&amp;#34;World Cabbage&amp;#34;, 50, 2.5); 或 Stock food(&amp;#34;World Cabbage&amp;#34;, 50, 2.5); 默认构造函数 定义默认构造函数有两种方法：
 一种是给已有构造函数的所有参数提供默认值：  Stock(const &amp;amp; co, long n = 0, double pr = 0.0)  另一种是通过函数重载来定义另一个构造函数——一个没有参数的构造函数  Stock(); 用户定义的默认构造函数通常给所有成员提供隐式初始值。例如，下面是Stock类定义的一个默认构造函数：
Stock::Stock() { company = &amp;#34;no name&amp;#34;; shares = 0; share_val = 0.0; set_tot(); } 提示： 在设计类时，通常应该提供对所有类成员做隐式初始化的默认构造函数。
声明对象变量时，初始化方式可以为：
Stock first(&amp;#34;Concrete Conlomerate&amp;#34;); //调用构造函数 Stock second(); //声明一个返回Stock对象的函数 Stock third; //隐式的调用默认构造函数 Stock *fourth = new Stock(&amp;#34;popo&amp;#34;); //动态对象 析构函数 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。
析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。
如果构造函数使用了new，则必须提供使用delete的析构函数，如：
class Student{ public: Student(){m_name=new char[20];} //即在堆上定义----故在释放对象时必须要释放掉内存 private: char *m_name; }; 故需要添加析构函数： //销毁时自动调用，没有则由系统默认生成 //没有返回值，也没有参数，从而不可重载 Student::~Student() { delete m_name; m_name=NULL; } 改进Stock类 this指针 当需要比较两个类中数据成员的大小，并返回变量值较大的类时，函数原型为：
const Stock &amp;amp; topval(const Stock &amp;amp; s) const 函数调用为：
top = stock1.topval(stock2); 或 top = stock2.topval(stock1); 但是在函数实现中会有一个问题：
const Stock &amp;amp; Stock::topval(const Stock &amp;amp; s) const { if (s.total_val &amp;gt; total_val) return s; else return ???????????; //函数无法返回调用该方法的对象 } 在 C&#43;&#43; 中，每一个对象都能通过 this 指针来访问自己的地址。每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。可以通过this-&amp;gt;total_val(类成员)来访问类成员。如果方法需要引用整个调用对象，则可以使用表达式*this。在函数的括号后面使用const限定符将this限定为const，这样不能使用this指针来修改对象的值。
于是，可以使用this指针返回调用该方法的对象：
const Stock &amp;amp; Stock::topval(const Stock &amp;amp; s) const { if (s.total_val &amp;gt; total_val) return s; else return *this; } 对象数组 声明对象数组的方法和标准类型数组方法相同：
Stock mystuff[4]; //创建一个含有四个Stock对象的数组 使用构造函数来初始化数组元素时，必须为每一个元素调用构造函数。
const int STKS = 4; Stock stocks[STKS] = { Stock(&amp;#34;Nono&amp;#34;, 12.5, 20), Stock(&amp;#34;dsa&amp;#34;, 200, 2.0), Stock(&amp;#34;Mono&amp;#34;, 130, 20.25), Stock(&amp;#34;Fleep&amp;#34;, 60, 6.5), } 类作用域 当我们要创建一个由所有对象共享的常量是个不错的主意，我们可能认为下面做法是可行的：
class Bakery() { private: const int Months = 12; //声明一个常量？这是错误的。 double costs[Months]; ... } 声明类只是描述了对象的形式，并没有创建对象，在创建对象之前，将没有用于存储值的空间。
此时有两种方法： * 第一种为在类中声明一个枚举，在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称。
class Bakery() { private: enum {Months = 12}; double costs[Months]; ... }  第二种方法为在类中定义常量的方式——使用关键字static  class Bakery() { private: static const int Months = 12; double costs[Months]; ... } 将常量与其他静态变量存储在一起，而不是存储在对象中。
抽象数据类型 ADT以通用的方式描述数据类型，而没有引入语言或实现细节。
下面简要介绍一下栈的特征，首先，栈存储了多个数据项（该特征使得栈成为了一个容器——一种更通用的抽象）；其次栈由可对他执行的操作来描述。
 可创建空栈 可将数据项添加到栈顶（压入） 可从栈顶删除数据项（弹出） 可查看栈是否填满 可查看栈是否为空  可以将上述描述转换为一个类声明，其中共有函数提供了表示栈操作的接口，而私有数据成员负责存储栈数据。类概念特别适合于ADT方法。
</content>
    </entry>
    
     <entry>
        <title>Markdown文件基本语法</title>
        <url>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/markdown%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
        <categories>
          <category>博客</category>
        </categories>
        <tags>
          <tag>markdown</tag>
        </tags>
        <content type="html"> 因为目前准备写博客，所以不可避免就要使用markdown语言写文章，所以这篇文章将对Markdown的基本语法进行介绍，方便以后查阅。
Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。目前常用的一些编辑器包括typora和VS Code以及vim等，目前我所使用的是VS code，使用VS Code需要安装 Markdown All in One 或 Markdown Preview Enhanced 插件从而可以进行预览。
本文章参考了Github上的Markdown Cheatsheet 以及简书上的 Markdown 语法小指南
分级标题 # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 也可使用===表示一级标题，使用---表示二级标题 Alt-H1 ====== Alt-H2 ------ H1 H2 H3 H4 H5 H6 也可使用===表示一级标题，使用&amp;mdash;表示二级标题
Alt-H1 Alt-H2 文字样式 文字强调 *Italics* or _Italics_ **Bold** or __Bold__ ***Bold Italics*** or ___Bold Italics___ ~~Delete~~ Italics or Italics Bold or Bold Bold Italics or Bold Italics Delete
文字上下标（superscript and subscript） 这是^上标文字^ 这是~下标文字~ 这是^上标文字^ 这是~下标文字~
字体下划线 &amp;lt;u&amp;gt;Underline&amp;lt;/u&amp;gt; Underline
字体背景高亮 ==Highlight== ==Highlight==
列表 有序列表 ==数字不能省略但可无序==，点号之后的空格不能少。建立多级列表时，每个子级别都要比上个级别前面多打2个以上空格。
1. Item-1 1.1. Item-1-1 1.1.1. Item-1-1-1 1.1.1.1. Item-1-1-1-1 1.2. Item-1-2 2. Item-2 6. Item-3  Item-1 1.1. Item-1-1 1.1.1. Item-1-1-1 1.1.1.1. Item-1-1-1-1 1.2. Item-1-2 Item-2 Item-3  无序列表 符号之后的空格不能少，-、&#43;、*效果一样，在嵌套列表中可以循环使用。
- Item-1 * Item-1-1 &#43; Item-1-1-1 * Item-1-1-1-1 * Item-1-2 &#43; Item-2 * Item-3  Item-1  Item-1-1 Item-1-1-1  Item-1-1-1-1  Item-1-2  Item-2 Item-3  添加链接（Links） 有两种添加链接的方式，分别为内联（inline）和引用（reference）
内联（inline） [I&amp;#39;m an inline-style link](https://www.google.com) [I&amp;#39;m an inline-style link with title](https://www.google.com &amp;#34;Google&amp;#39;s Homepage&amp;#34;) I&amp;rsquo;m an inline-style link
I&amp;rsquo;m an inline-style link with title
引用（reference） 引用（Reference）：一般应用于多个不同位置使用相同链接。通常分为两个部分：
调用部分格式为：链接文本
定义部分可以出现在文本中的其他位置，格式为：ref: http://some/link/address (可选的标题)。
This is [an example][ref] reference-style link. This is an example reference-style link.
自动创建链接 使用尖括号&amp;lt;&amp;gt;，可以为输入的URL或者邮箱自动创建链接，如https://www.baidu.com。
&amp;lt;https://www.baidu.com&amp;gt; https://www.baidu.com
添加图片（Images） 添加图片的使用方法基本上和链接类似，只是在中括号前加叹号!，即![alt text](URL &amp;quot;Image Title&amp;quot;)。
内联法: ![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png &amp;#34;Logo Title Text 1&amp;#34;) 引用法: ![alt text][logo] 内联法: 引用法: 文字引用（Blockquotes） 使用&amp;gt;表示文字引用。可以多级引用。
&amp;gt; Quote 1 &amp;gt; &amp;gt; Quote 2 &amp;gt; &amp;gt; &amp;gt; Quote 3  Quote 1 &amp;gt; Quote 2 &amp;gt; &amp;gt; Quote 3
 想在列表项里面使用区块引用，定界符&amp;gt;必须得缩进：
* Item &amp;gt; Quote 1 &amp;gt; Quote 2  Item &amp;gt; Quote 1 &amp;gt; Quote 2  转义字符（Backslash Escapes） Markdown 可以利用反斜杠\来插入一些在语法中有其它意义的符号，例如：如果想要用星号加在文字旁边的方式来做出强调效果，可以在星号的前面加上反斜杠：
\*literal asterisks\* *literal asterisks*
代码块引用（Fenced Code Blocks） var s = &amp;#34;JavaScript syntax highlighting&amp;#34;; alert(s); s = &amp;#34;Python syntax highlighting&amp;#34; print sNo language indicated, so no syntax highlighting. But let&amp;#39;s throw in a &amp;lt;b&amp;gt;tag&amp;lt;/b&amp;gt;. 注：代码缩进请使用四个空格，不要使用 Tab。
表格（Tables） | Tables | Are | Cool | | ------ |:---:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 |    Tables Are Cool     col 3 is right-aligned $1600   col 2 is centered $12   zebra stripes are neat $1    |、-、: 之间的多余空格会被忽略，不影响布局。 默认标题栏居中对齐，内容居左对齐。 -: 表示内容和标题栏居右对齐，:- 表示内容和标题栏居左对齐，:-: 表示内容和标题栏居中对齐。 内容和 | 之间的多余空格会被忽略，每行第一个 | 和最后一个|可以省略，- 的数量至少有一个。
分隔线 在一行中使用三个或三个以上的 *、- 或 _ 可以添加分隔线，中间插入空格，但是不能有其他字符。下面每种写法都可以建立分隔线：
* * * *** ***** - - - ------ 添加脚注（Footnotes） 脚注是在需要标记脚注文字的后面增加一个方括号，方括号中的内容必须以 ^ 开头，再接着是数字、字符串标记：
Footnotes[^1] have a label[^label] and a definition[^!DEF]. 接着，在文件的任意地方，可以把这个脚注的内容定义出来。脚注内容定义的形式就是前面引用脚注的内容，接着一个冒号，再接着一个以上的空格或制表符，最后是脚注定义的内容：
 Footnotes1 have a label2 and a definition3.
脚注定义的内容可以包含多行、段落、代码区块、区块引用和大多数其他 markdown 格式的内容。对于多行的内容只需要简单缩进至少4个空格。
Paragraph two of the definition. &amp;gt; A blockquote with &amp;gt; multiple lines. a code block A final paragraph. 默认情况下，脚注内容位于生成的 HTML 文档末尾。
目录（Table of Contents） 在需要目录出现的地方放置一个标记，这样会自动生成一个嵌套的包含所有标题的列表。默认的标记是 [TOC]。
[TOC] The first paragraph of the definition.[return] A footnote on &amp;ldquo;label&amp;rdquo;[return] The definition of a footnote.[return]  </content>
    </entry>
    
     <entry>
        <title>我的第一次Hugo博客搭建过程（超级详细）</title>
        <url>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/hugo&#43;github-page%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
        <categories>
          <category>博客</category>
        </categories>
        <tags>
          <tag>Hugo</tag><tag>github page</tag>
        </tags>
        <content type="html"> 最近希望搭建一个自己的技术博客，用来记录在学的一些知识和技术，在比较了一下几个目前较为流行的静态博客Jekyll、Hexo、Hugo之后，还是决定采用Hugo。
Hugo是基于Go语言的一款静态博客，编译之后只有一个二进制文件，相比于Hexo基于nodejs、jekyll基于ruby等解释型语言而言搭建过程简单且博客编译速度非常快，所以即使文章数量和标签等很多时，Hugo也可以在几秒钟完成更新。但是Hugo目前使用率不及Hexo，所以目前可用的主题较少，并且网上的相关问题解决也不多，大多时候需要自己摸索。后面会更新Hugo博客主题的配置文章，现在先进行Hugo安装以及部署到Github Page的介绍：
安装过程可参照Hugo中文官网：https://www.gohugo.org
Hugo安装 二进制安装（推荐：简单、快速）
到Hugo Releases下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe），我这里时解压到了D:\hugo目录下
上一步操作，可以看到我们把hugo.exe解压到了D:\hugo下面。所以hugo命令只能在该目录下才能识别。但是我们想要把博客目录建到其他目录下，这就需要配置环境变量，在此不再赘述。
生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径：
hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进去目录：
cd /path/to/site 站点目录结构：
▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml 生成文章 创建一个 about 页面：
hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下：
&#43;&#43;&#43; date = &amp;#34;2015-10-25T08:36:54-07:00&amp;#34; draft = true title = &amp;#34;about&amp;#34; &#43;&#43;&#43; 正文内容 内容是 Markdown 格式的，&#43;&#43;&#43; 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 &amp;mdash; 标记）或者 JSON 格式。
创建第一篇文章，放到 post 目录，方便之后生成聚合页面。
hugo new post/first.md 打开编辑 post/first.md ：
--- date: &amp;#34;2015-10-25T08:36:54-07:00&amp;#34; title: &amp;#34;first&amp;#34; --- ### Hello Hugo 1. aaa 1. bbb 1. ccc 注意当md文件中的第四行drafts=true时，该文件为草稿，不会生成文章。应把改行删掉或者改为drafts=false。
安装主题 在官网主题列表中选择主题进行安装，我的博客时采用icarus主题进行安装的，具体的主题配置按照该主题的说明文件进行配置。
# 创建 themes 目录 cd themes git clone https://github.com/digitalcraftsman/hugo-icarus-theme.git 运行hugo 在你的站点根目录执行 Hugo 命令进行调试：
hugo server --theme=icarus --buildDrafts 浏览器里打开：http://localhost:1313
将Hugo部署到Github Page 安装git 根据该博客链接进行git的下载安装和环境配置：
https://blog.csdn.net/huangqqdy/article/details/83032408
部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：jchenTech.github.io （jchenTech替换为你的github用户名）。
在站点根目录执行 Hugo 命令生成最终页面：
hugo --theme=icarus --baseUrl=&amp;#34;http://jchenTech.github.io/&amp;#34; 如果一切顺利，所有静态页面都会生成到public目录，将pubilc目录里所有文件push到刚创建的Repository的master分支。
cd public git init git remote add origin https://github.com/jchenTech/jchenTech.github.io.git git add -A git commit -m &amp;#34;first commit&amp;#34; git push -u origin master 当输入 git remote rm origin https://github.com/jchenTech/jchenTech.github.io.git提示：fatal: remote origin already exists.时，需要删除远程地址。
git remote rm origin 浏览器里访问：http://jchenTech.github.io
部署过程中遇到的问题 页面加载过程中请求了http资源 在我安装icarus主题的过程中，在将博客部署到github上时，会导致页面不能正常显示，在页面F12显示Https的页面加载了http的js和css，提示Mixed Content错误，阻止了加载。因此，需要在E:\hugo\jchenBlog\themes\icarus\layouts\partials\head.html文件中加入下语句，将会把http请求转化为https请求：
&amp;lt;meta http-equiv=&amp;#34;Content-Security-Policy&amp;#34; content=&amp;#34;upgrade-insecure-requests&amp;#34;&amp;gt; 出现博客首页无法加载出文章列表问题 困扰了很久的问题，这是因为在安装hugo时选择的是当前最新版本0.65，但是hugo icarus这个主题是之前发布的，在hugo进行版本更新后，从0.57版本后，该主题有一些不兼容，并且目前该主题没有像其他主题一样针对hugo版本进行更新，所以需要下载老版本，如今的版本号为0.54，下载该版本然后替换掉该路径下的hugo二进制文件即可。
</content>
    </entry>
    
     <entry>
        <title>Formulas with MathJax</title>
        <url>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/formulas-with-mathjax/</url>
        <categories>
          <category>博客</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> Mathematical equations in form of LaTeX or MathML code can be rendered with the support of MathJax. MathML works out of the box. If you&amp;rsquo;re using LaTeX you need to wrap your equation with $$ as shown in the following example:
$$ z = r \cdot (\sin{\phi} &#43; \cos{\phi} \cdot i) $$
$$ z = r \cdot (\sin{\phi} &#43; \cos{\phi} \cdot i) $$
You can also print formulas inline: $a^2 &#43; b^2 = c^2$. In this case wrap the formula only once with $.
</content>
    </entry>
    
     <entry>
        <title>Markdown Cheat Sheet</title>
        <url>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/markdown-cheat-sheet/</url>
        <categories>
          <category>博客</category>
        </categories>
        <tags>
          <tag>markdown</tag>
        </tags>
        <content type="html"> This note demonstrates some of what Markdown is capable of doing.
Note: Feel free to play with this page. Unlike regular notes, this doesn&amp;rsquo;t automatically save itself.
Basic formatting Paragraphs can be written like so. A paragraph is the basic block of Markdown. A paragraph is what text will turn into when there is no reason it should become anything else.
Paragraphs must be separated by a blank line. Basic formatting of italics and bold is supported. This *can be nested like* so.
Lists Ordered list  Item 1 A second item Number 3 Ⅳ  Note: the fourth item uses the Unicode character for Roman numeral four.
Unordered list  An item Another item Yet another item And there&amp;rsquo;s more&amp;hellip;  Paragraph modifiers Code block Code blocks are very useful for developers and other people who look at code or other things that are written in plain text. As you can see, it uses a fixed-width font. You can also make inline code to add code into other things.
Quote  Here is a quote. What this is should be self explanatory. Quotes are automatically indented when they are used.
 Headings There are six levels of headings. They correspond with the six levels of HTML headings. You&amp;rsquo;ve probably noticed them already in the page. Each level down uses one more hash character.
Headings can also contain formatting They can even contain inline code Of course, demonstrating what headings look like messes up the structure of the page.
I don&amp;rsquo;t recommend using more than three or four levels of headings here, because, when you&amp;rsquo;re smallest heading isn&amp;rsquo;t too small, and you&amp;rsquo;re largest heading isn&amp;rsquo;t too big, and you want each size up to look noticeably larger and more important, there there are only so many sizes that you can use.
URLs URLs can be made in a handful of ways:
 A named link to MarkItDown. The easiest way to do these is to select what you want to make a link and hit Ctrl&#43;L. Another named link to MarkItDown Sometimes you just want a URL like http://www.markitdown.net/.  Horizontal rule A horizontal rule is a line that goes across the middle of the page.
It&amp;rsquo;s sometimes handy for breaking things up.
Images Markdown can also contain images. I&amp;rsquo;ll need to add something here sometime.
Finally There&amp;rsquo;s actually a lot more to Markdown than this. See the official introduction and syntax for more information. However, be aware that this is not using the official implementation, and this might work subtly differently in some of the little things.
</content>
    </entry>
    
     <entry>
        <title>Using the gallery shortcode</title>
        <url>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/using-the-gallery-shortcode/</url>
        <categories>
          <category>博客</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> This way you can easily include a gallery into your page. Copy the code below into your content file and enter the relative paths to your images.
</content>
    </entry>
    
     <entry>
        <title>How to add pages to the menu</title>
        <url>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/linked-post/</url>
        <categories>
          <category>博客</category>
        </categories>
        <tags>
          <tag>golang</tag><tag>programming</tag><tag>theme</tag><tag>hugo</tag>
        </tags>
        <content type="html"> I&amp;rsquo;m a linked post in the menu. You can add other posts by adding the following line to the frontmatter:
menu = &amp;#34;main&amp;#34;</content>
    </entry>
    
</search>