<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
    <title>C&#43;&#43; primer plus 第12章类和动态内存分配 - 陈建君的技术博客</title>
    <meta name="keywords" content="蘭陵N散記,兰陵,独立,博客,程序员,架构师,个人,思考,读书,笔记,技术,分享,Golang">
    
    <meta property="og:title" content="C&#43;&#43; primer plus 第12章类和动态内存分配">
    <meta property="og:site_name" content="陈建君的技术博客">
    <meta property="og:image" content="/img/author.jpg"> 
    <meta name="title" content="C&#43;&#43; primer plus 第12章类和动态内存分配 - 陈建君的技术博客" />
    <meta name="description" content="蘭陵N散記 | 博客 | 软件 | 架构 | Java | Golang"> 
    <link rel="shortcut icon" href="http://jchenTech.github.io/img/favicon.ico" />
    <link rel="apple-touch-icon" href="http://jchenTech.github.io/img/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="http://jchenTech.github.io/img/apple-touch-icon.png" />
    <link href="http://jchenTech.github.io/js/vendor/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />
    <link href="http://jchenTech.github.io/js/vendor/fancybox/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />
    <link href="http://jchenTech.github.io/css/main.css" rel="stylesheet" type="text/css" />
    <link href="http://jchenTech.github.io/css/syntax.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
     fancybox: true, 
    motion: true
  };
</script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
<div class="container one-collumn sidebar-position-left page-home  ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-meta  custom-logo ">

  <div class="custom-logo-site-title">
    <a href="http://jchenTech.github.io/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">陈建君的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">一指流沙，程序年华</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
    <ul id="menu" class="menu">
      
      
        <li class="menu-item ">
          <a href="http://jchenTech.github.io/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://jchenTech.github.io/categories/%E6%8A%80%E6%9C%AF/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br />技术
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://jchenTech.github.io/categories/%E6%84%9F%E6%83%B3/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tint"></i> <br />感想
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://jchenTech.github.io/categories/%E7%AC%94%E8%AE%B0/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />笔记
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://jchenTech.github.io/categories/%E6%9D%82%E8%AE%B0/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />杂记
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://jchenTech.github.io/post/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档
          </a>
        </li>
      
        <li class="menu-item ">
          <a href="http://jchenTech.github.io/about/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于
          </a>
        </li>
      
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger"> <i class="menu-item-icon fa fa-search fa-fw"></i> <br /> 搜索</a>
      </li>
    </ul>
    <div class="site-search">
      <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>

    </div>
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
<section id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link" href="http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC12%E7%AB%A0%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" itemprop="url">
        C&#43;&#43; primer plus 第12章类和动态内存分配
        </a>
      </h1>
      <div class="post-meta">
      <span class="post-time">
<span class="post-meta-item-icon">
    <i class="fa fa-calendar-o"></i>
</span>
<span class="post-meta-item-text">时间：</span>
<time itemprop="dateCreated" datetime="2016-03-22T13:04:35+08:00" content="2020-03-17">
    2020-03-17
</time>
</span> 
      

  <span class="post-category" >
  &nbsp; | &nbsp;
  <span class="post-meta-item-icon">
    <i class="fa fa-folder-o"></i>
  </span>
  <span class="post-meta-item-text">分类：</span>
  
    <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
      <a href="http://jchenTech.github.io/categories/c&#43;&#43;" itemprop="url" rel="index">
        <span itemprop="name">C&#43;&#43;</span>
      </a>
      &nbsp; 
    </span>
  
</span>


       <span>
&nbsp; | &nbsp;
<span class="post-meta-item-icon">
    <i class="fa fa-eye"></i>
</span>
<span class="post-meta-item-text">阅读：</span>
<span class="leancloud-visitors-count">9401 字 ~19分钟</span>
</span>
      </div>
    </header>
    <div class="post-body" itemprop="articleBody">
    <p>C++ primer plus 第12章类和动态内存分配</p>

<p>[toc]</p>

<h2 id="动态内存和类">动态内存和类</h2>

<p>C++在分配内存时是让程序在运行时决定内存分配，而不是在编译时决定。这样，可根据程序的需要，而不是根据一系列严格的存储类型规则来使用内存。C++使用new和delete运算符来动态控制内存。</p>

<h3 id="复习示例和静态类成员">复习示例和静态类成员</h3>

<p>这个程序使用了一个新的存储类型：静态类成员：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">//strngbad.h
#include&lt;iostream&gt;
#ifndef STRNGBAD_H_
#define STRNGBAD_H_
class StringBad
{
private:
    char * str;      //指向字符串的指针
    int len;        //字符串的长度
    static int num_strings;    //对象个数
public:
    StringBad(const char * s);   //构造函数
    StringBad();                 //默认构造函数
    ~StringBad();                //析构函数
    //友元函数
    friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os,
        const StringBad &amp; st);
};
#endif</pre></div>
<p>首先，它使用char指针（而不是char数组）来表示姓名。这意味着类声明没有为字符串本身分配存储空间，而是在构造函数中使用new来为字符串分配空间。 这避免了在类声明中预先定义字符串的长度。</p>

<p>其次，将<code>num_strings</code>成员声明为<strong>静态存储类</strong>。 静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。 也就是说，类的所有对象共享同一个静态成员。 假设创建了10个StringBad对象，将有10个str成员和10个len成员，但只有一个共享的<code>num_strings</code>成员。这对于所有类对象都具有相同值的类私有数据是非常方便的。 例如，<code>num_strings</code>成员可以记录所创建的对象数目。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">//strngbad.cpp 
#include&lt;cstring&gt;
#include&#34;strngbad.h&#34;
using std::cout;
 
//初始化静态类成员
int StringBad::num_strings = 0;
 
//类方法
//以C字符型构造StringBad
StringBad::StringBad(const char * s)
{
    len = std::strlen(s);        //设置长度
    str = new char[len + 1];     //分配内存
    std::strcpy(str, s);         //初始化指针
    num_strings++;               //设置对象数量
    cout &lt;&lt; num_strings &lt;&lt; &#34;: \&#34;&#34; &lt;&lt; str
        &lt;&lt; &#34;\&#34; object created\n&#34;;
}
StringBad::StringBad()            //默认构造函数
{
    len = 4;
    str = new char[4];
    std::strcpy(str, &#34;C++&#34;);      //默认字符串
    num_strings++;
    cout &lt;&lt; num_strings &lt;&lt; &#34;: \&#34;&#34; &lt;&lt; str &lt;&lt; &#34;\&#34; default object created\n&#34;;
}
StringBad::~StringBad()           //必要的析构函数
{
    cout &lt;&lt; &#34;\&#34;&#34; &lt;&lt; str &lt;&lt; &#34;\&#34; object deleted, &#34;;
    --num_strings;               //有要求
    cout &lt;&lt; num_strings &lt;&lt; &#34; left\n&#34;;
    delete[] str;                 //有要求
}
std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const StringBad &amp; st)
{
    os &lt;&lt; st.str;
    return os;
}</pre></div>
<p>程序中使用了下面语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">int StringBad::num_strings = 0;</pre></div>
<p>注意： 不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。 对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。</p>

<p>注意： 静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态类成员所属的类。但如果静态成员是const整数类型或枚举型，则可以在类声明中初始化。</p>

<p>析构函数：str成员指向new分配的内存。当StringBad对象过期时，str指针也将过期。但str指向的内存仍被分配，除非使用delete将其释放。删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句可确保对象过期时，由构造函数使用new分配的内存被释放。</p>

<p>当类对象作为函数参数值传递时，析构函数将被调用。</p>

<p>另外，下面的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad sailor= sports;</pre></div>
<p>这使用的是哪个构造函数呢？不是默认构造函数，也不是参数为const char*的构造函数。记住，这种形式的初始化等效于下面的语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad sailor = StringBad(sports);    //使用sports的构造函数</pre></div>
<p>因为sports的类型为StringBad，因此相应的构造函数原型应该如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad(const StringBad &amp;);</pre></div>
<p>当您使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为<code>复制构造函数</code>，因为它创建对象的一个副本）。自动生成的构造函数不知道需要更新静态变量num_string，因此会将计数方案搞乱。 实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的。</p>

<h3 id="特殊成员函数">特殊成员函数</h3>

<p>StringBad类的问题是由特殊成员函数引起的。 这些成员函数是自动定义的，就StringBad而言，这些函数的行为与类设计不符。 具体地说，C++自动提供了这些成员函数：</p>

<ul>
<li>默认构造函数，如果没有定义构造函数；</li>
<li>默认析构函数，如果没有定义；</li>
<li>复制构造函数，如果没有定义；</li>
<li>赋值运算符，如果没有定义；</li>
<li>地址运算符，如果没有定义。</li>
</ul>

<ol>
<li>默认构造函数：</li>
</ol>

<p>如果没有提供任何构造函数，C++将创建默认构造函数。 例如，加入定义了一个Klunk类，但没有提供任何构造函数，则编译器将提供下述默认构造函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Klunk::Klunk() { }               //隐式默认构造函数

Klunk lunk;                    //调用默认构造函数</pre></div>
<p>默认构造函数使Lunk类似于一个常规的自动变量，也就是说，它的值在初始化时是未知的。</p>

<p>如果定义了构造函数，C++将不会定义默认构造函数。 如果希望在创建对象时不显式地对它进行初始化，则必须显式地定义默认构造函数。这种构造函数没有参数，但可以使用它来设置特定地值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Klunk::Klunk()               //显式默认构造函数
{
klunk_ct=0;
…
}</pre></div>
<p>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。 例如，Klunk类可以包含下述内联构造函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Klunk(int n = 0) {klunk_ct = n;}</pre></div>
<p>但只能有一个默认构造函数。 也就是说，不能这样做：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Klunk()  {klunk_ct = 0;}              //构造函数#1

Klunk(int n =0) {klunk_ct=n;}           //具有二义性的构造函数#2</pre></div>
<p>例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Klunk kar(10);                        //明确地与#1匹配

Klunk bus;                           //与两个构造函数均可匹配</pre></div>
<p>第二个声明既与构造函数#1（没有参数）匹配，也与构造函数#2（使用默认参数0）匹配。</p>

<ol>
<li>复制构造函数</li>
</ol>

<p>复制构造函数用于将一个对象复制到新创建的对象中。 类的复制构造函数的原型如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Class_name(const Class_name &amp;);</pre></div>
<p>它接受一个指向类对象的常量引用作为参数。 例如，StringBad类的复制构造函数原型如下
：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad(const StringBad &amp;);</pre></div>
<p>对于复制构造函数，需要知道两点：何时调用和有何功能。</p>

<ol>
<li>何时调用复制构造函数</li>
</ol>

<p>新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。 这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有地对象。例如，假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad ditto(motto);   //调用StringBad(const StringBad &amp;)

StringBad metoo = motto;  //调用StringBad(const StringBad &amp;)

StringBad also = StringBad(motto);      //调用StringBad(const StringBad &amp;)

StringBad * pStringBad = new StringBad(motto);  
////调用StringBad(const StringBad &amp;)</pre></div>
<p>每当程序生成了对象副本时，编译器都将使用复制构造函数。由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。</p>

<ol>
<li>默认的复制构造函数的功能</li>
</ol>

<p>默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad sailor = sports;</pre></div>
<p>与下面代码等价（由于私有成员是无法访问的，因此这些代码不能通过便于）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad sailor;

sailor.str=sports.str;

sailor.len=sports.len;</pre></div>
<p>如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。 静态函数（如num_strings）不受影响，因为它们属于整个类，而不是各个对象。</p>

<h3 id="复制构造函数哪里出了问题">复制构造函数哪里出了问题</h3>

<p>当callme2()被调用时，复制构造函数被用来初始化callme2()的形参，还被用来将对象sailor初始化为对象sports。 默认的复制构造函数不说明其行为，因此它不指出创建过程，也不增加计数器num_strings的值。但析构函数更新了计数，并且在任何对象过期时都将被调用，而不管对象是如何被创建的。 这是一个问题，因为这意味着程序无法准确地记录对象计数。 解决方法是提供一个对计数进行更新地显式复制构造函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad::StringBad(const StringBad &amp; s)
{
    num_strings++;
    ...
}</pre></div>
<p>解决类设计种这种问题的方法时进行深度复制（deep copy）。 也就是说，复制构造函数应当复制字符串并将副本的地址赋给str成员，而不仅仅是复制字符串地址。 这样每个对象都有自己的字符串，而不是引用另一个对象的字符串。 调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。可以这样编写String的复制构造函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad::StringBad(const StringBad &amp; st)
{
    num_strings++;         //处理静态成员更新
    len= st.len;          //相同长度
    str = new char[len + 1];    //分配空间
    std::strcpy(str,st.str);   //将字符串复制到新位置
    cout&lt;&lt; num_strings &lt;&lt; &#34;:\&#34;&#34; &lt;&lt; str
         &lt;&lt; &#34;\&#34; object created\n&#34;;
}</pre></div>
<p>必须定义复制构造函数的原因在于，一些类成员是使用new初始化的、指向数据的指针，而不是数据本身。</p>

<h3 id="赋值运算符">赋值运算符</h3>

<p>C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。 这种运算符的原型如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Class_name &amp; Class_name::operator=(const Class_name &amp;);</pre></div>
<p>它接受并返回一个指向类对象的引用。 例如，StringBad类的赋值运算符的原型如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad &amp; StringBad::operator=(constStringBad &amp;);</pre></div>
<ol>
<li>赋值运算符的功能以及何时使用它:</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad headline1(“Celery Stalks atMidnight”);
…
StringBad knot;
Knot = headline1;         //赋值运算符被调用</pre></div>
<p>初始化对象时，并不一定会使用赋值运算符：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad metoo=knot;    //可能使用复制构造函数，也可能是赋值运算符</pre></div>
<p>这里，metoo是一个新创建的对象，被初始化为knot的值，因此使用复制构造函数。 然而，正如前面指出的，实现时也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时对象的值复制到新对象中。这就是说，初始化总是会调用复制构造函数，而使用=运算符时也允许调用赋值运算符。</p>

<ol>
<li>解决赋值的问题</li>
</ol>

<p>对于由于默认赋值运算符不合适导致的问题，解决办法时提供赋值运算符（进行深度复制）定义。 其实现与复制构造函数相似，但也有一些差别。</p>

<p>由于目标对象可能引用了以前分配的数据，所以函数应使用delete[]来释放这些数据。</p>

<p>函数应当避免将对象赋给自身；否则，对对象重新赋值前，释放内存操作可能删除对象的内容。</p>

<p>函数返回一个指向调用对象的引用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad &amp; StringBad::operator=(const StringBad &amp; st)
{
    if (this == &amp;st)               //对象赋值给自身
         return *this;               //结束
    delete[] str;                  //释放老字符串
    len = st.len;
    str = new char[len + 1];        //为新字符串开辟空间
    std::strcpy(str,st.str);       //复制字符串
    return *this;                  
}</pre></div>
<p>如果地址相同，程序将返回*this，然后结束。 如果地址不同，函数将释放str指向的内存，这是因为稍后把一个新字符串的地址赋给str。 如果不首先使用delete运算符，则上述字符串将保留在内存中。赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值。</p>

<h2 id="改进后的新string类">改进后的新String类</h2>

<h3 id="修订后的默认构造函数">修订后的默认构造函数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String::String()
{
    len = 0;
    str = new char[1];  //这是为了和类析构函数兼容；
    str[0] = ’\0’;
}</pre></div>
<p>delete[ ]与使用new[ ]初始化的指针和空指针都兼容。空指针建议用<code>nullptr</code>表示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">str = nullptr;  //C++11的空指针表示法</pre></div>
<p>以其他方式初始化的指针，使用delete[]时，结果将是不确定的。</p>

<h3 id="比较成员函数">比较成员函数</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">friend bool operator==(const String &amp;st1, const String &amp;st2);</pre></div>
<p>将比较函数作为友元，有助于将String类对象与常规的C字符串进行比较。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">if (&#34;love&#34; == answer)</pre></div>
<p>将被转换为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">if (operator==(&#34;love&#34;, answer));</pre></div>
<p>然后编译器将使用某个构造函数将代码转换为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">if (operator==(String(&#34;love&#34;), answer));</pre></div>
<h3 id="使用中括号表示法访问字符">使用中括号表示法访问字符</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String opera(&#34;The Magic Flute&#34;);</pre></div>
<p>对于表达式opera[4]，C++将查找名称与特征标与此相同的方法；</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String::operator[](int i)</pre></div>
<p>如果找到匹配的原型，编译器将使用下面的函数调用来替代表达式opera[4]:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">opera.operator[ ](4)</pre></div>
<p>opera对象调用该方法，数组下标4成为该函数的参数。</p>

<p>有了上述定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">cout &lt;&lt;opera[4];</pre></div>
<p>被转换为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">cout &lt;&lt;opera.operator[4];</pre></div>
<p>返回值将是<code>opera.str[4]</code>。由此公有方法可以访问私有数据。</p>

<p>将返回类型声明为char &amp;，便可以给特定元素赋值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String means(&#34;might&#34;);
means[0] = &#39;r&#39;;</pre></div>
<p>第二条语句被转换为一个重载运算符函数调用：</p>

<p>means.operator[](0) = &lsquo;r&rsquo;;</p>

<p>这里将r赋给方法的返回值，上述代码等同于：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">means.str[0] = &#39;r&#39;;</pre></div>
<p>但在重载时，C++将区分常量和非常量函数的特征标，因此可以提供另一个仅供const String对象使用的operator[]()版本。</p>

<h3 id="静态类成员函数">静态类成员函数</h3>

<p>可以将成员函数声明为静态的，函数声明必须包含关键字<code>static</code>。但如果函数定义是独立的，则其中不能包含关键字static，这样做有两个重要的后果。</p>

<p>首先，不能通过对象调用静态成员函数 ，实际上，静态成员函数甚至不能使用this指针。</p>

<p>如果静态成员函数是在公有部分声明的，则可以使用类名和作用域运算符来调用它。</p>

<p>例如：可以给String类添加一个名为HowMany()的静态成员函数，方法是在类声明中添加如下原型定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">static int HowMany() {return num_strings;}</pre></div>
<p>由于静态成员函数不与特定的对象相关联，只能使用静态数据成员。</p>

<p>可以使用静态成员函数设置类级标记，以控制某些类接口的行为，例如：类级标记可以控制显示类内容的方法所使用的格式。</p>

<h3 id="进一步重载赋值运算符">进一步重载赋值运算符</h3>

<h2 id="在构造函数总使用new时应注意的事项">在构造函数总使用new时应注意的事项</h2>

<p>如果在构造函数中使用new来初始化对象的指针成员时必须特别小心。</p>

<ul>
<li><p>如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。</p></li>

<li><p>new和delete必须相互兼容。new对应于delete，new[ ]对应于delete[ ]。</p></li>

<li><p>如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。可以再一个构造函数中使用new初始化指针，也可以在另一个构造函数中使指针为空。</p></li>

<li><p>应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。通常，这种构造函数与下面类似。</p></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String::String(const String &amp; st)
{
    num_string++;
    len = st.len;
    str = new char [len+1];
    std::strcpy(str, st.str);
}</pre></div>
<ul>
<li>应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象，</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">StringBad &amp; StringBad::operator=(const StringBad &amp; st)
{
    if(this == &amp;st)
        return *this
    delete [] str;
    len = st.len;
    str = new char [len+1];
    std::strcpy(str, st.str);
    return *this;
}</pre></div>
<h3 id="应该和不应该">应该和不应该</h3>

<h3 id="包含类成员的类的逐成员复制">包含类成员的类的逐成员复制</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class Magazine
{
private:
    String title;
    string publisher;
...
};</pre></div>
<p>String和string都使用动态内存分配，这是否意味着需要为Magazine类编写复制构造函数和赋值运算符？不，至少对这个类本身来说不需要。默认的逐成员复制和赋值行为有一定的智能。如果您将一个Magazine对象复制或赋值给另一个Magazine对象，逐成员复制将使用成员类型定义的赋值构造函数和赋值运算符。也就是说，复制成员title时，将使用String的复制构造函数，而将成员title赋给另一个Magazine对象时，将使用String赋值运算符，以此类推。</p>

<p>然而，如果Magazine类因其他成员需要定义复制构造函数和赋值运算符，情况将更加复杂；在这种情况下，这些函数必须显式地调用String和string的复制构造函数和赋值运算符，这将在第13章中介绍。</p>

<h3 id="有关返回对象的说明">有关返回对象的说明</h3>

<p>返回方式：
* 返回指向对象的引用；
* 返回指向对象的const引用；
* 返回const对象；</p>

<ol>
<li>返回指向const对象的引用</li>
</ol>

<p>使用const引用的常见原因是旨在提高效率，但对于何时可以采用这种方式存在一些限制。</p>

<p>假如要编写函数Max()，它返回两个Vector对象中较大的一个，其中Vector是第11章开发的一个类。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Vector force1(50, 60);
Vector force2(10,70);
Vector max;
max = Max(force1, force2);</pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">//version 1
Vector Max(const Vector &amp; v1, const Vector &amp; v2)
{
    if (v1.magval() &gt; v2.magval())
        return v1;
    else
        return v2;
}

//version 2
const Vector &amp; Max(const Vector &amp; v1, const Vector &amp; v2)
{
    if (v1.magval() &gt; v2.magval())
        return v1;
    else
        return v2;
}</pre></div>
<p>返回对象将调用复制构造函数，而返回引用不会。因此第二个版本所做的工作更少，效率更高。引用指向的对象应该在调用函数执行时同时存在。</p>

<p>注意v1和v2被声明为const引用，所以返回类型必须为const，这样才匹配。</p>

<ol>
<li>返回指向非const对象的引用
<br /></li>
</ol>

<p>常用于两种情况：</p>

<ul>
<li>重载赋值运算符</li>
</ul>

<p>Operator=()的返回值作用域连续赋值；</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String s1(&#34;Good stuff&#34;);
String s2,s3;
s3=s2=s1;</pre></div>
<p>上述代码中，<code>s2.operator=()</code>的返回值被赋给s3。为此，返回String对象或String对象的引用都是可行的。但是通过引用可以避免调用复制构造函数，<strong>提高效率</strong>。</p>

<ul>
<li>重载与cout连用的&lt;&lt;运算符</li>
</ul>

<p>Operator&lt;&lt;()的返回值用于串接输出：</p>

<p>String s1(&ldquo;Good stuff&rdquo;);</p>

<p>cout &lt;&lt; s1 &lt;&lt; &ldquo;is coming!&rdquo;;</p>

<p><code>operator&lt;&lt;(cout, s1)</code>的返回值成员一个用于显示字符串&rdquo;is coming!&ldquo;的对象。返回类型必须是ostream &amp;，而不能仅仅是ostream。如果使用返回类型ostream，将要求调用ostream类的赋值构造函数，而ostream没有公有的赋值构造函数。幸运的是，返回一个指向cout的引用不会带来任何问题，因为cout已经在调用函数的作用域内。</p>

<h3 id="返回对象">返回对象</h3>

<p>如果被返回的对象是被调用函数的局部变量，则不应该按引用方式去返回它，因为在被调用函数执行完毕时，局部对象将调用析构函数。因此，当控制权回到调用函数时，引用指向的对象将不再存在。在这种情况下，应返回对象而不是引用。</p>

<p>通常，被重载的算术运算符属于这一类。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Vector force1();
Vector force2();
Vector net;
net = force1+force2;</pre></div>
<p>返回的不是force1，也不是force2，force1和force2在这个过程中应该保持不变。因此，返回值不能是指向在调用函数中已存在的对象的引用。相反，在Vector::operator+()中计算得到的两个矢量和被存储在一个新的临时对象中，该函数也不应返回指向该临时对象的引用，而应该返回实际的Vector对象，而不是引用。</p>

<p>在这种情况下，存在调用复制构造函数来创建被返回的对象的开销，然而这时无法避免的。</p>

<h3 id="返回const对象">返回const对象</h3>

<p>前面的Vector::operator+()的定义中有一个奇异的属性</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">net = force1 +force2; //语句1
force1 +force2 =net; //语句2</pre></div>
<p>这种代码都可行，是因为复制构造函数将创建一个临时对象来表示返回值。因此，在前面的代码中，表达式force1+force2的结果为一个临时对象。在语句1中，该临时对象被赋给一个net；在语句2中，net被赋给该临时对象。</p>

<p>如果您担心这种行为引发滥用。有个简单的解决方案，就是把返回类型声明为const Vector。那么语句2就非法了，因为返回对象无法被赋值，只能赋值给别人。</p>

<blockquote>
<p>总之，如果方法或函数要返回局部对象，就必须要返回对象，而不是返回对象的引用。这种情况下将使用赋值构造函数来生成返回的对象。这样的开销是不可避免的，也是必须的。</p>

<p>如果方法或函数要返回一个没有公有复制构造函数的类（例如ostream类）的对象，它必须返回一个指向这种对象的引用。</p>

<p>最后，有些方法和函数可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，因为其效率更高。</p>
</blockquote>

<h2 id="使用指向对象的指针">使用指向对象的指针</h2>

<h3 id="再探new和delete">再探new和delete</h3>

<p>new为创建的每一个对象的名称字符串分配存储空间，这是在构造函数中进行的；</p>

<p>析构函数使用delete来释放这些内存。</p>

<p>字符串是一个字符数组，所以析构函数使用的是带中括号的delete。使用new来为整个对象分配内存：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String * favorite = new String(saying[choice]);</pre></div>
<p>这不是为要存储的字符串分配内存，而是为<strong>对象分配内存</strong>；也就是说，为保存字符串地址的str指针和len成员分配内存。</p>

<h3 id="指针和对象小结">指针和对象小结</h3>

<ul>
<li>使用常规表示法来声明指向对象的指针：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String * glamour;</pre></div>
<ul>
<li>可以将指针初始化为指向已有的对象；</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String * first = &amp;saying[0];</pre></div>
<ul>
<li>可以使用new来初始化指针，这将创建一个新的对象</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">String * favorite = new String(sayings[choice]);</pre></div>
<ul>
<li>对类使用new将调用相应的类构造函数来初始化新创建的对象：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">//调用默认构造函数
String * gleep = new String;

//调用 String(const char *) 构造函数
String * glop = new String(&#34;my my my&#34;);

//调用 String(const String &amp;)构造函数
String * favorite = new String(saying[choice]);</pre></div>
<ul>
<li>可以使用-&gt;运算符通过指针访问类方法：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">if (saying[i].length()&lt; shortest-&gt;length())</pre></div>
<ul>
<li>可以对对象指针应用解除引用运算符（*）来获得对象</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">if (saying[i]&lt;*first)
    first = &amp;saying[i];</pre></div>
<h3 id="再谈定位new运算符">再谈定位new运算符</h3>

<p>这里说的定位new运算符，是一种相对于普通的new运算符，可以指定内存地址的运算符，程序直接使用我们提供的地址，不管它是否已经被使用，而且可以看到新值直接覆盖在旧值上面。</p>

<p>定位new运算符直接使用传递给它的地址，它不负责判断哪些内存单元已被使用，也不查找未使用的内存块。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">char * buffer = new char[BUF]；

JustTesting * pc1;

pc1 = new (buffer) JustTesting;  //定位new运算符

pc2 = new JustTesting(&#34;Heap&#34;, 20);

pc3 = new (buffer +sizeof(JustTesting)) JustTesting(&#34;Better Idea&#34;, 6);</pre></div>
<p>使用定位new运算符来为对象分配内存，必须确保其析构函数被调用。如何确保呢?、对于在堆中创建的对象，可以这样做。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">delete pc2;</pre></div>
<p>但是对于pc1却不可以，原因在于delete可以与常规new运算符配合使用，却不能与定位new运算符配合使用。</p>

<p>Pc3没有收到new运算符返回的地址。因此delete pc3将导致运行阶段错误。</p>

<p>Delete pc1将释放buffer，而不是pc1；</p>

<p>系统没有为定位new运算符在该内存块中创建的对象调用析构函数。</p>

<p>对于这种情况，需要显式地为定位new运算符创建的对象调用析构函数。这是少数几个需要显式调用析构函数的情形。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">pc3-&gt;~JustTesting();

pc1-&gt;~JustTesting();//销毁对象的顺序，先销毁后创建的对象。类似于栈的先进后出顺序。</pre></div>
<p>仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。</p>

<h2 id="复习各种技术">复习各种技术</h2>

<h2 id="队列模拟">队列模拟</h2>

<p><strong>队列</strong>：是一种抽象的数据类型（Abstract Data Type），可以存储有序的项目序列。新项目被添加在队尾，并可以删除队首的项目。队列有些像栈。栈是在同一端进行添加和删除。这使得栈是一种后进先出的结构，队列是先进先出的。</p>

<p><strong>问题</strong>：Heather银行要在Food Hea超市门口开设一个ATM机。Food Heap需要了解ATM对超市交通可能造成的影响。Heather银行希望对顾客排队等待的时间进行评估，编写一个程序模拟这种情况。</p>

<p><strong>设计</strong>：设计一个队列类，队列中的项目是顾客。设计一个表示顾客的类，编写一个程序来模拟顾客和队列之间的交互。</p>

<h3 id="队列类">队列类</h3>

<p>队列的特征：</p>

<ul>
<li>队列能够存储有序的项目序列；</li>
<li>队列所能容纳的项目数有一定的限制；</li>
<li>应当能够创建空队列；</li>
<li>应当能够检查队列是否为空；</li>
<li>应当能够检查队列是否是满的；</li>
<li>应当能够在队尾添加项目；</li>
<li>应当能够在队首删除项目；</li>
<li>应当能够确定队列中的项目数；</li>
</ul>

<h2 id="总结">总结</h2>

<p>本章介绍了定义和使用类的许多重要方面。其中一些方面是非常微妙甚至是很难理解的。</p>

<p>在类构造函数中，可以使用new为数据分配内存。然后将内存地址赋给类成员。这样，类便可以处理长度不同的字符串，而不用在类设计时提前固定数组的长度。</p>

<p>在类构造函数中使用new，也可能在对象过期时引发问题。</p>

<p>如果对象包含成员指针，同时它指向的内存是由new分配的。则释放用于保存对象的内存并不会自动释放对象成员指针所指向的内存。因此在构造函数中使用new来分配内存时，应在类析构函数中使用delete来释放分配的内存。这样，当对象过期时，将自动释放其指针成员指向的内存。</p>

<p>如果对象包含指向new分配的内存的指针成员，则将一个对象初始化为另一个对象，或将一个对象赋给另一个对象时，也会出现问题。（浅复制），在默认情况下，C++逐个对成员初始化和赋值，这意味着被初始化或被赋值的对象的成员将与原始对象完全相同。如果原始对象的成员指向一个数据块，则副本成员将指向同一个数据块。当程序最终删除这两个对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。</p>

<p>解决方法是：定义一个特殊的复制构造函数来重新定义初始化，并重载赋值运算符。在上述任何一种情况下，新的定义都将创建指向数据的副本，并使新的对象指向这些副本。这样，旧对象和新对象都将引用独立的，相同的数据，而不会重叠。由于同样的原因，必须定义赋值运算符。对于每一种情况，最终目的都是执行深度复制，也就是说，复制实际的数据，而不仅仅是复制指向数据的指针。</p>

<p>对象的存储持续性为自动或外部时，在它不再存在时将自动调用其析构函数。如果使用new运算符为对象分配内存，并将其地址赋给一个指针，则当您将delete用于该指针时将自动为该对象调用析构函数。</p>

<p>然而使用定位new运算符（而不是常规new运算符），为对象分配内存，必须显式地为该对象调用析构函数。方法是使用指向该对象的指针调用析构函数的方法。</p>

<p>C++允许在类中包含结构、类和枚举定义。这些嵌套类型的作用域为整个类，这意味着它们被局限于类中，不会与其他地方定义的同名结构、类和枚举发生冲突。</p>

<p>C++为类构造函数提供了一种可用来初始化数据成员的特殊语法。这种语法包括冒号和有逗号分隔的初始化列表。被放在构造函数参数的右括号后，函数体的左括号前。每个初始化器都有被初始化的成员的名称和包含初始值的括号组成。从概念上讲，这些初始化操作是在对象创建时进行的，此时函数体中的语句还没有被执行。语法如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Queue(int qs): qsize(qs), items(0), front(NULL), rear(NULL){ }</pre></div>
<p>如果数据成员是非静态const成员或引用，则必须采用这种格式，但可将C++11新增的类内初始化用于非静态const成员。</p>

<p>C++允许类内初始化，即在类定义中进行初始化：</p>

<p>这与使用成员初始化列表等价。然而，使用成员初始化列表的构造函数将覆盖相应的类内初始化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Class Queue
{
…
private:
    Node * front = NULL;
    enum {Q_SIZE = 10};
    node * rear = NULL;
    int items = 0;
    const int qsize =Q_SIZE;
…
};</pre></div>
    </div>
    <footer class="post-footer">
     
 
<div class="post-tags">     
     
    <a href="http://jchenTech.github.io/tags/c&#43;&#43;" rel="tag" title="C&#43;&#43;">#C&#43;&#43;#</a>
    
</div>



     <div class="post-nav">
    <div class="post-nav-next post-nav-item">
    
        <a href="http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC11%E7%AB%A0%E4%BD%BF%E7%94%A8%E7%B1%BB/" rel="next" title="C&#43;&#43; primer plus 第11章使用类">
        <i class="fa fa-chevron-left"></i> C&#43;&#43; primer plus 第11章使用类
        </a>
    
    </div>

    <div class="post-nav-prev post-nav-item">
    
        <a href="http://jchenTech.github.io/post/c&#43;&#43;/c&#43;&#43;-primer-plus-%E7%AC%AC13%E7%AB%A0%E7%B1%BB%E7%BB%A7%E6%89%BF/" rel="prev" title="C&#43;&#43; primer plus 第13章类继承">
        C&#43;&#43; primer plus 第13章类继承 <i class="fa fa-chevron-right"></i>
        </a>
    
    </div>
</div>
      
     
     
     




    </footer>
  </article>
</section>

          </div>
        </div>
        <div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>
<aside id="sidebar" class="sidebar">
  <div class="sidebar-inner">

  <ul class="sidebar-nav motion-element">
    <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
      文章目录
    </li>
    <li class="sidebar-nav-overview" data-target="site-overview">
      站点概览
    </li>
  </ul>

    <section class="site-overview sidebar-panel ">
      <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
        src="http://jchenTech.github.io/img/author.jpg"
        alt="陈建君" />
    <p class="site-author-name" itemprop="name">陈建君</p>
    <p class="site-description motion-element" itemprop="description"> 
        Programmer &amp; Huster</p>
</div>
      <nav class="site-state motion-element">
    <div class="site-state-item site-state-posts">
      <a href="http://jchenTech.github.io/post/">
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">日志</span>
      </a>
    </div>
    <div class="site-state-item site-state-categories">    
        <a href="http://jchenTech.github.io/categories/">      
         
        <span class="site-state-item-count">8</span>
        
        <span class="site-state-item-name">分类</span>
        
        </a>
    </div>

    <div class="site-state-item site-state-tags">
        <a href="http://jchenTech.github.io/tags/">
         
        <span class="site-state-item-count">37</span>
        
        <span class="site-state-item-name">标签</span>
        </a>
    </div>
</nav>
      
      
<div class="links-of-author motion-element">
    
        <span class="links-of-author-item">
        <a href="https://github.com/xtfly/" target="_blank" title="GitHub">
            <i class="fa fa-fw fa-github"></i>
            GitHub
        </a>
        </span>
    
        <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/lan-ling-xin-yun" target="_blank" title="知乎">
            <i class="fa fa-fw fa-globe"></i>
            知乎
        </a>
        </span>
    
</div>


      

      <div class="links-of-blogroll motion-element inline">
<script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5b4f2ucxar6&amp;m=0&amp;s=220&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33&amp;bv=35" async="async"></script>
</div>

    </section>
    
<section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
    <div class="post-toc">
        <div class="post-toc-content"><nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#动态内存和类">动态内存和类</a>
<ul>
<li><a href="#复习示例和静态类成员">复习示例和静态类成员</a></li>
<li><a href="#特殊成员函数">特殊成员函数</a></li>
<li><a href="#复制构造函数哪里出了问题">复制构造函数哪里出了问题</a></li>
<li><a href="#赋值运算符">赋值运算符</a></li>
</ul></li>
<li><a href="#改进后的新string类">改进后的新String类</a>
<ul>
<li><a href="#修订后的默认构造函数">修订后的默认构造函数</a></li>
<li><a href="#比较成员函数">比较成员函数</a></li>
<li><a href="#使用中括号表示法访问字符">使用中括号表示法访问字符</a></li>
<li><a href="#静态类成员函数">静态类成员函数</a></li>
<li><a href="#进一步重载赋值运算符">进一步重载赋值运算符</a></li>
</ul></li>
<li><a href="#在构造函数总使用new时应注意的事项">在构造函数总使用new时应注意的事项</a>
<ul>
<li><a href="#应该和不应该">应该和不应该</a></li>
<li><a href="#包含类成员的类的逐成员复制">包含类成员的类的逐成员复制</a></li>
<li><a href="#有关返回对象的说明">有关返回对象的说明</a></li>
<li><a href="#返回对象">返回对象</a></li>
<li><a href="#返回const对象">返回const对象</a></li>
</ul></li>
<li><a href="#使用指向对象的指针">使用指向对象的指针</a>
<ul>
<li><a href="#再探new和delete">再探new和delete</a></li>
<li><a href="#指针和对象小结">指针和对象小结</a></li>
<li><a href="#再谈定位new运算符">再谈定位new运算符</a></li>
</ul></li>
<li><a href="#复习各种技术">复习各种技术</a></li>
<li><a href="#队列模拟">队列模拟</a>
<ul>
<li><a href="#队列类">队列类</a></li>
</ul></li>
<li><a href="#总结">总结</a></li>
</ul></li>
</ul>
</nav></div>
    </div>
</section>

  </div>
</aside>

      </div>
    </main>
   
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  <span itemprop="copyrightYear">  &copy; 
  2009 - 2020</span>
  <span class="with-love"><i class="fa fa-heart"></i></span>
  <span class="author" itemprop="copyrightHolder">陈建君的技术博客</span>
</div>
<div class="powered-by">
  Powered by - <a class="theme-link" href="http://gohugo.io" target="_blank" title="hugo" >Hugo v0.54.0</a>
</div>
<div class="theme-info">
  Theme by - <a class="theme-link" href="https://github.com/xtfly/hugo-theme-next" target="_blank"> NexT
  </a>
</div>


      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      <span id="scrollpercent"><span>0</span>%</span>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
<script type="text/javascript" src="http://jchenTech.github.io/js/vendor/jquery/index.js?v=2.1.3"></script>
<script type="text/javascript" src="http://jchenTech.github.io/js/vendor/fastclick/lib/fastclick.min.js?v=1.0.6"></script> 
<script type="text/javascript" src="http://jchenTech.github.io/js/vendor/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
<script type="text/javascript" src="http://jchenTech.github.io/js/vendor/velocity/velocity.min.js?v=1.2.1"></script>
<script type="text/javascript" src="http://jchenTech.github.io/js/vendor/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="http://jchenTech.github.io/js/vendor/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>

<script src="http://jchenTech.github.io/js/vendor/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>

<script type="text/javascript" src="http://jchenTech.github.io/js/utils.js"></script>
<script type="text/javascript" src="http://jchenTech.github.io/js/motion.js"></script>
<script type="text/javascript" src="http://jchenTech.github.io/js/affix.js"></script>
<script type="text/javascript" src="http://jchenTech.github.io/js/schemes/pisces.js"></script>

<script type="text/javascript" src="http://jchenTech.github.io/js/scrollspy.js"></script>
<script type="text/javascript" src="http://jchenTech.github.io/js/post-details.js"></script>
<script type="text/javascript" src="http://jchenTech.github.io/js/toc.js"></script>

<script type="text/javascript" src="http://jchenTech.github.io/js/bootstrap.js"></script>

<script type="text/javascript" src="http://jchenTech.github.io/js/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] }
  });
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>
</body>
</html>