<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on jchen&#39;s blog</title>
    <link>http://jchenTech.github.io/categories/C&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on jchen&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 23 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://jchenTech.github.io/categories/C++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; primer plus 第15章友元、异常和其他</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC15%E7%AB%A0%E5%8F%8B%E5%85%83%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC15%E7%AB%A0%E5%8F%8B%E5%85%83%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/</guid>
      <description>1 友元 1.1 友元类 友元函数：不是类的成员函数，但是能够访问类的私有数据成员。 之前有个矛盾就是规定非成员函数不能直接访问类的私有数据，但是这会儿却可以，但那只是针对常规非成员函数而言，特殊的非成员函数就可以访问类的私有数据——友元函数。 友元函数就是这么特殊，虽然在类中声明，却不是类的成</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第14章C&#43;&#43;中的代码重用</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC14%E7%AB%A0C&#43;&#43;%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC14%E7%AB%A0C&#43;&#43;%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/</guid>
      <description>C++的主要目的是促进代码重用。 公有继承是实现这一目标的机制之一； 本身是另一个类的成员，这种方法称为包含、组合、层次化。 另一种方法是使用私有、保护继承。 通常包含、私有继承和保护继承用于实现has-a关系，即新的类型包含另一个类的对象。 多重继承使得能够使用两个或更多的基类派生出新的</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第13章类继承</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC13%E7%AB%A0%E7%B1%BB%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC13%E7%AB%A0%E7%B1%BB%E7%BB%A7%E6%89%BF/</guid>
      <description>1 一个简单得基类 从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。 1.1 派生一个类 class RatedPlayer :public TableTennisPlayer { } 冒号指出RatedPlayer 类的基类是TableTennisPlayer类。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将称为派生</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第12章类和动态内存分配</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC12%E7%AB%A0%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC12%E7%AB%A0%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>1 动态内存和类 C++在分配内存时是让程序在运行时决定内存分配，而不是在编译时决定。这样，可根据程序的需要，而不是根据一系列严格的存储类型规则来使用内存。C++使用new和delete运算符来动态控制内存。 1.1 复习示例和静态类成员 这个程序使用了一个新的存储类型：静态类成员： //strngbad.h #include&amp;lt;iostream&amp;gt; #ifndef STRNGBAD_H_ #define</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第11章使用类</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC11%E7%AB%A0%E4%BD%BF%E7%94%A8%E7%B1%BB/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC11%E7%AB%A0%E4%BD%BF%E7%94%A8%E7%B1%BB/</guid>
      <description>C++ primer plus 第11章使用类 1 运算符重载 operatorop(argumnt-list) 例如，operator+()重载+运算符。 2 计算时间：一个运算符重载示例 如果要计算两个时间之和，如2小时40分与1小时30分之和，可以重载运算符+，在类中的成员函数为： Time operator+(const Time &amp;amp; t) const; 2.1 重载限制 重载后的运算符至少有一个操作数是用户定义的类型，这将防止</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第10章对象和类</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC10%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC10%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</guid>
      <description>C++ primer plus 第10章对象和类 1 过程性编程和面向对象编程 2 抽象和类 2.1 ifndef 文件中的#ifndef 头件的中的#ifndef，这是一个很关键的东西。 需要注意的是，#ifndef起到的效果是防止一个源文件两次包含同一个头文件，而不是防止两个源文件包含同一个头文件。 而编译时，这两个C文件要一同编译成</description>
    </item>
    
  </channel>
</rss>
