<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jchen&#39;s blog</title>
    <link>http://jchenTech.github.io/</link>
    <description>Recent content on jchen&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 11 Nov 2020 14:00:00 +0800</lastBuildDate><atom:link href="http://jchenTech.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaWeb连载12 | JSON和AJAX</title>
      <link>http://jchenTech.github.io/post/JavaWeb/JSON%E5%92%8CAJAX/</link>
      <pubDate>Wed, 11 Nov 2020 14:00:00 +0800</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/JSON%E5%92%8CAJAX/</guid>
      <description>1 什么是JSON？ JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python等）。 这样就使得 JSON 成为理想的数据交换格式。 json 是一种轻量级的数据交换格式。轻量级指的是</description>
    </item>
    
    <item>
      <title>JavaWeb连载11 | Filter过滤器</title>
      <link>http://jchenTech.github.io/post/JavaWeb/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Tue, 10 Nov 2020 20:55:00 +0800</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>1 什么是Filter过滤器 Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是：Servlet 程序、Listener 监听器、Filter 过滤器 Filter 过滤器它是 JavaEE 的规范。也就是接口 Filter 过滤器它的作用是： 拦截请求，过滤响应。 拦截请求常见的应用场景有： 权限检查 日记操作 事务管理 ……等等 2 Filter初</description>
    </item>
    
    <item>
      <title>JavaWeb连载10 | Cookie和Session</title>
      <link>http://jchenTech.github.io/post/JavaWeb/Cookie%E5%92%8CSession/</link>
      <pubDate>Tue, 10 Nov 2020 18:55:00 +0800</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/Cookie%E5%92%8CSession/</guid>
      <description>1 会话技术 会话：一次会话中包含多次请求和响应 注：一次会话表示浏览器第一次给服务器发送请求，会话建立，直到有一方断开为止 功能：在一次会话的多次请求间共享数据 方式： (1) 客户端会话技术：Cookie (2) 服务器端会话技术：Session 2 Cookie会话 2.1 什么是Cookie Cookie 翻译过来是饼干的</description>
    </item>
    
    <item>
      <title>JavaWeb连载09 | EL表达式</title>
      <link>http://jchenTech.github.io/post/JavaWeb/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 08 Nov 2020 21:55:00 +0800</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1 EL表达式简介 EL表达式全称：Expression Language，即表达式语言 EL表达式作用：代替JSP页面中表达式脚本进行数据的输出 EL表达式比JSP的表达式脚本简洁很多 EL表达式的格式是：${表达式} ，注：EL表达式写在jsp页面中，表达式一般是域对象的key 代码演示：在</description>
    </item>
    
    <item>
      <title>JavaWeb连载08 | JSP</title>
      <link>http://jchenTech.github.io/post/JavaWeb/JSP/</link>
      <pubDate>Sun, 08 Nov 2020 18:55:00 +0800</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/JSP/</guid>
      <description>1 JSP的介绍与创建 JSP的全称是Java Server Pages，即Java的服务器页面 JSP的主要作用是代替Servlet程序回传HTML页面的数据 web目录(或其他)右击 &amp;ndash;&amp;gt; new &amp;ndash;&amp;gt; JSP/JSPX &amp;ndash;&amp;gt; 输入文件名 &amp;ndash;&amp;gt; 选择JSP file创建 Servlet程序回传HTML页面数据（非常繁琐）： public class PrintHtml extends HttpServlet { @Override protected void doGet(HttpServletRequest</description>
    </item>
    
    <item>
      <title>JavaSE连载 | Java语言位运算符详解</title>
      <link>http://jchenTech.github.io/post/Java/Java%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 06 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Java/Java%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%A6%E8%A7%A3/</guid>
      <description>1 位运算符概述 很多编程语言都有位运算符，Java语言也不例外。在Java语言中，提供了7种位运算符，分别是按位与&amp;amp;、按位或|、按位异或^、取反~、左移&amp;lt;&amp;lt;、带符号右移&amp;gt;&amp;gt;和无符号右移&amp;gt;&amp;gt;&amp;gt;。这些运算符当中，仅有~是单目运算符，其他</description>
    </item>
    
    <item>
      <title>Java后端学习路线</title>
      <link>http://jchenTech.github.io/route/</link>
      <pubDate>Fri, 30 Oct 2020 00:13:27 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/route/</guid>
      <description>s啊实打实打算</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>http://jchenTech.github.io/about/</link>
      <pubDate>Fri, 30 Oct 2020 00:13:27 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/about/</guid>
      <description>本人的相关经历 本科就读于西南大学含弘学院网络工程专业，在上课之余，主要从事于社交网络、社团挖掘和智能算法的科研工作，以第一作者身份在IEEE ACCESS期刊和ICNC-FSKD国际会议发表论文两篇。 在本科期间，曾申请前往美国加州大学伯克利分校UCB进行交流访学，主要选修的课程为C</description>
    </item>
    
    <item>
      <title>JDBC核心技术</title>
      <link>http://jchenTech.github.io/post/DataBase/JDBC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Wed, 28 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/DataBase/JDBC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</guid>
      <description>1 JDBC概述 1.1 数据的持久化 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在</description>
    </item>
    
    <item>
      <title>JavaSE连载 | IO流</title>
      <link>http://jchenTech.github.io/post/Java/IO%E6%B5%81/</link>
      <pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Java/IO%E6%B5%81/</guid>
      <description>1 File类的使用 1.1 File类的理解 File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹) File类声明在java.io包下 File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法， 并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容</description>
    </item>
    
    <item>
      <title>JavaSE连载 | 反射</title>
      <link>http://jchenTech.github.io/post/Java/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Java/%E5%8F%8D%E5%B0%84/</guid>
      <description>1 反射的概述 1.1 反射主要内容 Java反射机制 理解Class类并获取Class实例 类的加载与ClassLoader的理解 创建运行时类的对象 获取运行时类的完整结构 调用运行时类的指定结构 反射的应用：动态代理 1.2 反射的理解 Reflection(反射)是被视为动态语言的关键，反射机制允许程序在</description>
    </item>
    
    <item>
      <title>二叉树的遍历java实现</title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86java%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86java%E5%AE%9E%E7%8E%B0/</guid>
      <description>1 二叉树遍历方法 二叉树深度优先遍历（配合leetcode进行练习） 前序遍历： 144. 二叉树的前序遍历 后序遍历： 145. 二叉树的后序遍历 中序遍历： 94. 二叉树的中序遍历 二叉树广度优先遍历 层序遍历：102. 二叉树的层序遍历 2 深度优先遍历 2.1 递归解法 2.1.1 通用框架 public List&amp;lt;Integer&amp;gt; mlr(TreeNode root){ List&amp;lt;Integer&amp;gt; res=new ArrayList&amp;lt;&amp;gt;(); helper(res,root); return res; } 2.1.2 前序遍历 访问顺序：先</description>
    </item>
    
    <item>
      <title>JavaSE连载 | 多线程</title>
      <link>http://jchenTech.github.io/post/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>1 程序、进程、线程的理解 程序(program) 概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。 进程(process) 概念：程序的一次执行过程，或是正在运行的一个程序。 说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程(thre</description>
    </item>
    
    <item>
      <title>JavaSE连载 | 网络编程</title>
      <link>http://jchenTech.github.io/post/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>1 InetAddress类的使用 1.1 实现网络通信需要解决的两个问题 如何准确地定位网络上一台或多台主机；定位主机上的特定的应用 找到主机后如何可靠高效地进行数据传输 1.2 网络通信的两个要素 对应问题一：IP和端口号 对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物</description>
    </item>
    
    <item>
      <title>JavaWeb连载05 | XML</title>
      <link>http://jchenTech.github.io/post/JavaWeb/XML/</link>
      <pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/XML/</guid>
      <description>1 XML 简介 1.1 什么是xml？ xml 是可扩展的标记性语言。 1.2 xml 的主要作用 用来保存数据，而且这些数据具有自我描述性 它还可以做为项目或者模块的配置文件 还可以做为网络传输数据的格式（现在JSON 为主）。 2 xml 语法 文档声明 元素（标签） xml 属性 xml 注释 文本区域（CDATA 区） 2.1 文档声明 &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; xml 声明。 &amp;lt;!-- xml 声</description>
    </item>
    
    <item>
      <title>JavaWeb连载06 | Tomcat</title>
      <link>http://jchenTech.github.io/post/JavaWeb/Tomcat/</link>
      <pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/Tomcat/</guid>
      <description>1 JavaWeb的概念 JavaWeb是指所有通过Java语言编写的可以通过浏览器访问的程序的总称， JavaWeb是基于请求和响应来开发的 请求(Request)：指客户端给服务器发送数据 响应(Response)：指服务器给客户端回传数据 请求和响应的关系： 2 Web资源的分类 静态资源：</description>
    </item>
    
    <item>
      <title>JavaWeb连载07 | Servlet</title>
      <link>http://jchenTech.github.io/post/JavaWeb/Servlet/</link>
      <pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/Servlet/</guid>
      <description>1 Servlet技术 1.1 Servlet介绍 Servlet时JavaEE规范（接口）之一 Servlet是JavaWeb三大组件之一，三大组件分别是Servlet，Filter过滤器和Listener过滤器 Servlet是运行在服务器上的一个Java程序，可以接受客户端发来的请求，并响</description>
    </item>
    
    <item>
      <title>JavaSE连载 | Java集合框架</title>
      <link>http://jchenTech.github.io/post/Java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Java/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</guid>
      <description>1 数组与集合 集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中) 数组存储的特点： 一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了。我们也就只能</description>
    </item>
    
    <item>
      <title>JavaWeb连载04 | jQuery介绍</title>
      <link>http://jchenTech.github.io/post/JavaWeb/jQuery%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/jQuery%E4%BB%8B%E7%BB%8D/</guid>
      <description>1 jQuery介绍 什么是jQuery ? jQuery，顾名思义，也就是JavaScript 和查询（Query），它就是辅助JavaScript 开发的js 类库。 jQuery 核心思想！！！ 它的核心思想是write less, do more(写得更少,做得更多)，所以它实现了很多浏览器的兼容问题。 jQuery 流行程度 jQuery 现</description>
    </item>
    
    <item>
      <title>JavaWeb连载03 | JavaScript入门</title>
      <link>http://jchenTech.github.io/post/JavaWeb/JavaScript%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 24 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/JavaScript%E5%85%A5%E9%97%A8/</guid>
      <description>1 JavaScript介绍 Javascript 语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行JavaScript 代码。 JS 是Netscape 网景公司的产品，最早取名为LiveScript;为了吸引更多java程序员。更名为JavaScript。 JS 是弱类型，Java 是强</description>
    </item>
    
    <item>
      <title>Leetcode连载 | 链表</title>
      <link>http://jchenTech.github.io/post/Leetcode/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 24 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Leetcode/%E9%93%BE%E8%A1%A8/</guid>
      <description>找出两个链表的交点 160. 相交链表(easy) 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值</description>
    </item>
    
    <item>
      <title>Git入门与常用指令</title>
      <link>http://jchenTech.github.io/post/Git/Git%E5%85%A5%E9%97%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Git/Git%E5%85%A5%E9%97%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</guid>
      <description>1 获取 Git 仓库 有两种取得 Git 项目仓库的方法。 在现有目录中初始化仓库: 进入项目目录运行 git init 命令,该命令将创建一个名为 .git 的子目录。 从一个服务器克隆一个现有的 Git 仓库: git clone [url] 自定义本地仓库的名字: git clone [url] directoryname 2 记录每次更新到仓库 检测当前文件状态 : git status 提出更改（把它们添加到暂存区）：git add filename (针</description>
    </item>
    
    <item>
      <title>JavaWeb连载02 | CSS技术</title>
      <link>http://jchenTech.github.io/post/JavaWeb/CSS%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/CSS%E6%8A%80%E6%9C%AF/</guid>
      <description>1 CSS技术介绍 CSS 是「层叠样式表单」。是用于(增强)控制网页样式并允许将样式信息与网页内容分离的一种标记性语言。 2 CSS语法规则 选择器：浏览器根据“选择器”决定受CSS 样式影响的HTML 元素（标签）。 属性(property) 是你要改变的样式名，并且每个属性都有一个值。属性和值被冒</description>
    </item>
    
    <item>
      <title>Leetcode连载 | 数组</title>
      <link>http://jchenTech.github.io/post/Leetcode/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Leetcode/%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/</guid>
      <description>移动零 283. 移动零 (Easy) 给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 1. 必须在原数组上操作，不能拷贝额外的数组。 2. 尽量减少操作次数。 class Solution { public void moveZeroes(int[] nums) { if (nums == null) { return; } //使用双指针i,j，用指针i遍历数组，用指针j记录</description>
    </item>
    
    <item>
      <title>MySQL基础</title>
      <link>http://jchenTech.github.io/post/DataBase/MySQL%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/DataBase/MySQL%E5%9F%BA%E7%A1%80/</guid>
      <description>1 数据库相关介绍 1.1 数据库的好处 持久化数据到本地 可以实现结构化查询，方便管理 1.2 数据库相关概念 DB：数据库，保存一组有组织的数据的容器 DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据 SQL:结构化查询语言，用于和DBMS通信的语言 1.3 数据库存储数据的特点 将数据放</description>
    </item>
    
    <item>
      <title>JavaWeb连载01 | HTML入门介绍</title>
      <link>http://jchenTech.github.io/post/JavaWeb/HTML%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/JavaWeb/HTML%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</guid>
      <description>1 网页的组成部分 页面由三部分内容组成：内容（结构）、表现、行为。 内容（结构），是我们在页面中可以看到的数据。我们称之为内容。一般内容我们使用HTML技术来展示。 表现，指的是这些内容在页面上的展示形式。比如说。布局，颜色，大小等等。一般使用CSS 技术实现 行为，指的是页面中元素与输入</description>
    </item>
    
    <item>
      <title>Java常用方法总结</title>
      <link>http://jchenTech.github.io/post/Java/Java%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Java/Java%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>String类方法 方法 描述 int length() 返回字符串的长度： return value.length char charAt(int index) 返回某索引处的字符return value[index] boolean isEmpty() 判断是否是空字符串：return value.length == 0 String toLowerCase() 使用默认语言环境，将 String 中的所字符转换为小写 String toUpperCase() 使用默认语言环境，将 String 中的所字符转换为大写 String trim() 返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj) 比较字</description>
    </item>
    
    <item>
      <title>【CS61B】LEC9 Extends, Casting, Higher Order Functions</title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC9/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC9/</guid>
      <description>LEC9 Extends, Casting, Higher Order Functions 1 接口和实现 Interface and Implement 早先我们介绍了类和接口，我们意识到在编写类时，有时会编写很多冗余代码。 这将我们引向继承，即某个对象不需要重新定义其父对象的所有性质。我们可以从接口和类继承，语法略有不同。 对于要继承接口性质的类，语法如下（其中SLList是一个类，而List61B是一</description>
    </item>
    
    <item>
      <title>如何删除Github上的文件夹</title>
      <link>http://jchenTech.github.io/post/Git/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Github%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Git/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4Github%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>&lt;p&gt;要知道在github上只能删除仓库,却无法删除文件夹或文件, 所以只能通过命令来解决，&lt;/p&gt;
&lt;p&gt;（1）首先进入master文件夹下, &lt;code&gt;Git Bash Here&lt;/code&gt; ,打开命令窗口 &lt;code&gt;$ git --help&lt;/code&gt; 帮助命令&lt;/p&gt;
&lt;p&gt;（2）&lt;code&gt;$ git pull origin master&lt;/code&gt; 将远程仓库里面的项目拉下来，&lt;code&gt;$ dir&lt;/code&gt;  查看有哪些文件夹&lt;/p&gt;
&lt;p&gt;（3）此时&lt;code&gt;$ git rm -r --cached target&lt;/code&gt;  删除&lt;code&gt;target&lt;/code&gt;文件夹，&lt;code&gt;$ git commit -m &#39;Deleted target&#39;&lt;/code&gt;  提交。&lt;/p&gt;
&lt;p&gt;（4）最后&lt;code&gt;$ git push -u origin master &lt;/code&gt;将本次更改更新到github项目上去，删除完毕。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【CS61B】LEC8 Inheritance, Implements</title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC8/</link>
      <pubDate>Fri, 28 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC8/</guid>
      <description>LEC8 Inheritance, Implements 1 方法重载 Overloading: 在Java中，类方法名字可以相同，但参数不同。例如，Math 类可以具有 add(int a, int b) 方法和 add(float a, float b) 方法。 Java编译器足够智能，可以根据传入的参数选择正确的方法。具有相同名称但不同参数的方法被认为被重载。 2 使代码通用： 考虑一个仅使用 AList 作为参数的 largestNumber 方法。缺点是，无论我们</description>
    </item>
    
    <item>
      <title>【CS61B】链表IntList、SLList、DLList、AList整理</title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61B%E9%93%BE%E8%A1%A8IntListSLListDLListAList/</link>
      <pubDate>Fri, 28 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61B%E9%93%BE%E8%A1%A8IntListSLListDLListAList/</guid>
      <description>&lt;p&gt;本文整理了CS61B中的链表IntList、SLList、DLList、AList实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>十大经典排序算法总结（基于Java实现）</title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%9F%BA%E4%BA%8EJava%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 21 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%9F%BA%E4%BA%8EJava%E5%AE%9E%E7%8E%B0/</guid>
      <description>1 排序算法说明 1.1 排序的定义 对一序列对象根据某个关键字进行排序。 1.2 术语说明 稳定 ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定 ：如果a原本在br的前面，而a=b，排序之后a可能会出现在b的后面； 内排序 ：所有排序操作都在内存中完成； 外排序 ：由于数据太大，因此把数据放在</description>
    </item>
    
    <item>
      <title>【CS61B】Proj1A Data Structures -- LinkedListDeque and ArrayDeque </title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BProj1A/</link>
      <pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BProj1A/</guid>
      <description>&lt;p&gt;项目要求：https://sp18.datastructur.es/materials/proj/proj1a/proj1a&lt;/p&gt;
&lt;p&gt;代码地址：https://github.com/jchenTech/cs61b/tree/master/proj1a&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【CS61B】LEC6 ALists, Resizing, vs. SLists </title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC6/</link>
      <pubDate>Tue, 18 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC6/</guid>
      <description>ALists, Resizing, vs. SLists https://sp18.datastructur.es/ 列表与数组 我们的 DLList 有一个缺点。获得第i个项目很慢；我们必须从头到尾扫描列表中的每个项目，直到到达第 i 个项目为止。但是，对于名为 A 的数组，我们可以使用方括号表示法 A[i] 快速访问第i个项目。因此，我们的目标是实现带有数组的列表。 AList AList 将具有与 DLList 相同的API，这意味着它将具有与 DLList 相</description>
    </item>
    
    <item>
      <title>【CS61B】LEC5 DLLists, Arrays </title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC5/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC5/</guid>
      <description>DLLists, Arrays https://sp18.datastructur.es/ SLList的缺点 addLast() 方法非常慢！我们无法添加到列表的中间。另外，如果我们的列表很大，那么我们必须从最前面开始，并一直循环到列表的最后，然后再添加元素。 一个Naive的解决方法 回想一下，我们将列表的大小作为SLList的实例变量进行了缓存。如果我们也缓存列表中的最后一个元素怎</description>
    </item>
    
    <item>
      <title>【CS61B】LEC4 SLLists, Nested Classes, Sentinel Nodes </title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC4/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC4/</guid>
      <description>SLLists, Nested Classes, Sentinel Nodes https://sp18.datastructur.es/ 裸数据结构Naked Data Structure IntLists很难使用。为了正确使用 IntLists，即使对于简单的列表相关任务，程序员也必须理解并利用递归。 Adding Clothes 我们首先将 IntList 类转变为 IntNode 类。然后我们将删除IntNode类中的所有方法，接下来我们将创建一个名为 SLList 的新类，该类首先包含实例变量，并</description>
    </item>
    
    <item>
      <title>【CS61B】LEC3 References, Recursion, and Lists </title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC3/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC3/</guid>
      <description>References, Recursion, and Lists https://sp18.datastructur.es/ Bits: 计算机将信息存储为内存，并使用0或1的位序列表示此信息。 Primitives： Primitives是信息的表示。 Java有8种原始类型：byte, short, int, long, float, double, boolean, and char。每个基本类型由一定数量的位表示。例如，整型是32位，而字节是8位。 **声明基元：**当我们将变量声</description>
    </item>
    
    <item>
      <title>【CS61B】LEC2 Defining and Using Classes </title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC2/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC2/</guid>
      <description>1 Static vs Non-Static Methods 1.1 Static Methods Java中的所有代码都必须是类class中的一部分，大多数代码在方法methods中： public class Dog { public static void makeNoise() { System.out.println(&amp;quot;Bark!&amp;quot;); } } 如果运行 Dog 类，将会报错： $ java Dog Error: Main method not found in class Dog, please define the main method as: public static void main(String[] args) 为了执行Dog类，我们需要添加一个main方法。或者，我们也可以单独创建一个 DogLauncher 类来执行</description>
    </item>
    
    <item>
      <title>【CS61B】LEC1 Intro, Hello World </title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC1/</link>
      <pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61BLEC1/</guid>
      <description>从今天开始，将follow数据结构的一门经典课程，UC Berkeley的CS61B。 1 Hello World Let&amp;rsquo;s look at our first Java program. When run, the program below prints &amp;ldquo;Hello world!&amp;rdquo; to the screen. public class HelloWorld { public static void main(String[] args) { System.out.println(&amp;quot;Hello world!&amp;quot;); } } For those of you coming from a language like Python, this probably seems needlessly verbose. However, it&amp;rsquo;s all for good reason, which we&amp;rsquo;ll come to understand over the next couple of weeks. Some key syntactic features to notice: The program consists of a class declaration, which is declared using the keywords public class. In Java, all code lives inside of classes. The code</description>
    </item>
    
    <item>
      <title>【CS61B】利用Github管理课程代码并搭建Auto Grade环境</title>
      <link>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61B%E5%88%A9%E7%94%A8Github%E7%AE%A1%E7%90%86%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%B9%B6%E6%90%AD%E5%BB%BAAuto-Grade%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/CS61B%E5%88%A9%E7%94%A8Github%E7%AE%A1%E7%90%86%E8%AF%BE%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%B9%B6%E6%90%AD%E5%BB%BAAuto-Grade%E7%8E%AF%E5%A2%83/</guid>
      <description>&lt;p&gt;学习CS61B的一个挑战便是需要学习使用Git and github。由于非伯克利注册的学生不能够得到instructional number,因此我们需要在自己的github上创建一个专有的repository，我将自己的命名为cs61b-sp18，有了这个repo，我们就可以把本地的课程代码/作业代码/项目代码推送到这个远程库中，然后上传到autograder进行评分。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu18.04安装NVIDA显卡驱动</title>
      <link>http://jchenTech.github.io/post/Linux/Ubuntu18.04%E5%AE%89%E8%A3%85Nvida%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Linux/Ubuntu18.04%E5%AE%89%E8%A3%85Nvida%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</guid>
      <description>今天的目标是在 Ubuntu 18.04 上安装 NVIDIA 显卡驱动，请注意，显卡一定要是 NVIDIA 的显卡才能按照这篇文章的方法安装。 先来说说带有 NVIDIA 独立显卡的电脑为什么要安装 NVIDIA 显卡驱动吧。下面是我从维基百科摘抄的显卡工作原理的介绍： 显卡是插在主板上的扩展槽里的（现在一般是 PCI-E 插槽，此前还有 AGP、PCI、ISA 等插槽）。它</description>
    </item>
    
    <item>
      <title>Ubuntu18.04桌面版双系统安装教程</title>
      <link>http://jchenTech.github.io/post/Linux/Ubuntu18.04%E6%A1%8C%E9%9D%A2%E7%89%88%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Linux/Ubuntu18.04%E6%A1%8C%E9%9D%A2%E7%89%88%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</guid>
      <description>由于后面将要在linux系统上进行图像处理相关工作，所以需要安装Linux操作系统，目前采用的是Ubuntu18.04桌面版本方便个人使用，由于在虚拟机上较慢，采取双系统安装方式。 1 准备工作 注：本篇文章以 Ubuntu18.04.1 的安装为例。 准备工作在其他系统上进行，我这里在 Windows10 上进行以下的三步。 1.1 下载 Ubuntu</description>
    </item>
    
    <item>
      <title>【论文笔记】MRP: Fast Haze Removal for Nighttime Image Using Maximum Reflectance Prior</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0MRP%E5%A4%9C%E9%97%B4%E5%8E%BB%E9%9B%BE/</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0MRP%E5%A4%9C%E9%97%B4%E5%8E%BB%E9%9B%BE/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在本文中，我们解决了单个夜间图像中的雾霾去除问题，即使存在杂色和非均匀照明。核心思想在于先前的新型最大反射率。我们首先介绍&lt;strong&gt;夜间朦胧成像模型&lt;/strong&gt;，其中包括直接衰减项和散射项中的局部环境照明项目。然后，我们提出一个简单但有效的图像先验，&lt;strong&gt;最大反射先验，以估计变化的环境照明&lt;/strong&gt;。最大反射率先验基于关键观察：对于大多数白天无雾图像块，每个颜色通道在某些像素处具有非常高的强度。对于夜间雾度图像，每个颜色通道的局部最大强度主要由环境照明贡献。因此，我们可以&lt;strong&gt;直接估计环境照度和透射图，从而恢复高质量的雾状图像&lt;/strong&gt;。各种夜间图像的实验结果证明了所提出方法的有效性。特别是，我们的方法具有计算效率的优势，比现有技术方法快10-100倍。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>DehazeZoo：图像&amp;视频去雾清晰化资源大全（论文/数据集/开源项目）</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%9B%86/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%9B%86/</guid>
      <description>&lt;p&gt;图像去雾的目的是消除雾霾环境对图像质量的影响，增加图像的可视度，是图像处理和计算机视觉领域共同关切的前沿课题，吸引了国内外研究人员的广泛关注。在github上 cxtalk列举了图像去雾近年来经典论文、评估指标与数据集，在此转载以便记录。&lt;/p&gt;
&lt;p&gt;转载自：DehazeZoo (Single Image vs. Video Based) &lt;a href=&#34;https://github.com/cxtalk/DehazeZoo&#34;&gt;https://github.com/cxtalk/DehazeZoo&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【论文笔记】AOD-Net: An All-in-One Network for Dehazing and Beyond</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0AOD-Net/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0AOD-Net/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;摘要:本文提出了一种用卷积神经网络（CNN）构建的图像去雾模型，称为一体化除雾网络（AOD-Net）。它是基于重新配制的大气散射模型设计的。 AOD-Net不是像大多数先前模型那样分别估算传输矩阵和大气光，而是通过轻量级CNN直接生成清晰图像。这种新颖的端到端设计使得将AOD-Net嵌入到其他深度模型（例如，faster R-CNN）中变得容易，以改善对模糊图像的高级任务性能。在合成和自然模糊图像数据集上的实验结果证明了我们在PSNR，SSIM和主观视觉质量方面优于现有技术的优越性能。此外，当将AOD-Net与faster R-CNN连接并从头到尾训练联合管道时，我们目睹了对模糊图像的对象检测性能的大幅提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;关键词:去雾，图像恢复，深度学习，联合训练，物体检测。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>【论文笔记】MSCNN: Single Image Dehazing via Multi-Scale Convolutional Neural Networks</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0MSCNN/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0MSCNN/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;现存方法缺点：The performance of existing image dehazing methods is limited by hand-designed features, such as the dark channel, color disparity and maximum contrast, with complex fusion schemes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;提出的方法：In this paper, we propose a multi-scale deep neural network for single-image dehazing by learning the mapping between hazy images and their corresponding transmission maps. The proposed algorithm consists of a &lt;strong&gt;coarse-scale net which predicts a holistic transmission map based on the entire image&lt;/strong&gt;, and &lt;strong&gt;a fine-scale net which refines results locally. To train the multi-scale deep network&lt;/strong&gt;, we synthesize a dataset comprised of hazy images and corresponding transmission maps based on the NYU Depth dataset. Extensive experiments demonstrate that the proposed algorithm performs favorably against the state-of-the-art methods on both synthetic and real-world images in terms of quality and speed.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>【论文笔记】DehazeNet: An End-to-End System for Single Image Haze Removal</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0DehazeNet/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0DehazeNet/</guid>
      <description>&lt;p&gt;该文章提出一种名为DehazeNet的可训练的端到端系统，用于传输值估计。 DehazeNet将模糊图像作为输入，并输出其中间透射图，随后用于通过大气散射模型恢复无雾图像。 DehazeNet采用基于卷积神经网络的深层架构，&lt;strong&gt;其层专门设计用于体现图像去雾中已建立的假设/先验&lt;/strong&gt;。具体而言，Maxout单位的图层用于特征提取，这可以生成几乎所有与雾相关的特征。我们还在DehazeNet中提出了一种新的非线性激活函数，称为&lt;strong&gt;双边整流线性单元&lt;/strong&gt;，它能够提高恢复的无雾图像的质量。我们在提议的&lt;strong&gt;DehazeNet的组件与现有方法中使用的组件之间建立连接&lt;/strong&gt;。基准图像的实验表明，DehazeNet比现有方法具有更高的性能，同时保持高效和易用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【论文笔记】暗通道先验去雾算法</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E6%9A%97%E9%80%9A%E9%81%93%E5%85%88%E9%AA%8C%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 07 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%E6%9A%97%E9%80%9A%E9%81%93%E5%85%88%E9%AA%8C%E5%8E%BB%E9%9B%BE%E7%AE%97%E6%B3%95/</guid>
      <description>雾霾是由空气中的灰尘和烟雾等小的漂浮颗粒产生的常见大气现象。这些漂浮的颗粒极大地吸收和散射光，导致图像质量下降。在雾霾影响下，视频监控，远程感应，自动驾驶等许多实际应用很容易受到威胁，检测和识别等高级计算机视觉任务很难完成。因此，图像去雾（除雾）成为一种越来越重要的技术。在图像去</description>
    </item>
    
    <item>
      <title>网络挖掘及其相关应用</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/</guid>
      <description>网络挖掘及其相关应用 1 网络结构 1.1 网络统计特征 网络模型许多概念来自于图论，因为网络模型本质上是一个由节点和边组成的图。以下为网络模型中常用的统计概念。 度（Degree）：节点的度定义为与该节点相连的边的数目。在有向图中，所有指向某节点的边的数量叫作该节点的入度，所有从该节点出发指向</description>
    </item>
    
    <item>
      <title>Python之Matplotlib绘图基础</title>
      <link>http://jchenTech.github.io/post/Python/python%E4%B9%8Bmatplotlib%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/Python/python%E4%B9%8Bmatplotlib%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/</guid>
      <description>Python十分适合用来进行数据分析，因为它有“四板斧”，分别是Matplotlib、NumPy、SciPy/Pandas。Matplotlib是画图工具，NumPy是矩阵运算库，SciPy是数学运算工具，Pandas是数据处理的工具。本篇文章将介绍python的绘图工具Matp</description>
    </item>
    
    <item>
      <title>循环神经网络RNN介绍</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 03 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN%E4%BB%8B%E7%BB%8D/</guid>
      <description>循环神经网络(Recurrent Neural Networks，RNN)已经在众多自然语言处理(Natural Language Processing, NLP)中取得了巨大成功以及广泛应用。本文将对RNN进行简单介绍。 1 神经网络基础 神经网络可以当做是能够拟合任意函数的黑盒子，只要训练数据足够，给定特定的x，就能得到希望的y，结构</description>
    </item>
    
    <item>
      <title>深度学习目标检测：R-CNN, SSPNet, Fast R-CNN, Faster R-CNN, YOLO, SSD</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BR-CNN-SSPNet-Fast-R-CNN-Faster-R-CNN-YOLO-SSD/</link>
      <pubDate>Fri, 03 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BR-CNN-SSPNet-Fast-R-CNN-Faster-R-CNN-YOLO-SSD/</guid>
      <description>&lt;p&gt;Object Detection，在给定的图像中，找到目标图像的位置，并标注出来。 或者是，图像中有那些目标，目标的位置在那。这个目标，是限定在数据集中包含的目标种类，比如数据集中有两种目标:狗，猫。 就在图像找出来猫，狗的位置，并标注出来 是狗还是猫。&lt;/p&gt;
&lt;p&gt;这就涉及到两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标识别，识别出来目标是猫还是狗，Image Classification解决了图像的识别问题。&lt;/li&gt;
&lt;li&gt;定位，找出来猫狗的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将详细介绍目前深度学习目标检测算法的几种热门算法R-CNN, SSPNet, Fast R-CNN, Faster R-CNN, YOLO, SSD的比较&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>hugo博客建立归档页面</title>
      <link>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/hugo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%9D%A2/</link>
      <pubDate>Tue, 31 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/hugo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%9D%A2/</guid>
      <description>在 Hugo 中默认只生成 tags 和 categories 两个页面，没有 archives （归档）页面，所以我们需要自己实现 1 新建归档单页面模板 首先，在 themes/主题/layouts 目录创建一个目录 archives 然后在里面新建一个文件 single.html。 2 替换归档页面模板代码 注意我们接下来要覆盖 themes/主题/layouts/_d</description>
    </item>
    
    <item>
      <title>Hugo插入图片</title>
      <link>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/Hugo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/Hugo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</guid>
      <description>在写博客时，常常需要在文章中插入图片，Hugo有多种图片插入方式，可以将图片存在本地引用、将图片放在CDN引用或建立图床。 1 本地引用 1.1 绝对路径 当图片使用较少时，可以将图片存在 static/images/具体文章 目录下的，在部署当github page上面时，会将图片推到github</description>
    </item>
    
    <item>
      <title>卷积神经网络</title>
      <link>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</guid>
      <description>&lt;p&gt;卷积神经网络（CNN）是一种深层神经网络，已被证明在计算机视觉任务中表现出色，例如图像分类，目标检测，目标定位和神经样式转换。 在这篇文章中，我将详细地介绍构成卷积神经网络的不同层：卷积层，池化层和完全连接层。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第15章友元、异常和其他</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC15%E7%AB%A0%E5%8F%8B%E5%85%83%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC15%E7%AB%A0%E5%8F%8B%E5%85%83%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/</guid>
      <description>1 友元 1.1 友元类 友元函数：不是类的成员函数，但是能够访问类的私有数据成员。 之前有个矛盾就是规定非成员函数不能直接访问类的私有数据，但是这会儿却可以，但那只是针对常规非成员函数而言，特殊的非成员函数就可以访问类的私有数据——友元函数。 友元函数就是这么特殊，虽然在类中声明，却不是类的成</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第14章C&#43;&#43;中的代码重用</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC14%E7%AB%A0C&#43;&#43;%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC14%E7%AB%A0C&#43;&#43;%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/</guid>
      <description>C++的主要目的是促进代码重用。 公有继承是实现这一目标的机制之一； 本身是另一个类的成员，这种方法称为包含、组合、层次化。 另一种方法是使用私有、保护继承。 通常包含、私有继承和保护继承用于实现has-a关系，即新的类型包含另一个类的对象。 多重继承使得能够使用两个或更多的基类派生出新的</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第13章类继承</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC13%E7%AB%A0%E7%B1%BB%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC13%E7%AB%A0%E7%B1%BB%E7%BB%A7%E6%89%BF/</guid>
      <description>1 一个简单得基类 从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。 1.1 派生一个类 class RatedPlayer :public TableTennisPlayer { } 冒号指出RatedPlayer 类的基类是TableTennisPlayer类。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将称为派生</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第12章类和动态内存分配</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC12%E7%AB%A0%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC12%E7%AB%A0%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>1 动态内存和类 C++在分配内存时是让程序在运行时决定内存分配，而不是在编译时决定。这样，可根据程序的需要，而不是根据一系列严格的存储类型规则来使用内存。C++使用new和delete运算符来动态控制内存。 1.1 复习示例和静态类成员 这个程序使用了一个新的存储类型：静态类成员： //strngbad.h #include&amp;lt;iostream&amp;gt; #ifndef STRNGBAD_H_ #define</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第11章使用类</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC11%E7%AB%A0%E4%BD%BF%E7%94%A8%E7%B1%BB/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC11%E7%AB%A0%E4%BD%BF%E7%94%A8%E7%B1%BB/</guid>
      <description>C++ primer plus 第11章使用类 1 运算符重载 operatorop(argumnt-list) 例如，operator+()重载+运算符。 2 计算时间：一个运算符重载示例 如果要计算两个时间之和，如2小时40分与1小时30分之和，可以重载运算符+，在类中的成员函数为： Time operator+(const Time &amp;amp; t) const; 2.1 重载限制 重载后的运算符至少有一个操作数是用户定义的类型，这将防止</description>
    </item>
    
    <item>
      <title>C&#43;&#43; primer plus 第10章对象和类</title>
      <link>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC10%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/C&#43;&#43;/C&#43;&#43;-primer-plus-%E7%AC%AC10%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</guid>
      <description>C++ primer plus 第10章对象和类 1 过程性编程和面向对象编程 2 抽象和类 2.1 ifndef 文件中的#ifndef 头件的中的#ifndef，这是一个很关键的东西。 需要注意的是，#ifndef起到的效果是防止一个源文件两次包含同一个头文件，而不是防止两个源文件包含同一个头文件。 而编译时，这两个C文件要一同编译成</description>
    </item>
    
    <item>
      <title>Markdown文件基本语法</title>
      <link>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/Markdown%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/Markdown%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      <description>&lt;p&gt;因为目前准备写博客，所以不可避免就要使用markdown语言写文章，所以这篇文章将对Markdown的基本语法进行介绍，方便以后查阅。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我的第一次Hugo博客搭建过程（超级详细）</title>
      <link>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/hugo&#43;github-page%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/hugo&#43;github-page%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid>
      <description>最近希望搭建一个自己的技术博客，用来记录在学的一些知识和技术，在比较了一下几个目前较为流行的静态博客Jekyll、Hexo、Hugo之后，还是决定采用Hugo。 Hugo是基于Go语言的一款静态博客，编译之后只有一个二进制文件，相比于Hexo基于nodejs、jekyll基于rub</description>
    </item>
    
    <item>
      <title>Formulas with MathJax</title>
      <link>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/formulas-with-mathjax/</link>
      <pubDate>Sat, 20 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/formulas-with-mathjax/</guid>
      <description>&lt;p&gt;Mathematical equations in form of LaTeX or MathML code can be rendered with the support of &lt;a href=&#34;https://www.mathjax.org&#34;&gt;MathJax&lt;/a&gt;. MathML works out of the box. If you&amp;rsquo;re using LaTeX you need to wrap your equation with &lt;code&gt;$$&lt;/code&gt; as shown in the following example:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Markdown Cheat Sheet</title>
      <link>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/markdown-cheat-sheet/</link>
      <pubDate>Sat, 20 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/markdown-cheat-sheet/</guid>
      <description>&lt;p&gt;This note demonstrates some of what &lt;a href=&#34;http://daringfireball.net/projects/markdown/&#34;&gt;Markdown&lt;/a&gt; is capable of doing.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: Feel free to play with this page. Unlike regular notes, this doesn&amp;rsquo;t automatically save itself.&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Using the gallery shortcode</title>
      <link>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/using-the-gallery-shortcode/</link>
      <pubDate>Sat, 20 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/using-the-gallery-shortcode/</guid>
      <description>&lt;p&gt;This way you can easily include a gallery into your page. Copy the code below into your content file and enter the relative paths to your images.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>How to add pages to the menu</title>
      <link>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/linked-post/</link>
      <pubDate>Fri, 02 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/post/%E5%8D%9A%E5%AE%A2/linked-post/</guid>
      <description>I&amp;rsquo;m a linked post in the menu. You can add other posts by adding the following line to the frontmatter: menu = &amp;quot;main&amp;quot;</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>http://jchenTech.github.io/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>搜索</title>
      <link>http://jchenTech.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://jchenTech.github.io/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
